!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!%      This module `mwd_parameters` encapsulates all SMASH parameters.
!%      This module is wrapped and differentiated.
!%
!%      ParametersDT type:
!%      
!%      </> Public
!%      ======================== =======================================
!%      `Variables`              Description
!%      ======================== =======================================
!%      ``ci``                   Interception parameter          [mm]    (default: 1)     ]0, +Inf[
!%      ``cp``                   Production parameter            [mm]    (default: 200)   ]0, +Inf[
!%      ``beta``                 Percolation parameter           [-]     (default: 1000)  ]0, +Inf[
!%      ``cft``                  Fast transfer parameter         [mm]    (default: 500)   ]0, +Inf[
!%      ``cst``                  Slow transfer parameter         [mm]    (default: 500)   ]0, +Inf[
!%      ``alpha``                Transfer partitioning parameter [-]     (default: 0.9)   ]0, 1[
!%      ``exc``                  Exchange parameter              [mm/dt] (default: 0)     ]-Inf, +Inf[
!%      ``lr``                   Linear routing parameter        [min]   (default: 5)     ]0, +Inf[
!%      ======================== =======================================
!%      
!%      Hyper_ParametersDT type:
!%
!%      </> Public
!%      ======================== =======================================
!%      `Variables`              Description
!%      ======================== =======================================
!%      ``ci``                   Interception parameter          [mm]    (default: 1)     ]0, +Inf[
!%      ``cp``                   Production parameter            [mm]    (default: 200)   ]0, +Inf[
!%      ``beta``                 Percolation parameter           [-]     (default: 1000)  ]0, +Inf[
!%      ``cft``                  Fast transfer parameter         [mm]    (default: 500)   ]0, +Inf[
!%      ``cst``                  Slow transfer parameter         [mm]    (default: 500)   ]0, +Inf[
!%      ``alpha``                Transfer partitioning parameter [-]     (default: 0.9)   ]0, 1[
!%      ``exc``                  Exchange parameter              [mm/dt] (default: 0)     ]-Inf, +Inf[
!%      ``lr``                   Linear routing parameter        [min]   (default: 5)     ]0, +Inf[
!%      ======================== =======================================
!%
!%      contains
!%
!%      [1]  ParametersDT_initialise
!%      [2]  Hyper_ParametersDT_initialise
!%      [3]  parameters_to_matrix
!%      [4]  matrix_to_parameters
!%      [5]  vector_to_parameters
!%      [6]  set0_parameters
!%      [7]  set1_parameters
!%      [8]  hyper_parameters_to_matrix
!%      [10] matrix_to_hyper_parameters
!%      [11] set0_hyper_parameters
!%      [12] set1_hyper_parameters
!%      [13] hyper_parameters_to_parameters
MODULE MWD_PARAMETERS_DIFF
!% only: sp, np
  USE MD_COMMON
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
  IMPLICIT NONE
  TYPE PARAMETERSDT
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: ci
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cp
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: beta
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cft
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cst
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: alpha
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: exc
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: lr
  END TYPE PARAMETERSDT
  TYPE HYPER_PARAMETERSDT
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: ci
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cp
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: beta
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cft
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cst
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: alpha
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: exc
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: lr
  END TYPE HYPER_PARAMETERSDT

CONTAINS
!  Differentiation of parametersdt_initialise in forward (tangent) mode (with options fixinterface):
!   Plus diff mem management of: this.ci:out this.cp:out this.beta:out
!                this.cft:out this.cst:out this.alpha:out this.exc:out
!                this.lr:out
  SUBROUTINE PARAMETERSDT_INITIALISE_D(this, this_d, mesh)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: this
    TYPE(PARAMETERSDT), INTENT(INOUT) :: this_d
    TYPE(MESHDT), INTENT(IN) :: mesh
    ALLOCATE(this_d%ci(mesh%nrow, mesh%ncol))
    ALLOCATE(this%ci(mesh%nrow, mesh%ncol))
    ALLOCATE(this_d%cp(mesh%nrow, mesh%ncol))
    ALLOCATE(this%cp(mesh%nrow, mesh%ncol))
    ALLOCATE(this_d%beta(mesh%nrow, mesh%ncol))
    ALLOCATE(this%beta(mesh%nrow, mesh%ncol))
    ALLOCATE(this_d%cft(mesh%nrow, mesh%ncol))
    ALLOCATE(this%cft(mesh%nrow, mesh%ncol))
    ALLOCATE(this_d%cst(mesh%nrow, mesh%ncol))
    ALLOCATE(this%cst(mesh%nrow, mesh%ncol))
    ALLOCATE(this_d%alpha(mesh%nrow, mesh%ncol))
    ALLOCATE(this%alpha(mesh%nrow, mesh%ncol))
    ALLOCATE(this_d%exc(mesh%nrow, mesh%ncol))
    ALLOCATE(this%exc(mesh%nrow, mesh%ncol))
    ALLOCATE(this_d%lr(mesh%nrow, mesh%ncol))
    ALLOCATE(this%lr(mesh%nrow, mesh%ncol))
    this%ci = 1._sp
    this%cp = 200._sp
    this%beta = 1000._sp
    this%cft = 500._sp
    this%cst = 500._sp
    this%alpha = 0.9_sp
    this%exc = 0._sp
    this%lr = 5._sp
  END SUBROUTINE PARAMETERSDT_INITIALISE_D

!  Differentiation of parametersdt_initialise in reverse (adjoint) mode, forward sweep (with options fixinterface):
!   Plus diff mem management of: this.ci:out this.cp:out this.beta:out
!                this.cft:out this.cst:out this.alpha:out this.exc:out
!                this.lr:out
  SUBROUTINE PARAMETERSDT_INITIALISE_FWD(this, this_b, mesh)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: this
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(INOUT) :: this_b
    ALLOCATE(this_b%ci(mesh%nrow, mesh%ncol))
    this_b%ci = 0.0_4
    ALLOCATE(this%ci(mesh%nrow, mesh%ncol))
    ALLOCATE(this_b%cp(mesh%nrow, mesh%ncol))
    this_b%cp = 0.0_4
    ALLOCATE(this%cp(mesh%nrow, mesh%ncol))
    ALLOCATE(this_b%beta(mesh%nrow, mesh%ncol))
    this_b%beta = 0.0_4
    ALLOCATE(this%beta(mesh%nrow, mesh%ncol))
    ALLOCATE(this_b%cft(mesh%nrow, mesh%ncol))
    this_b%cft = 0.0_4
    ALLOCATE(this%cft(mesh%nrow, mesh%ncol))
    ALLOCATE(this_b%cst(mesh%nrow, mesh%ncol))
    this_b%cst = 0.0_4
    ALLOCATE(this%cst(mesh%nrow, mesh%ncol))
    ALLOCATE(this_b%alpha(mesh%nrow, mesh%ncol))
    this_b%alpha = 0.0_4
    ALLOCATE(this%alpha(mesh%nrow, mesh%ncol))
    ALLOCATE(this_b%exc(mesh%nrow, mesh%ncol))
    this_b%exc = 0.0_4
    ALLOCATE(this%exc(mesh%nrow, mesh%ncol))
    ALLOCATE(this_b%lr(mesh%nrow, mesh%ncol))
    this_b%lr = 0.0_4
    ALLOCATE(this%lr(mesh%nrow, mesh%ncol))
    this%ci = 1._sp
    this%cp = 200._sp
    this%beta = 1000._sp
    this%cft = 500._sp
    this%cst = 500._sp
    this%alpha = 0.9_sp
    this%exc = 0._sp
    this%lr = 5._sp
  END SUBROUTINE PARAMETERSDT_INITIALISE_FWD

!  Differentiation of parametersdt_initialise in reverse (adjoint) mode, backward sweep (with options fixinterface):
!   Plus diff mem management of: this.ci:out this.cp:out this.beta:out
!                this.cft:out this.cst:out this.alpha:out this.exc:out
!                this.lr:out
  SUBROUTINE PARAMETERSDT_INITIALISE_BWD(this, this_b, mesh)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: this
    TYPE(PARAMETERSDT), INTENT(INOUT) :: this_b
    TYPE(MESHDT), INTENT(IN) :: mesh
    DEALLOCATE(this%lr)
    DEALLOCATE(this_b%lr)
    DEALLOCATE(this%exc)
    DEALLOCATE(this_b%exc)
    DEALLOCATE(this%alpha)
    DEALLOCATE(this_b%alpha)
    DEALLOCATE(this%cst)
    DEALLOCATE(this_b%cst)
    DEALLOCATE(this%cft)
    DEALLOCATE(this_b%cft)
    DEALLOCATE(this%beta)
    DEALLOCATE(this_b%beta)
    DEALLOCATE(this%cp)
    DEALLOCATE(this_b%cp)
    DEALLOCATE(this%ci)
    DEALLOCATE(this_b%ci)
  END SUBROUTINE PARAMETERSDT_INITIALISE_BWD

  SUBROUTINE PARAMETERSDT_INITIALISE(this, mesh)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: this
    TYPE(MESHDT), INTENT(IN) :: mesh
    ALLOCATE(this%ci(mesh%nrow, mesh%ncol))
    ALLOCATE(this%cp(mesh%nrow, mesh%ncol))
    ALLOCATE(this%beta(mesh%nrow, mesh%ncol))
    ALLOCATE(this%cft(mesh%nrow, mesh%ncol))
    ALLOCATE(this%cst(mesh%nrow, mesh%ncol))
    ALLOCATE(this%alpha(mesh%nrow, mesh%ncol))
    ALLOCATE(this%exc(mesh%nrow, mesh%ncol))
    ALLOCATE(this%lr(mesh%nrow, mesh%ncol))
    this%ci = 1._sp
    this%cp = 200._sp
    this%beta = 1000._sp
    this%cft = 500._sp
    this%cst = 500._sp
    this%alpha = 0.9_sp
    this%exc = 0._sp
    this%lr = 5._sp
  END SUBROUTINE PARAMETERSDT_INITIALISE

  SUBROUTINE HYPER_PARAMETERSDT_INITIALISE(this, setup)
    IMPLICIT NONE
    TYPE(HYPER_PARAMETERSDT), INTENT(INOUT) :: this
    TYPE(SETUPDT), INTENT(IN) :: setup
    INTEGER :: n
    INTRINSIC TRIM
    SELECT CASE  (TRIM(setup%optimize%mapping)) 
    CASE ('hyper-linear') 
      n = 1 + setup%nd
    CASE ('hyper-polynomial') 
      n = 1 + 2*setup%nd
    END SELECT
    ALLOCATE(this%ci(n, 1))
    ALLOCATE(this%cp(n, 1))
    ALLOCATE(this%beta(n, 1))
    ALLOCATE(this%cft(n, 1))
    ALLOCATE(this%cst(n, 1))
    ALLOCATE(this%alpha(n, 1))
    ALLOCATE(this%exc(n, 1))
    ALLOCATE(this%lr(n, 1))
  END SUBROUTINE HYPER_PARAMETERSDT_INITIALISE

END MODULE MWD_PARAMETERS_DIFF

!%      This module `mwd_states` encapsulates all SMASH states.
!%      This module is wrapped and differentiated.
!%
!%      StatesDT type:
!%      
!%      </> Public
!%      ======================== =======================================
!%      `Variables`              Description
!%      ======================== =======================================
!%      ``hi``                   Interception state    [-]   (default: 0.01)   ]0, 1[
!%      ``hp``                   Production state      [-]   (default: 0.01)   ]0, 1[
!%      ``hft``                  Fast transfer state   [-]   (default: 0.01)   ]0, 1[
!%      ``hst``                  Slow transfer state   [-]   (default: 0.01)   ]0, 1[
!%      ``hlr``                  Linear routing state  [mm]  (default: 0.01)   ]0, +Inf[
!%      ======================== =======================================
!%
!%      Hyper_StatesDT type:
!%      
!%      </> Public
!%      ======================== =======================================
!%      `Variables`              Description
!%      ======================== =======================================
!%      ``hi``                   Interception state    [-]   (default: 0.01)   ]0, 1[
!%      ``hp``                   Production state      [-]   (default: 0.01)   ]0, 1[
!%      ``hft``                  Fast transfer state   [-]   (default: 0.01)   ]0, 1[
!%      ``hst``                  Slow transfer state   [-]   (default: 0.01)   ]0, 1[
!%      ``hlr``                  Linear routing state  [mm]  (default: 0.01)   ]0, +Inf[
!%      ======================== =======================================
!%
!%      contains
!%
!%      [1] StatesDT_initialise
!%      [2] Hyper_StatesDT_initialise
!%      [3] states_to_matrix
!%      [4] matrix_to_states
!%      [5] vector_to_states
!%      [6] set0_states
!%      [7] set1_states
!%      [8]  hyper_states_to_matrix
!%      [10] matrix_to_hyper_states
!%      [11] set0_hyper_states
!%      [12] set1_hyper_states
!%      [13] hyper_states_to_states
MODULE MWD_STATES_DIFF
!% only: sp, ns
  USE MD_COMMON
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
  IMPLICIT NONE
  TYPE STATESDT
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hi
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hp
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hft
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hst
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hlr
  END TYPE STATESDT
  TYPE HYPER_STATESDT
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hi
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hp
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hft
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hst
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hlr
  END TYPE HYPER_STATESDT

CONTAINS
!  Differentiation of statesdt_initialise in forward (tangent) mode (with options fixinterface):
!   Plus diff mem management of: this.hi:out this.hp:out this.hft:out
!                this.hst:out this.hlr:out
  SUBROUTINE STATESDT_INITIALISE_D(this, this_d, mesh)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(INOUT) :: this
    TYPE(STATESDT), INTENT(INOUT) :: this_d
    TYPE(MESHDT), INTENT(IN) :: mesh
    ALLOCATE(this_d%hi(mesh%nrow, mesh%ncol))
    ALLOCATE(this%hi(mesh%nrow, mesh%ncol))
    ALLOCATE(this_d%hp(mesh%nrow, mesh%ncol))
    ALLOCATE(this%hp(mesh%nrow, mesh%ncol))
    ALLOCATE(this_d%hft(mesh%nrow, mesh%ncol))
    ALLOCATE(this%hft(mesh%nrow, mesh%ncol))
    ALLOCATE(this_d%hst(mesh%nrow, mesh%ncol))
    ALLOCATE(this%hst(mesh%nrow, mesh%ncol))
    ALLOCATE(this_d%hlr(mesh%nrow, mesh%ncol))
    ALLOCATE(this%hlr(mesh%nrow, mesh%ncol))
    this%hi = 0.01_sp
    this%hp = 0.01_sp
    this%hft = 0.01_sp
    this%hst = 0.01_sp
    this%hlr = 0.000001_sp
  END SUBROUTINE STATESDT_INITIALISE_D

!  Differentiation of statesdt_initialise in reverse (adjoint) mode, forward sweep (with options fixinterface):
!   Plus diff mem management of: this.hi:out this.hp:out this.hft:out
!                this.hst:out this.hlr:out
  SUBROUTINE STATESDT_INITIALISE_FWD(this, this_b, mesh)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(INOUT) :: this
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(STATESDT), INTENT(INOUT) :: this_b
    ALLOCATE(this_b%hi(mesh%nrow, mesh%ncol))
    this_b%hi = 0.0_4
    ALLOCATE(this%hi(mesh%nrow, mesh%ncol))
    ALLOCATE(this_b%hp(mesh%nrow, mesh%ncol))
    this_b%hp = 0.0_4
    ALLOCATE(this%hp(mesh%nrow, mesh%ncol))
    ALLOCATE(this_b%hft(mesh%nrow, mesh%ncol))
    this_b%hft = 0.0_4
    ALLOCATE(this%hft(mesh%nrow, mesh%ncol))
    ALLOCATE(this_b%hst(mesh%nrow, mesh%ncol))
    this_b%hst = 0.0_4
    ALLOCATE(this%hst(mesh%nrow, mesh%ncol))
    ALLOCATE(this_b%hlr(mesh%nrow, mesh%ncol))
    this_b%hlr = 0.0_4
    ALLOCATE(this%hlr(mesh%nrow, mesh%ncol))
    this%hi = 0.01_sp
    this%hp = 0.01_sp
    this%hft = 0.01_sp
    this%hst = 0.01_sp
    this%hlr = 0.000001_sp
  END SUBROUTINE STATESDT_INITIALISE_FWD

!  Differentiation of statesdt_initialise in reverse (adjoint) mode, backward sweep (with options fixinterface):
!   Plus diff mem management of: this.hi:out this.hp:out this.hft:out
!                this.hst:out this.hlr:out
  SUBROUTINE STATESDT_INITIALISE_BWD(this, this_b, mesh)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(INOUT) :: this
    TYPE(STATESDT), INTENT(INOUT) :: this_b
    TYPE(MESHDT), INTENT(IN) :: mesh
    DEALLOCATE(this%hlr)
    DEALLOCATE(this_b%hlr)
    DEALLOCATE(this%hst)
    DEALLOCATE(this_b%hst)
    DEALLOCATE(this%hft)
    DEALLOCATE(this_b%hft)
    DEALLOCATE(this%hp)
    DEALLOCATE(this_b%hp)
    DEALLOCATE(this%hi)
    DEALLOCATE(this_b%hi)
  END SUBROUTINE STATESDT_INITIALISE_BWD

  SUBROUTINE STATESDT_INITIALISE(this, mesh)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(INOUT) :: this
    TYPE(MESHDT), INTENT(IN) :: mesh
    ALLOCATE(this%hi(mesh%nrow, mesh%ncol))
    ALLOCATE(this%hp(mesh%nrow, mesh%ncol))
    ALLOCATE(this%hft(mesh%nrow, mesh%ncol))
    ALLOCATE(this%hst(mesh%nrow, mesh%ncol))
    ALLOCATE(this%hlr(mesh%nrow, mesh%ncol))
    this%hi = 0.01_sp
    this%hp = 0.01_sp
    this%hft = 0.01_sp
    this%hst = 0.01_sp
    this%hlr = 0.000001_sp
  END SUBROUTINE STATESDT_INITIALISE

  SUBROUTINE HYPER_STATESDT_INITIALISE(this, setup)
    IMPLICIT NONE
    TYPE(HYPER_STATESDT), INTENT(INOUT) :: this
    TYPE(SETUPDT), INTENT(IN) :: setup
    INTEGER :: n
    INTRINSIC TRIM
    SELECT CASE  (TRIM(setup%optimize%mapping)) 
    CASE ('hyper-linear') 
      n = 1 + setup%nd
    CASE ('hyper-polynomial') 
      n = 1 + 2*setup%nd
    END SELECT
    ALLOCATE(this%hi(n, 1))
    ALLOCATE(this%hp(n, 1))
    ALLOCATE(this%hft(n, 1))
    ALLOCATE(this%hst(n, 1))
    ALLOCATE(this%hlr(n, 1))
  END SUBROUTINE HYPER_STATESDT_INITIALISE

END MODULE MWD_STATES_DIFF

!%      This module `mwd_output` encapsulates all SMASH output.
!%      This module is wrapped and differentiated.
!%
!%      OutputDT type:
!%      
!%      </> Public
!%      ========================== =====================================
!%      `Variables`                Description
!%      ========================== =====================================
!%      ``qsim``                   Simulated discharge at gauge            [m3/s]
!%      ``qsim_domain``            Simulated discharge whole domain        [m3/s]
!%      ``sparse_qsim_domain``     Sparse simulated discharge whole domain [m3/s]
!%      ``net_prcp_domain``        Net precipitaition whole domain         [mm/dt]
!%      ``sparse_net_prcp_domain`` Sparse net precipitation whole domain   [mm/dt]
!%      ``parameters_gradient``    Parameters gradients
!%      ``cost``                   Cost value
!%      ``sp1``                    Scalar product <dY*, dY>
!%      ``sp2``                    Scalar product <dk*, dk>
!%      ``an``                     Alpha gradient test 
!%      ``ian``                    Ialpha gradient test
!%      ``fstates``                Final states (StatesDT)
!%      ========================== =====================================
!%
!%      contains
!%
!%      [1] OutputDT_initialise
MODULE MWD_OUTPUT_DIFF
!% only: sp, dp, lchar, np, ns
  USE MD_COMMON
!% only: SetupDT
  USE MWD_SETUP
!%only: MeshDT
  USE MWD_MESH
!%only: StatesDT, StatesDT_initialise
  USE MWD_STATES_DIFF
  IMPLICIT NONE
  TYPE OUTPUTDT
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: qsim
      REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: qsim_domain
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: sparse_qsim_domain
      REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: net_prcp_domain
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: sparse_net_prcp_domain
      REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: parameters_gradient
      REAL(sp) :: cost
      REAL(sp) :: sp1
      REAL(sp) :: sp2
      REAL(sp), DIMENSION(:), ALLOCATABLE :: an
      REAL(sp), DIMENSION(:), ALLOCATABLE :: ian
      TYPE(STATESDT) :: fstates
  END TYPE OUTPUTDT
  TYPE OUTPUTDT_DIFF
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: qsim
  END TYPE OUTPUTDT_DIFF

CONTAINS
  SUBROUTINE OUTPUTDT_INITIALISE(this, setup, mesh)
    IMPLICIT NONE
    TYPE(OUTPUTDT), INTENT(INOUT) :: this
    TYPE(SETUPDT), INTENT(INOUT) :: setup
    TYPE(MESHDT), INTENT(INOUT) :: mesh
    IF (mesh%ng .GT. 0) THEN
      ALLOCATE(this%qsim(mesh%ng, setup%ntime_step))
      this%qsim = -99._sp
    END IF
    IF (setup%save_qsim_domain) THEN
      IF (setup%sparse_storage) THEN
        ALLOCATE(this%sparse_qsim_domain(mesh%nac, setup%ntime_step))
        this%sparse_qsim_domain = -99._sp
      ELSE
        ALLOCATE(this%qsim_domain(mesh%nrow, mesh%ncol, setup%ntime_step&
&       ))
        this%qsim_domain = -99._sp
      END IF
    END IF
    IF (setup%save_net_prcp_domain) THEN
      IF (setup%sparse_storage) THEN
        ALLOCATE(this%sparse_net_prcp_domain(mesh%nac, setup%ntime_step)&
&       )
        this%sparse_net_prcp_domain = -99._sp
      ELSE
        ALLOCATE(this%net_prcp_domain(mesh%nrow, mesh%ncol, setup%&
&       ntime_step))
        this%net_prcp_domain = -99._sp
      END IF
    END IF
    CALL STATESDT_INITIALISE(this%fstates, mesh)
  END SUBROUTINE OUTPUTDT_INITIALISE

END MODULE MWD_OUTPUT_DIFF

!%      This module `md_gr_operator` encapsulates all SMASH GR operator.
!%      This module is differentiated.
!%
!%      contains
!%
!%      [1] gr_interception
!%      [2] gr_production
!%      [3] gr_exchange
!%      [4] gr_transfer
MODULE MD_GR_OPERATOR_DIFF
!% only : sp
  USE MD_COMMON
  IMPLICIT NONE

CONTAINS
!  Differentiation of gr_interception in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: hi ei pn
!   with respect to varying inputs: hi ci
!% TODO comment
  SUBROUTINE GR_INTERCEPTION_D(prcp, pet, ci, ci_d, hi, hi_d, pn, pn_d, &
&   ei, ei_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: prcp, pet, ci
    REAL(sp), INTENT(IN) :: ci_d
    REAL(sp), INTENT(INOUT) :: hi
    REAL(sp), INTENT(INOUT) :: hi_d
    REAL(sp), INTENT(OUT) :: pn, ei
    REAL(sp), INTENT(OUT) :: pn_d, ei_d
    INTRINSIC MIN
    INTRINSIC MAX
    REAL(sp) :: temp
    IF (pet .GT. prcp + hi*ci) THEN
      ei_d = ci*hi_d + hi*ci_d
      ei = prcp + hi*ci
    ELSE
      ei = pet
      ei_d = 0.0_4
    END IF
    IF (0._sp .LT. prcp - ci*(1._sp-hi) - ei) THEN
      pn_d = ci*hi_d - (1._sp-hi)*ci_d - ei_d
      pn = prcp - ci*(1._sp-hi) - ei
    ELSE
      pn = 0._sp
      pn_d = 0.0_4
    END IF
    temp = (prcp-ei-pn)/ci
    hi_d = hi_d + (-ei_d-pn_d-temp*ci_d)/ci
    hi = hi + temp
  END SUBROUTINE GR_INTERCEPTION_D

!  Differentiation of gr_interception in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: hi ei ci pn
!   with respect to varying inputs: hi ci
!% TODO comment
  SUBROUTINE GR_INTERCEPTION_B(prcp, pet, ci, ci_b, hi, hi_b, pn, pn_b, &
&   ei, ei_b)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: prcp, pet, ci
    REAL(sp) :: ci_b
    REAL(sp), INTENT(INOUT) :: hi
    REAL(sp), INTENT(INOUT) :: hi_b
    REAL(sp) :: pn, ei
    REAL(sp) :: pn_b, ei_b
    INTRINSIC MIN
    INTRINSIC MAX
    REAL(sp) :: temp_b
    INTEGER :: branch
    IF (pet .GT. prcp + hi*ci) THEN
      ei = prcp + hi*ci
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      ei = pet
    END IF
    IF (0._sp .LT. prcp - ci*(1._sp-hi) - ei) THEN
      pn = prcp - ci*(1._sp-hi) - ei
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      pn = 0._sp
    END IF
    temp_b = hi_b/ci
    ei_b = ei_b - temp_b
    pn_b = pn_b - temp_b
    ci_b = ci_b - (prcp-ei-pn)*temp_b/ci
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      ci_b = ci_b - (1._sp-hi)*pn_b
      hi_b = hi_b + ci*pn_b
      ei_b = ei_b - pn_b
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      hi_b = hi_b + ci*ei_b
      ci_b = ci_b + hi*ei_b
    END IF
  END SUBROUTINE GR_INTERCEPTION_B

!% TODO comment
  SUBROUTINE GR_INTERCEPTION(prcp, pet, ci, hi, pn, ei)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: prcp, pet, ci
    REAL(sp), INTENT(INOUT) :: hi
    REAL(sp), INTENT(OUT) :: pn, ei
    INTRINSIC MIN
    INTRINSIC MAX
    IF (pet .GT. prcp + hi*ci) THEN
      ei = prcp + hi*ci
    ELSE
      ei = pet
    END IF
    IF (0._sp .LT. prcp - ci*(1._sp-hi) - ei) THEN
      pn = prcp - ci*(1._sp-hi) - ei
    ELSE
      pn = 0._sp
    END IF
    hi = hi + (prcp-ei-pn)/ci
  END SUBROUTINE GR_INTERCEPTION

!  Differentiation of gr_production in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: hp perc pr
!   with respect to varying inputs: hp en beta cp pn
  SUBROUTINE GR_PRODUCTION_D(pn, pn_d, en, en_d, cp, cp_d, beta, beta_d&
&   , hp, hp_d, pr, pr_d, perc, perc_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: pn, en, cp, beta
    REAL(sp), INTENT(IN) :: pn_d, en_d, cp_d, beta_d
    REAL(sp), INTENT(INOUT) :: hp
    REAL(sp), INTENT(INOUT) :: hp_d
    REAL(sp), INTENT(OUT) :: pr, perc
    REAL(sp), INTENT(OUT) :: pr_d, perc_d
    REAL(sp) :: inv_cp, ps, es, hp_imd
    REAL(sp) :: inv_cp_d, ps_d, es_d, hp_imd_d
    INTRINSIC TANH
    REAL(sp) :: pwx1
    REAL(sp) :: pwx1_d
    REAL(sp) :: pwr1
    REAL(sp) :: pwr1_d
    REAL(sp) :: temp
    REAL(sp) :: temp0
    REAL(sp) :: temp1
    REAL(sp) :: temp2
    inv_cp_d = -(cp_d/cp**2)
    inv_cp = 1._sp/cp
    pr = 0._sp
    temp = TANH(pn*inv_cp)
    temp0 = TANH(pn*inv_cp)
    temp1 = cp*(-(hp*hp)+1._sp)
    temp2 = temp1*temp0/(hp*temp+1._sp)
    ps_d = (temp0*((1._sp-hp**2)*cp_d-cp*2*hp*hp_d)+temp1*(1.0-TANH(pn*&
&     inv_cp)**2)*(inv_cp*pn_d+pn*inv_cp_d)-temp2*(temp*hp_d+hp*(1.0-&
&     TANH(pn*inv_cp)**2)*(inv_cp*pn_d+pn*inv_cp_d)))/(hp*temp+1._sp)
    ps = temp2
    temp2 = TANH(en*inv_cp)
    temp1 = TANH(en*inv_cp)
    temp0 = hp*cp*(-hp+2._sp)
    temp = temp0*temp1/((-hp+1._sp)*temp2+1._sp)
    es_d = (temp1*((2._sp-hp)*(cp*hp_d+hp*cp_d)-hp*cp*hp_d)+temp0*(1.0-&
&     TANH(en*inv_cp)**2)*(inv_cp*en_d+en*inv_cp_d)-temp*((1._sp-hp)*(&
&     1.0-TANH(en*inv_cp)**2)*(inv_cp*en_d+en*inv_cp_d)-temp2*hp_d))/((&
&     1._sp-hp)*temp2+1._sp)
    es = temp
    hp_imd_d = hp_d + inv_cp*(ps_d-es_d) + (ps-es)*inv_cp_d
    hp_imd = hp + (ps-es)*inv_cp
    IF (pn .GT. 0) THEN
      pr_d = pn_d - cp*(hp_imd_d-hp_d) - (hp_imd-hp)*cp_d
      pr = pn - (hp_imd-hp)*cp
    ELSE
      pr_d = 0.0_4
    END IF
    pwx1_d = 4*hp_imd**3*(hp_imd_d-hp_imd*beta_d/beta)/beta**4
    pwx1 = 1._sp + (hp_imd/beta)**4
    pwr1_d = -(0.25_sp*pwx1**(-1.25)*pwx1_d)
    pwr1 = pwx1**(-0.25_sp)
    perc_d = (1._sp-pwr1)*(cp*hp_imd_d+hp_imd*cp_d) - hp_imd*cp*pwr1_d
    perc = hp_imd*cp*(1._sp-pwr1)
    hp_d = hp_imd_d - inv_cp*perc_d - perc*inv_cp_d
    hp = hp_imd - perc*inv_cp
  END SUBROUTINE GR_PRODUCTION_D

!  Differentiation of gr_production in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: hp beta cp perc pr
!   with respect to varying inputs: hp en beta cp pn
  SUBROUTINE GR_PRODUCTION_B(pn, pn_b, en, en_b, cp, cp_b, beta, beta_b&
&   , hp, hp_b, pr, pr_b, perc, perc_b)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: pn, en, cp, beta
    REAL(sp) :: pn_b, en_b, cp_b, beta_b
    REAL(sp), INTENT(INOUT) :: hp
    REAL(sp), INTENT(INOUT) :: hp_b
    REAL(sp) :: pr, perc
    REAL(sp) :: pr_b, perc_b
    REAL(sp) :: inv_cp, ps, es, hp_imd
    REAL(sp) :: inv_cp_b, ps_b, es_b, hp_imd_b
    INTRINSIC TANH
    REAL(sp) :: pwx1
    REAL(sp) :: pwx1_b
    REAL(sp) :: pwr1
    REAL(sp) :: pwr1_b
    REAL(sp) :: temp
    REAL(sp) :: temp0
    REAL(sp) :: temp_b
    REAL(sp) :: temp1
    REAL(sp) :: temp2
    REAL(sp) :: temp3
    REAL(sp) :: temp_b0
    REAL(sp) :: temp_b1
    REAL(sp) :: temp4
    REAL(sp) :: temp_b2
    REAL(sp) :: temp_b3
    REAL(sp) :: temp_b4
    REAL(sp) :: temp_b5
    INTEGER :: branch
    inv_cp = 1._sp/cp
    ps = cp*(1._sp-hp*hp)*TANH(pn*inv_cp)/(1._sp+hp*TANH(pn*inv_cp))
    es = hp*cp*(2._sp-hp)*TANH(en*inv_cp)/(1._sp+(1._sp-hp)*TANH(en*&
&     inv_cp))
    hp_imd = hp + (ps-es)*inv_cp
    IF (pn .GT. 0) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    pwx1 = 1._sp + (hp_imd/beta)**4
    pwr1 = pwx1**(-0.25_sp)
    perc = hp_imd*cp*(1._sp-pwr1)
    pwx1 = 1._sp + (hp_imd/beta)**4
    pwr1 = pwx1**(-0.25_sp)
    inv_cp = 1._sp/cp
    perc_b = perc_b - inv_cp*hp_b
    inv_cp_b = -(perc*hp_b)
    cp_b = cp_b + hp_imd*(1._sp-pwr1)*perc_b
    pwr1_b = -(hp_imd*cp*perc_b)
    pwx1_b = -(0.25_sp*pwx1**(-1.25)*pwr1_b)
    temp_b5 = 4*hp_imd**3*pwx1_b/beta**4
    hp_imd_b = hp_b + cp*(1._sp-pwr1)*perc_b + temp_b5
    beta_b = beta_b - hp_imd*temp_b5/beta
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      pn_b = pr_b
      hp_imd_b = hp_imd_b - cp*pr_b
      hp_b = cp*pr_b
      cp_b = cp_b - (hp_imd-hp)*pr_b
    ELSE
      hp_b = 0.0_4
      pn_b = 0.0_4
    END IF
    es_b = -(inv_cp*hp_imd_b)
    temp4 = TANH(en*inv_cp)
    temp3 = (-hp+1._sp)*temp4 + 1._sp
    temp1 = TANH(en*inv_cp)
    temp0 = hp*cp*(-hp+2._sp)
    temp_b3 = es_b/temp3
    temp_b = (2._sp-hp)*temp1*temp_b3
    temp_b0 = -(temp0*temp1*temp_b3/temp3)
    hp_b = hp_b + hp_imd_b + cp*temp_b - hp*cp*temp1*temp_b3 - temp4*&
&     temp_b0
    ps_b = inv_cp*hp_imd_b
    temp_b4 = (1.0-TANH(en*inv_cp)**2)*temp0*temp_b3
    temp_b5 = (1.0-TANH(en*inv_cp)**2)*(1._sp-hp)*temp_b0
    en_b = inv_cp*temp_b5 + inv_cp*temp_b4
    cp_b = cp_b + hp*temp_b
    temp = TANH(pn*inv_cp)
    temp0 = hp*temp + 1._sp
    temp1 = TANH(pn*inv_cp)
    temp2 = cp*(-(hp*hp)+1._sp)
    temp_b = ps_b/temp0
    temp_b0 = (1.0-TANH(pn*inv_cp)**2)*temp2*temp_b
    temp_b1 = -(temp2*temp1*temp_b/temp0)
    hp_b = hp_b + temp*temp_b1 - 2*hp*cp*temp1*temp_b
    temp_b2 = (1.0-TANH(pn*inv_cp)**2)*hp*temp_b1
    inv_cp_b = inv_cp_b + (ps-es)*hp_imd_b + en*temp_b5 + en*temp_b4 + &
&     pn*temp_b2 + pn*temp_b0
    cp_b = cp_b + (1._sp-hp**2)*temp1*temp_b - inv_cp_b/cp**2
    pn_b = pn_b + inv_cp*temp_b2 + inv_cp*temp_b0
  END SUBROUTINE GR_PRODUCTION_B

  SUBROUTINE GR_PRODUCTION(pn, en, cp, beta, hp, pr, perc)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: pn, en, cp, beta
    REAL(sp), INTENT(INOUT) :: hp
    REAL(sp), INTENT(OUT) :: pr, perc
    REAL(sp) :: inv_cp, ps, es, hp_imd
    INTRINSIC TANH
    REAL(sp) :: pwx1
    REAL(sp) :: pwr1
    inv_cp = 1._sp/cp
    pr = 0._sp
    ps = cp*(1._sp-hp*hp)*TANH(pn*inv_cp)/(1._sp+hp*TANH(pn*inv_cp))
    es = hp*cp*(2._sp-hp)*TANH(en*inv_cp)/(1._sp+(1._sp-hp)*TANH(en*&
&     inv_cp))
    hp_imd = hp + (ps-es)*inv_cp
    IF (pn .GT. 0) pr = pn - (hp_imd-hp)*cp
    pwx1 = 1._sp + (hp_imd/beta)**4
    pwr1 = pwx1**(-0.25_sp)
    perc = hp_imd*cp*(1._sp-pwr1)
    hp = hp_imd - perc*inv_cp
  END SUBROUTINE GR_PRODUCTION

!  Differentiation of gr_exchange in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: l
!   with respect to varying inputs: hft exc
  SUBROUTINE GR_EXCHANGE_D(exc, exc_d, hft, hft_d, l, l_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: exc
    REAL(sp), INTENT(IN) :: exc_d
    REAL(sp), INTENT(INOUT) :: hft
    REAL(sp), INTENT(INOUT) :: hft_d
    REAL(sp), INTENT(OUT) :: l
    REAL(sp), INTENT(OUT) :: l_d
    REAL(sp) :: temp
    temp = hft**3.5_sp
    l_d = temp*exc_d + exc*3.5_sp*hft**2.5*hft_d
    l = exc*temp
  END SUBROUTINE GR_EXCHANGE_D

!  Differentiation of gr_exchange in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: l hft exc
!   with respect to varying inputs: hft exc
  SUBROUTINE GR_EXCHANGE_B(exc, exc_b, hft, hft_b, l, l_b)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: exc
    REAL(sp) :: exc_b
    REAL(sp), INTENT(INOUT) :: hft
    REAL(sp), INTENT(INOUT) :: hft_b
    REAL(sp) :: l
    REAL(sp) :: l_b
    exc_b = exc_b + hft**3.5_sp*l_b
    hft_b = hft_b + 3.5_sp*hft**2.5*exc*l_b
  END SUBROUTINE GR_EXCHANGE_B

  SUBROUTINE GR_EXCHANGE(exc, hft, l)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: exc
    REAL(sp), INTENT(INOUT) :: hft
    REAL(sp), INTENT(OUT) :: l
    l = exc*hft**3.5_sp
  END SUBROUTINE GR_EXCHANGE

!  Differentiation of gr_transfer in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: q ht
!   with respect to varying inputs: ht ct pr
  SUBROUTINE GR_TRANSFER_D(n, prcp, pr, pr_d, ct, ct_d, ht, ht_d, q, q_d&
& )
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: n, prcp, pr, ct
    REAL(sp), INTENT(IN) :: pr_d, ct_d
    REAL(sp), INTENT(INOUT) :: ht
    REAL(sp), INTENT(INOUT) :: ht_d
    REAL(sp), INTENT(OUT) :: q
    REAL(sp), INTENT(OUT) :: q_d
    REAL(sp) :: pr_imd, ht_imd, nm1, d1pnm1
    REAL(sp) :: pr_imd_d, ht_imd_d
    INTRINSIC MAX
    REAL(sp) :: pwx1
    REAL(sp) :: pwx1_d
    REAL(sp) :: pwy1
    REAL(sp) :: pwr1
    REAL(sp) :: pwr1_d
    REAL(sp) :: pwy2
    REAL(sp) :: pwr2
    REAL(sp) :: pwr2_d
    REAL(sp) :: pwx3
    REAL(sp) :: pwx3_d
    REAL(sp) :: pwy3
    REAL(sp) :: pwr3
    REAL(sp) :: pwr3_d
    nm1 = n - 1._sp
    d1pnm1 = 1._sp/nm1
    IF (prcp .LT. 0._sp) THEN
      pwx1_d = ct*ht_d + ht*ct_d
      pwx1 = ht*ct
      pwy1 = -nm1
      IF (pwx1 .LE. 0.0 .AND. (pwy1 .EQ. 0.0 .OR. pwy1 .NE. INT(pwy1))) &
&     THEN
        pwr1_d = 0.0_4
      ELSE
        pwr1_d = pwy1*pwx1**(pwy1-1)*pwx1_d
      END IF
      pwr1 = pwx1**pwy1
      pwy2 = -nm1
      IF (ct .LE. 0.0 .AND. (pwy2 .EQ. 0.0 .OR. pwy2 .NE. INT(pwy2))) &
&     THEN
        pwr2_d = 0.0_4
      ELSE
        pwr2_d = pwy2*ct**(pwy2-1)*ct_d
      END IF
      pwr2 = ct**pwy2
      pwx3_d = pwr1_d - pwr2_d
      pwx3 = pwr1 - pwr2
      pwy3 = -d1pnm1
      IF (pwx3 .LE. 0.0 .AND. (pwy3 .EQ. 0.0 .OR. pwy3 .NE. INT(pwy3))) &
&     THEN
        pwr3_d = 0.0_4
      ELSE
        pwr3_d = pwy3*pwx3**(pwy3-1)*pwx3_d
      END IF
      pwr3 = pwx3**pwy3
      pr_imd_d = pwr3_d - ct*ht_d - ht*ct_d
      pr_imd = pwr3 - ht*ct
    ELSE
      pr_imd_d = pr_d
      pr_imd = pr
    END IF
    IF (1.e-6_sp .LT. ht + pr_imd/ct) THEN
      ht_imd_d = ht_d + (pr_imd_d-pr_imd*ct_d/ct)/ct
      ht_imd = ht + pr_imd/ct
    ELSE
      ht_imd = 1.e-6_sp
      ht_imd_d = 0.0_4
    END IF
    pwx1_d = ct*ht_imd_d + ht_imd*ct_d
    pwx1 = ht_imd*ct
    pwy1 = -nm1
    IF (pwx1 .LE. 0.0 .AND. (pwy1 .EQ. 0.0 .OR. pwy1 .NE. INT(pwy1))) &
&   THEN
      pwr1_d = 0.0_4
    ELSE
      pwr1_d = pwy1*pwx1**(pwy1-1)*pwx1_d
    END IF
    pwr1 = pwx1**pwy1
    pwy2 = -nm1
    IF (ct .LE. 0.0 .AND. (pwy2 .EQ. 0.0 .OR. pwy2 .NE. INT(pwy2))) THEN
      pwr2_d = 0.0_4
    ELSE
      pwr2_d = pwy2*ct**(pwy2-1)*ct_d
    END IF
    pwr2 = ct**pwy2
    pwx3_d = pwr1_d + pwr2_d
    pwx3 = pwr1 + pwr2
    pwy3 = -d1pnm1
    IF (pwx3 .LE. 0.0 .AND. (pwy3 .EQ. 0.0 .OR. pwy3 .NE. INT(pwy3))) &
&   THEN
      pwr3_d = 0.0_4
    ELSE
      pwr3_d = pwy3*pwx3**(pwy3-1)*pwx3_d
    END IF
    pwr3 = pwx3**pwy3
    ht_d = (pwr3_d-pwr3*ct_d/ct)/ct
    ht = pwr3/ct
    q_d = ct*(ht_imd_d-ht_d) + (ht_imd-ht)*ct_d
    q = (ht_imd-ht)*ct
  END SUBROUTINE GR_TRANSFER_D

!  Differentiation of gr_transfer in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: q ht ct
!   with respect to varying inputs: ht ct pr
  SUBROUTINE GR_TRANSFER_B(n, prcp, pr, pr_b, ct, ct_b, ht, ht_b, q, q_b&
& )
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: n, prcp, pr, ct
    REAL(sp) :: pr_b, ct_b
    REAL(sp), INTENT(INOUT) :: ht
    REAL(sp), INTENT(INOUT) :: ht_b
    REAL(sp) :: q
    REAL(sp) :: q_b
    REAL(sp) :: pr_imd, ht_imd, nm1, d1pnm1
    REAL(sp) :: pr_imd_b, ht_imd_b
    INTRINSIC MAX
    REAL(sp) :: pwx1
    REAL(sp) :: pwx1_b
    REAL(sp) :: pwy1
    REAL(sp) :: pwr1
    REAL(sp) :: pwr1_b
    REAL(sp) :: pwy2
    REAL(sp) :: pwr2
    REAL(sp) :: pwr2_b
    REAL(sp) :: pwx3
    REAL(sp) :: pwx3_b
    REAL(sp) :: pwy3
    REAL(sp) :: pwr3
    REAL(sp) :: pwr3_b
    INTEGER :: branch
    nm1 = n - 1._sp
    d1pnm1 = 1._sp/nm1
    IF (prcp .LT. 0._sp) THEN
      pwx1 = ht*ct
      pwy1 = -nm1
      pwr1 = pwx1**pwy1
      pwy2 = -nm1
      pwr2 = ct**pwy2
      pwx3 = pwr1 - pwr2
      pwy3 = -d1pnm1
      pwr3 = pwx3**pwy3
      pr_imd = pwr3 - ht*ct
      CALL PUSHCONTROL1B(1)
    ELSE
      pr_imd = pr
      CALL PUSHCONTROL1B(0)
    END IF
    IF (1.e-6_sp .LT. ht + pr_imd/ct) THEN
      ht_imd = ht + pr_imd/ct
      CALL PUSHCONTROL1B(0)
    ELSE
      ht_imd = 1.e-6_sp
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL4(pwx1)
    pwx1 = ht_imd*ct
    CALL PUSHREAL4(pwy1)
    pwy1 = -nm1
    pwr1 = pwx1**pwy1
    CALL PUSHREAL4(pwy2)
    pwy2 = -nm1
    pwr2 = ct**pwy2
    CALL PUSHREAL4(pwx3)
    pwx3 = pwr1 + pwr2
    CALL PUSHREAL4(pwy3)
    pwy3 = -d1pnm1
    pwr3 = pwx3**pwy3
    CALL PUSHREAL4(ht)
    ht = pwr3/ct
    pwx1 = ht_imd*ct
    nm1 = n - 1._sp
    pwy1 = -nm1
    pwy2 = -nm1
    d1pnm1 = 1._sp/nm1
    pwy3 = -d1pnm1
    ht_b = ht_b - ct*q_b
    pwr3_b = ht_b/ct
    IF (pwx3 .LE. 0.0 .AND. (pwy3 .EQ. 0.0 .OR. pwy3 .NE. INT(pwy3))) &
&   THEN
      pwx3_b = 0.0_4
    ELSE
      pwx3_b = pwy3*pwx3**(pwy3-1)*pwr3_b
    END IF
    pwr1_b = pwx3_b
    pwr2_b = pwx3_b
    IF (pwx1 .LE. 0.0 .AND. (pwy1 .EQ. 0.0 .OR. pwy1 .NE. INT(pwy1))) &
&   THEN
      pwx1_b = 0.0_4
    ELSE
      pwx1_b = pwy1*pwx1**(pwy1-1)*pwr1_b
    END IF
    ht_imd_b = ct*q_b + ct*pwx1_b
    IF (ct .LE. 0.0 .AND. (pwy2 .EQ. 0.0 .OR. pwy2 .NE. INT(pwy2))) THEN
      ct_b = ct_b + (ht_imd-ht)*q_b + ht_imd*pwx1_b - pwr3*ht_b/ct**2
    ELSE
      ct_b = ct_b + (ht_imd-ht)*q_b + pwy2*ct**(pwy2-1)*pwr2_b - pwr3*&
&       ht_b/ct**2 + ht_imd*pwx1_b
    END IF
    CALL POPREAL4(ht)
    CALL POPREAL4(pwy3)
    CALL POPREAL4(pwx3)
    CALL POPREAL4(pwy2)
    CALL POPREAL4(pwy1)
    CALL POPREAL4(pwx1)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      ht_b = ht_imd_b
      pr_imd_b = ht_imd_b/ct
      ct_b = ct_b - pr_imd*ht_imd_b/ct**2
    ELSE
      ht_b = 0.0_4
      pr_imd_b = 0.0_4
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      pr_b = pr_imd_b
    ELSE
      pwr3_b = pr_imd_b
      IF (pwx3 .LE. 0.0 .AND. (pwy3 .EQ. 0.0 .OR. pwy3 .NE. INT(pwy3))) &
&     THEN
        pwx3_b = 0.0_4
      ELSE
        pwx3_b = pwy3*pwx3**(pwy3-1)*pwr3_b
      END IF
      pwr1_b = pwx3_b
      pwr2_b = -pwx3_b
      IF (pwx1 .LE. 0.0 .AND. (pwy1 .EQ. 0.0 .OR. pwy1 .NE. INT(pwy1))) &
&     THEN
        pwx1_b = 0.0_4
      ELSE
        pwx1_b = pwy1*pwx1**(pwy1-1)*pwr1_b
      END IF
      ht_b = ht_b + ct*pwx1_b - ct*pr_imd_b
      IF (ct .LE. 0.0 .AND. (pwy2 .EQ. 0.0 .OR. pwy2 .NE. INT(pwy2))) &
&     THEN
        ct_b = ct_b + ht*pwx1_b - ht*pr_imd_b
      ELSE
        ct_b = ct_b + pwy2*ct**(pwy2-1)*pwr2_b - ht*pr_imd_b + ht*pwx1_b
      END IF
      pr_b = 0.0_4
    END IF
  END SUBROUTINE GR_TRANSFER_B

  SUBROUTINE GR_TRANSFER(n, prcp, pr, ct, ht, q)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: n, prcp, pr, ct
    REAL(sp), INTENT(INOUT) :: ht
    REAL(sp), INTENT(OUT) :: q
    REAL(sp) :: pr_imd, ht_imd, nm1, d1pnm1
    INTRINSIC MAX
    REAL(sp) :: pwx1
    REAL(sp) :: pwy1
    REAL(sp) :: pwr1
    REAL(sp) :: pwy2
    REAL(sp) :: pwr2
    REAL(sp) :: pwx3
    REAL(sp) :: pwy3
    REAL(sp) :: pwr3
    nm1 = n - 1._sp
    d1pnm1 = 1._sp/nm1
    IF (prcp .LT. 0._sp) THEN
      pwx1 = ht*ct
      pwy1 = -nm1
      pwr1 = pwx1**pwy1
      pwy2 = -nm1
      pwr2 = ct**pwy2
      pwx3 = pwr1 - pwr2
      pwy3 = -d1pnm1
      pwr3 = pwx3**pwy3
      pr_imd = pwr3 - ht*ct
    ELSE
      pr_imd = pr
    END IF
    IF (1.e-6_sp .LT. ht + pr_imd/ct) THEN
      ht_imd = ht + pr_imd/ct
    ELSE
      ht_imd = 1.e-6_sp
    END IF
    pwx1 = ht_imd*ct
    pwy1 = -nm1
    pwr1 = pwx1**pwy1
    pwy2 = -nm1
    pwr2 = ct**pwy2
    pwx3 = pwr1 + pwr2
    pwy3 = -d1pnm1
    pwr3 = pwx3**pwy3
    ht = pwr3/ct
    q = (ht_imd-ht)*ct
  END SUBROUTINE GR_TRANSFER

END MODULE MD_GR_OPERATOR_DIFF

!%      This module `md_routing_operator` encapsulates all SMASH routing operator.
!%      This module is differentiated.
!%
!%      contains
!%
!%      [1] upstream_discharge
!%      [2] sparse_upstream_discharge
!%      [3] linear_routing
MODULE MD_ROUTING_OPERATOR_DIFF
!% only : sp
  USE MD_COMMON
  IMPLICIT NONE

CONTAINS
!  Differentiation of upstream_discharge in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: qup
!   with respect to varying inputs: q
  SUBROUTINE UPSTREAM_DISCHARGE_D(dt, dx, nrow, ncol, flwdir, &
&   drained_area, row, col, q, q_d, qup, qup_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt, dx
    INTEGER, INTENT(IN) :: nrow, ncol, row, col
    INTEGER, DIMENSION(nrow, ncol), INTENT(IN) :: flwdir, drained_area
    REAL(sp), DIMENSION(nrow, ncol), INTENT(IN) :: q
    REAL(sp), DIMENSION(nrow, ncol), INTENT(IN) :: q_d
    REAL(sp), INTENT(OUT) :: qup
    REAL(sp), INTENT(OUT) :: qup_d
    INTEGER :: i, row_imd, col_imd
    INTEGER, DIMENSION(8), SAVE :: dcol=(/0, -1, -1, -1, 0, 1, 1, 1/)
    INTEGER, DIMENSION(8), SAVE :: drow=(/1, 1, 0, -1, -1, -1, 0, 1/)
    INTEGER, DIMENSION(8), SAVE :: dkind=(/1, 2, 3, 4, 5, 6, 7, 8/)
    INTRINSIC REAL
    REAL*4 :: temp
    qup = 0._sp
    IF (drained_area(row, col) .GT. 1) THEN
      qup_d = 0.0_4
      DO i=1,8
        col_imd = col + dcol(i)
        row_imd = row + drow(i)
        IF (col_imd .GT. 0 .AND. col_imd .LE. ncol .AND. row_imd .GT. 0 &
&           .AND. row_imd .LE. nrow) THEN
          IF (flwdir(row_imd, col_imd) .EQ. dkind(i)) THEN
            qup_d = qup_d + q_d(row_imd, col_imd)
            qup = qup + q(row_imd, col_imd)
          END IF
        END IF
      END DO
      temp = 0.001_sp*(dx*dx)*REAL(drained_area(row, col)-1)
      qup_d = dt*qup_d/temp
      qup = dt*(qup/temp)
    ELSE
      qup_d = 0.0_4
    END IF
  END SUBROUTINE UPSTREAM_DISCHARGE_D

!  Differentiation of upstream_discharge in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: q qup
!   with respect to varying inputs: q
  SUBROUTINE UPSTREAM_DISCHARGE_B(dt, dx, nrow, ncol, flwdir, &
&   drained_area, row, col, q, q_b, qup, qup_b)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt, dx
    INTEGER, INTENT(IN) :: nrow, ncol, row, col
    INTEGER, DIMENSION(nrow, ncol), INTENT(IN) :: flwdir, drained_area
    REAL(sp), DIMENSION(nrow, ncol), INTENT(IN) :: q
    REAL(sp), DIMENSION(nrow, ncol) :: q_b
    REAL(sp) :: qup
    REAL(sp) :: qup_b
    INTEGER :: i, row_imd, col_imd
    INTEGER, DIMENSION(8), SAVE :: dcol=(/0, -1, -1, -1, 0, 1, 1, 1/)
    INTEGER, DIMENSION(8), SAVE :: drow=(/1, 1, 0, -1, -1, -1, 0, 1/)
    INTEGER, DIMENSION(8), SAVE :: dkind=(/1, 2, 3, 4, 5, 6, 7, 8/)
    INTRINSIC REAL
    INTEGER :: branch
    IF (drained_area(row, col) .GT. 1) THEN
      DO i=1,8
        CALL PUSHINTEGER4(col_imd)
        col_imd = col + dcol(i)
        CALL PUSHINTEGER4(row_imd)
        row_imd = row + drow(i)
        IF (col_imd .GT. 0 .AND. col_imd .LE. ncol .AND. row_imd .GT. 0 &
&           .AND. row_imd .LE. nrow) THEN
          IF (flwdir(row_imd, col_imd) .EQ. dkind(i)) THEN
            CALL PUSHCONTROL2B(2)
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(0)
        END IF
      END DO
      qup_b = dt*qup_b/(0.001_sp*dx**2*REAL(drained_area(row, col)-1))
      DO i=8,1,-1
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .NE. 1) q_b(row_imd, col_imd) = q_b(row_imd, &
&             col_imd) + qup_b
        END IF
        CALL POPINTEGER4(row_imd)
        CALL POPINTEGER4(col_imd)
      END DO
    END IF
  END SUBROUTINE UPSTREAM_DISCHARGE_B

  SUBROUTINE UPSTREAM_DISCHARGE(dt, dx, nrow, ncol, flwdir, drained_area&
&   , row, col, q, qup)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt, dx
    INTEGER, INTENT(IN) :: nrow, ncol, row, col
    INTEGER, DIMENSION(nrow, ncol), INTENT(IN) :: flwdir, drained_area
    REAL(sp), DIMENSION(nrow, ncol), INTENT(IN) :: q
    REAL(sp), INTENT(OUT) :: qup
    INTEGER :: i, row_imd, col_imd
    INTEGER, DIMENSION(8), SAVE :: dcol=(/0, -1, -1, -1, 0, 1, 1, 1/)
    INTEGER, DIMENSION(8), SAVE :: drow=(/1, 1, 0, -1, -1, -1, 0, 1/)
    INTEGER, DIMENSION(8), SAVE :: dkind=(/1, 2, 3, 4, 5, 6, 7, 8/)
    INTRINSIC REAL
    qup = 0._sp
    IF (drained_area(row, col) .GT. 1) THEN
      DO i=1,8
        col_imd = col + dcol(i)
        row_imd = row + drow(i)
        IF (col_imd .GT. 0 .AND. col_imd .LE. ncol .AND. row_imd .GT. 0 &
&           .AND. row_imd .LE. nrow) THEN
          IF (flwdir(row_imd, col_imd) .EQ. dkind(i)) qup = qup + q(&
&             row_imd, col_imd)
        END IF
      END DO
      qup = qup*dt/(0.001_sp*dx*dx*REAL(drained_area(row, col)-1))
    END IF
  END SUBROUTINE UPSTREAM_DISCHARGE

!  Differentiation of sparse_upstream_discharge in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: qup
!   with respect to varying inputs: q
  SUBROUTINE SPARSE_UPSTREAM_DISCHARGE_D(dt, dx, nrow, ncol, nac, flwdir&
&   , drained_area, ind_sparse, row, col, q, q_d, qup, qup_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt, dx
    INTEGER, INTENT(IN) :: nrow, ncol, nac, row, col
    INTEGER, DIMENSION(nrow, ncol), INTENT(IN) :: flwdir, drained_area, &
&   ind_sparse
    REAL(sp), DIMENSION(nac), INTENT(IN) :: q
    REAL(sp), DIMENSION(nac), INTENT(IN) :: q_d
    REAL(sp), INTENT(OUT) :: qup
    REAL(sp), INTENT(OUT) :: qup_d
    INTEGER :: i, row_imd, col_imd, k
    INTEGER, DIMENSION(8), SAVE :: dcol=(/0, -1, -1, -1, 0, 1, 1, 1/)
    INTEGER, DIMENSION(8), SAVE :: drow=(/1, 1, 0, -1, -1, -1, 0, 1/)
    INTEGER, DIMENSION(8), SAVE :: dkind=(/1, 2, 3, 4, 5, 6, 7, 8/)
    INTRINSIC REAL
    REAL*4 :: temp
    qup = 0._sp
    IF (drained_area(row, col) .GT. 1) THEN
      qup_d = 0.0_4
      DO i=1,8
        col_imd = col + dcol(i)
        row_imd = row + drow(i)
        IF (col_imd .GT. 0 .AND. col_imd .LE. ncol .AND. row_imd .GT. 0 &
&           .AND. row_imd .LE. nrow) THEN
          IF (flwdir(row_imd, col_imd) .EQ. dkind(i)) THEN
            k = ind_sparse(row_imd, col_imd)
            qup_d = qup_d + q_d(k)
            qup = qup + q(k)
          END IF
        END IF
      END DO
      temp = 0.001_sp*(dx*dx)*REAL(drained_area(row, col)-1)
      qup_d = dt*qup_d/temp
      qup = dt*(qup/temp)
    ELSE
      qup_d = 0.0_4
    END IF
  END SUBROUTINE SPARSE_UPSTREAM_DISCHARGE_D

!  Differentiation of sparse_upstream_discharge in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: q qup
!   with respect to varying inputs: q
  SUBROUTINE SPARSE_UPSTREAM_DISCHARGE_B(dt, dx, nrow, ncol, nac, flwdir&
&   , drained_area, ind_sparse, row, col, q, q_b, qup, qup_b)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt, dx
    INTEGER, INTENT(IN) :: nrow, ncol, nac, row, col
    INTEGER, DIMENSION(nrow, ncol), INTENT(IN) :: flwdir, drained_area, &
&   ind_sparse
    REAL(sp), DIMENSION(nac), INTENT(IN) :: q
    REAL(sp), DIMENSION(nac) :: q_b
    REAL(sp) :: qup
    REAL(sp) :: qup_b
    INTEGER :: i, row_imd, col_imd, k
    INTEGER, DIMENSION(8), SAVE :: dcol=(/0, -1, -1, -1, 0, 1, 1, 1/)
    INTEGER, DIMENSION(8), SAVE :: drow=(/1, 1, 0, -1, -1, -1, 0, 1/)
    INTEGER, DIMENSION(8), SAVE :: dkind=(/1, 2, 3, 4, 5, 6, 7, 8/)
    INTRINSIC REAL
    INTEGER :: branch
    IF (drained_area(row, col) .GT. 1) THEN
      DO i=1,8
        col_imd = col + dcol(i)
        row_imd = row + drow(i)
        IF (col_imd .GT. 0 .AND. col_imd .LE. ncol .AND. row_imd .GT. 0 &
&           .AND. row_imd .LE. nrow) THEN
          IF (flwdir(row_imd, col_imd) .EQ. dkind(i)) THEN
            CALL PUSHINTEGER4(k)
            k = ind_sparse(row_imd, col_imd)
            CALL PUSHCONTROL2B(2)
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(0)
        END IF
      END DO
      qup_b = dt*qup_b/(0.001_sp*dx**2*REAL(drained_area(row, col)-1))
      DO i=8,1,-1
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .NE. 1) THEN
            q_b(k) = q_b(k) + qup_b
            CALL POPINTEGER4(k)
          END IF
        END IF
      END DO
    END IF
  END SUBROUTINE SPARSE_UPSTREAM_DISCHARGE_B

  SUBROUTINE SPARSE_UPSTREAM_DISCHARGE(dt, dx, nrow, ncol, nac, flwdir, &
&   drained_area, ind_sparse, row, col, q, qup)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt, dx
    INTEGER, INTENT(IN) :: nrow, ncol, nac, row, col
    INTEGER, DIMENSION(nrow, ncol), INTENT(IN) :: flwdir, drained_area, &
&   ind_sparse
    REAL(sp), DIMENSION(nac), INTENT(IN) :: q
    REAL(sp), INTENT(OUT) :: qup
    INTEGER :: i, row_imd, col_imd, k
    INTEGER, DIMENSION(8), SAVE :: dcol=(/0, -1, -1, -1, 0, 1, 1, 1/)
    INTEGER, DIMENSION(8), SAVE :: drow=(/1, 1, 0, -1, -1, -1, 0, 1/)
    INTEGER, DIMENSION(8), SAVE :: dkind=(/1, 2, 3, 4, 5, 6, 7, 8/)
    INTRINSIC REAL
    qup = 0._sp
    IF (drained_area(row, col) .GT. 1) THEN
      DO i=1,8
        col_imd = col + dcol(i)
        row_imd = row + drow(i)
        IF (col_imd .GT. 0 .AND. col_imd .LE. ncol .AND. row_imd .GT. 0 &
&           .AND. row_imd .LE. nrow) THEN
          IF (flwdir(row_imd, col_imd) .EQ. dkind(i)) THEN
            k = ind_sparse(row_imd, col_imd)
            qup = qup + q(k)
          END IF
        END IF
      END DO
      qup = qup*dt/(0.001_sp*dx*dx*REAL(drained_area(row, col)-1))
    END IF
  END SUBROUTINE SPARSE_UPSTREAM_DISCHARGE

!  Differentiation of linear_routing in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: hr qrout
!   with respect to varying inputs: qup hr lr
  SUBROUTINE LINEAR_ROUTING_D(dt, qup, qup_d, lr, lr_d, hr, hr_d, qrout&
&   , qrout_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt
    REAL(sp), INTENT(IN) :: qup, lr
    REAL(sp), INTENT(IN) :: qup_d, lr_d
    REAL(sp), INTENT(INOUT) :: hr
    REAL(sp), INTENT(INOUT) :: hr_d
    REAL(sp), INTENT(OUT) :: qrout
    REAL(sp), INTENT(OUT) :: qrout_d
    REAL(sp) :: hr_imd
    REAL(sp) :: hr_imd_d
    INTRINSIC EXP
    REAL(sp) :: arg1
    REAL(sp) :: arg1_d
    REAL(sp) :: temp
    hr_imd_d = hr_d + qup_d
    hr_imd = hr + qup
    temp = dt/(60._sp*lr)
    arg1_d = temp*lr_d/lr
    arg1 = -temp
    temp = EXP(arg1)
    hr_d = temp*hr_imd_d + hr_imd*EXP(arg1)*arg1_d
    hr = hr_imd*temp
    qrout_d = hr_imd_d - hr_d
    qrout = hr_imd - hr
  END SUBROUTINE LINEAR_ROUTING_D

!  Differentiation of linear_routing in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: hr qrout lr
!   with respect to varying inputs: qup hr lr
  SUBROUTINE LINEAR_ROUTING_B(dt, qup, qup_b, lr, lr_b, hr, hr_b, qrout&
&   , qrout_b)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt
    REAL(sp), INTENT(IN) :: qup, lr
    REAL(sp) :: qup_b, lr_b
    REAL(sp), INTENT(INOUT) :: hr
    REAL(sp), INTENT(INOUT) :: hr_b
    REAL(sp) :: qrout
    REAL(sp) :: qrout_b
    REAL(sp) :: hr_imd
    REAL(sp) :: hr_imd_b
    INTRINSIC EXP
    REAL(sp) :: arg1
    REAL(sp) :: arg1_b
    hr_imd = hr + qup
    arg1 = -(dt/(lr*60._sp))
    arg1 = -(dt/(lr*60._sp))
    hr_b = hr_b - qrout_b
    hr_imd_b = qrout_b + EXP(arg1)*hr_b
    arg1_b = EXP(arg1)*hr_imd*hr_b
    lr_b = lr_b + dt*arg1_b/(lr**2*60._sp)
    hr_b = hr_imd_b
    qup_b = hr_imd_b
  END SUBROUTINE LINEAR_ROUTING_B

  SUBROUTINE LINEAR_ROUTING(dt, qup, lr, hr, qrout)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt
    REAL(sp), INTENT(IN) :: qup, lr
    REAL(sp), INTENT(INOUT) :: hr
    REAL(sp), INTENT(OUT) :: qrout
    REAL(sp) :: hr_imd
    INTRINSIC EXP
    REAL(sp) :: arg1
    hr_imd = hr + qup
    arg1 = -(dt/(lr*60._sp))
    hr = hr_imd*EXP(arg1)
    qrout = hr_imd - hr
  END SUBROUTINE LINEAR_ROUTING

END MODULE MD_ROUTING_OPERATOR_DIFF

MODULE MWD_PARAMETERS_MANIPULATION_DIFF
  USE MD_COMMON
  USE MWD_SETUP
  USE MWD_INPUT_DATA
  USE MWD_PARAMETERS_DIFF
  IMPLICIT NONE
  INTERFACE SET_PARAMETERS
      MODULE PROCEDURE SET0D_PARAMETERS
      MODULE PROCEDURE SET1D_PARAMETERS
      MODULE PROCEDURE SET3D_PARAMETERS
  END INTERFACE SET_PARAMETERS

  INTERFACE SET_PARAMETERS_D
      MODULE PROCEDURE SET3D_PARAMETERS_D
  END INTERFACE

  INTERFACE SET_PARAMETERS_B
      MODULE PROCEDURE SET3D_PARAMETERS_B
  END INTERFACE

  INTERFACE SET_HYPER_PARAMETERS
      MODULE PROCEDURE SET0D_HYPER_PARAMETERS
      MODULE PROCEDURE SET1D_HYPER_PARAMETERS
      MODULE PROCEDURE SET3D_HYPER_PARAMETERS
  END INTERFACE SET_HYPER_PARAMETERS


CONTAINS
!  Differentiation of get_parameters in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: a
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.lr)
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.lr:in
!%      TODO comment  
  SUBROUTINE GET_PARAMETERS_D(parameters, parameters_d, a, a_d)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters_d
    REAL(sp), DIMENSION(:, :, :), INTENT(INOUT) :: a
    REAL(sp), DIMENSION(:, :, :), INTENT(INOUT) :: a_d
    a_d = 0.0_4
    a_d(:, :, 1) = parameters_d%ci(:, :)
    a(:, :, 1) = parameters%ci(:, :)
    a_d(:, :, 2) = parameters_d%cp(:, :)
    a(:, :, 2) = parameters%cp(:, :)
    a_d(:, :, 3) = parameters_d%beta(:, :)
    a(:, :, 3) = parameters%beta(:, :)
    a_d(:, :, 4) = parameters_d%cft(:, :)
    a(:, :, 4) = parameters%cft(:, :)
    a_d(:, :, 5) = parameters_d%cst(:, :)
    a(:, :, 5) = parameters%cst(:, :)
    a_d(:, :, 6) = parameters_d%alpha(:, :)
    a(:, :, 6) = parameters%alpha(:, :)
    a_d(:, :, 7) = parameters_d%exc(:, :)
    a(:, :, 7) = parameters%exc(:, :)
    a_d(:, :, 8) = parameters_d%lr(:, :)
    a(:, :, 8) = parameters%lr(:, :)
  END SUBROUTINE GET_PARAMETERS_D

!  Differentiation of get_parameters in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: a
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.lr)
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.lr:in
!%      TODO comment  
  SUBROUTINE GET_PARAMETERS_B(parameters, parameters_b, a, a_b)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(PARAMETERSDT) :: parameters_b
    REAL(sp), DIMENSION(:, :, :), INTENT(INOUT) :: a
    REAL(sp), DIMENSION(:, :, :), INTENT(INOUT) :: a_b
    parameters_b%lr = 0.0_4
    parameters_b%lr = parameters_b%lr + a_b(:, :, 8)
    a_b(:, :, 8) = 0.0_4
    parameters_b%exc = 0.0_4
    parameters_b%exc = parameters_b%exc + a_b(:, :, 7)
    a_b(:, :, 7) = 0.0_4
    parameters_b%alpha = 0.0_4
    parameters_b%alpha = parameters_b%alpha + a_b(:, :, 6)
    a_b(:, :, 6) = 0.0_4
    parameters_b%cst = 0.0_4
    parameters_b%cst = parameters_b%cst + a_b(:, :, 5)
    a_b(:, :, 5) = 0.0_4
    parameters_b%cft = 0.0_4
    parameters_b%cft = parameters_b%cft + a_b(:, :, 4)
    a_b(:, :, 4) = 0.0_4
    parameters_b%beta = 0.0_4
    parameters_b%beta = parameters_b%beta + a_b(:, :, 3)
    a_b(:, :, 3) = 0.0_4
    parameters_b%cp = 0.0_4
    parameters_b%cp = parameters_b%cp + a_b(:, :, 2)
    a_b(:, :, 2) = 0.0_4
    parameters_b%ci = 0.0_4
    parameters_b%ci = parameters_b%ci + a_b(:, :, 1)
  END SUBROUTINE GET_PARAMETERS_B

!%      TODO comment  
  SUBROUTINE GET_PARAMETERS(parameters, a)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    REAL(sp), DIMENSION(:, :, :), INTENT(INOUT) :: a
    a(:, :, 1) = parameters%ci(:, :)
    a(:, :, 2) = parameters%cp(:, :)
    a(:, :, 3) = parameters%beta(:, :)
    a(:, :, 4) = parameters%cft(:, :)
    a(:, :, 5) = parameters%cst(:, :)
    a(:, :, 6) = parameters%alpha(:, :)
    a(:, :, 7) = parameters%exc(:, :)
    a(:, :, 8) = parameters%lr(:, :)
  END SUBROUTINE GET_PARAMETERS

!  Differentiation of set3d_parameters in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.lr)
!   with respect to varying inputs: a
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.lr:in
  SUBROUTINE SET3D_PARAMETERS_D(parameters, parameters_d, a, a_d)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_d
    REAL(sp), DIMENSION(:, :, :), INTENT(IN) :: a
    REAL(sp), DIMENSION(:, :, :), INTENT(IN) :: a_d
    parameters_d%ci = 0.0_4
    parameters_d%ci(:, :) = a_d(:, :, 1)
    parameters%ci(:, :) = a(:, :, 1)
    parameters_d%cp = 0.0_4
    parameters_d%cp(:, :) = a_d(:, :, 2)
    parameters%cp(:, :) = a(:, :, 2)
    parameters_d%beta = 0.0_4
    parameters_d%beta(:, :) = a_d(:, :, 3)
    parameters%beta(:, :) = a(:, :, 3)
    parameters_d%cft = 0.0_4
    parameters_d%cft(:, :) = a_d(:, :, 4)
    parameters%cft(:, :) = a(:, :, 4)
    parameters_d%cst = 0.0_4
    parameters_d%cst(:, :) = a_d(:, :, 5)
    parameters%cst(:, :) = a(:, :, 5)
    parameters_d%alpha = 0.0_4
    parameters_d%alpha(:, :) = a_d(:, :, 6)
    parameters%alpha(:, :) = a(:, :, 6)
    parameters_d%exc = 0.0_4
    parameters_d%exc(:, :) = a_d(:, :, 7)
    parameters%exc(:, :) = a(:, :, 7)
    parameters_d%lr = 0.0_4
    parameters_d%lr(:, :) = a_d(:, :, 8)
    parameters%lr(:, :) = a(:, :, 8)
  END SUBROUTINE SET3D_PARAMETERS_D

!  Differentiation of set3d_parameters in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.lr)
!   with respect to varying inputs: a
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.lr:in
  SUBROUTINE SET3D_PARAMETERS_B(parameters, parameters_b, a, a_b)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_b
    REAL(sp), DIMENSION(:, :, :), INTENT(IN) :: a
    REAL(sp), DIMENSION(:, :, :) :: a_b
    a_b = 0.0_4
    a_b(:, :, 8) = a_b(:, :, 8) + parameters_b%lr
    a_b(:, :, 7) = a_b(:, :, 7) + parameters_b%exc
    a_b(:, :, 6) = a_b(:, :, 6) + parameters_b%alpha
    a_b(:, :, 5) = a_b(:, :, 5) + parameters_b%cst
    a_b(:, :, 4) = a_b(:, :, 4) + parameters_b%cft
    a_b(:, :, 3) = a_b(:, :, 3) + parameters_b%beta
    a_b(:, :, 2) = a_b(:, :, 2) + parameters_b%cp
    a_b(:, :, 1) = a_b(:, :, 1) + parameters_b%ci
  END SUBROUTINE SET3D_PARAMETERS_B

  SUBROUTINE SET3D_PARAMETERS(parameters, a)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    REAL(sp), DIMENSION(:, :, :), INTENT(IN) :: a
    parameters%ci(:, :) = a(:, :, 1)
    parameters%cp(:, :) = a(:, :, 2)
    parameters%beta(:, :) = a(:, :, 3)
    parameters%cft(:, :) = a(:, :, 4)
    parameters%cst(:, :) = a(:, :, 5)
    parameters%alpha(:, :) = a(:, :, 6)
    parameters%exc(:, :) = a(:, :, 7)
    parameters%lr(:, :) = a(:, :, 8)
  END SUBROUTINE SET3D_PARAMETERS

  SUBROUTINE SET1D_PARAMETERS(parameters, a)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    REAL(sp), DIMENSION(np), INTENT(IN) :: a
    parameters%ci(:, :) = a(1)
    parameters%cp(:, :) = a(2)
    parameters%beta(:, :) = a(3)
    parameters%cft(:, :) = a(4)
    parameters%cst(:, :) = a(5)
    parameters%alpha(:, :) = a(6)
    parameters%exc(:, :) = a(7)
    parameters%lr(:, :) = a(8)
  END SUBROUTINE SET1D_PARAMETERS

  SUBROUTINE SET0D_PARAMETERS(parameters, a)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    REAL(sp), INTENT(IN) :: a
    REAL(sp), DIMENSION(np) :: a1d
    a1d(:) = a
    CALL SET1D_PARAMETERS(parameters, a1d)
  END SUBROUTINE SET0D_PARAMETERS

!  Differentiation of get_hyper_parameters in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: a
!   with respect to varying inputs: *(hyper_parameters.ci) *(hyper_parameters.cp)
!                *(hyper_parameters.beta) *(hyper_parameters.cft)
!                *(hyper_parameters.cst) *(hyper_parameters.alpha)
!                *(hyper_parameters.exc) *(hyper_parameters.lr)
!   Plus diff mem management of: hyper_parameters.ci:in hyper_parameters.cp:in
!                hyper_parameters.beta:in hyper_parameters.cft:in
!                hyper_parameters.cst:in hyper_parameters.alpha:in
!                hyper_parameters.exc:in hyper_parameters.lr:in
  SUBROUTINE GET_HYPER_PARAMETERS_D(hyper_parameters, hyper_parameters_d&
&   , a, a_d)
    IMPLICIT NONE
    TYPE(HYPER_PARAMETERSDT), INTENT(IN) :: hyper_parameters
    TYPE(HYPER_PARAMETERSDT), INTENT(IN) :: hyper_parameters_d
    REAL(sp), DIMENSION(:, :, :), INTENT(INOUT) :: a
    REAL(sp), DIMENSION(:, :, :), INTENT(INOUT) :: a_d
    a_d = 0.0_4
    a_d(:, :, 1) = hyper_parameters_d%ci(:, :)
    a(:, :, 1) = hyper_parameters%ci(:, :)
    a_d(:, :, 2) = hyper_parameters_d%cp(:, :)
    a(:, :, 2) = hyper_parameters%cp(:, :)
    a_d(:, :, 3) = hyper_parameters_d%beta(:, :)
    a(:, :, 3) = hyper_parameters%beta(:, :)
    a_d(:, :, 4) = hyper_parameters_d%cft(:, :)
    a(:, :, 4) = hyper_parameters%cft(:, :)
    a_d(:, :, 5) = hyper_parameters_d%cst(:, :)
    a(:, :, 5) = hyper_parameters%cst(:, :)
    a_d(:, :, 6) = hyper_parameters_d%alpha(:, :)
    a(:, :, 6) = hyper_parameters%alpha(:, :)
    a_d(:, :, 7) = hyper_parameters_d%exc(:, :)
    a(:, :, 7) = hyper_parameters%exc(:, :)
    a_d(:, :, 8) = hyper_parameters_d%lr(:, :)
    a(:, :, 8) = hyper_parameters%lr(:, :)
  END SUBROUTINE GET_HYPER_PARAMETERS_D

!  Differentiation of get_hyper_parameters in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: a
!   with respect to varying inputs: *(hyper_parameters.ci) *(hyper_parameters.cp)
!                *(hyper_parameters.beta) *(hyper_parameters.cft)
!                *(hyper_parameters.cst) *(hyper_parameters.alpha)
!                *(hyper_parameters.exc) *(hyper_parameters.lr)
!   Plus diff mem management of: hyper_parameters.ci:in hyper_parameters.cp:in
!                hyper_parameters.beta:in hyper_parameters.cft:in
!                hyper_parameters.cst:in hyper_parameters.alpha:in
!                hyper_parameters.exc:in hyper_parameters.lr:in
  SUBROUTINE GET_HYPER_PARAMETERS_B(hyper_parameters, hyper_parameters_b&
&   , a, a_b)
    IMPLICIT NONE
    TYPE(HYPER_PARAMETERSDT), INTENT(IN) :: hyper_parameters
    TYPE(HYPER_PARAMETERSDT) :: hyper_parameters_b
    REAL(sp), DIMENSION(:, :, :), INTENT(INOUT) :: a
    REAL(sp), DIMENSION(:, :, :), INTENT(INOUT) :: a_b
    hyper_parameters_b%lr = 0.0_4
    hyper_parameters_b%lr = hyper_parameters_b%lr + a_b(:, :, 8)
    a_b(:, :, 8) = 0.0_4
    hyper_parameters_b%exc = 0.0_4
    hyper_parameters_b%exc = hyper_parameters_b%exc + a_b(:, :, 7)
    a_b(:, :, 7) = 0.0_4
    hyper_parameters_b%alpha = 0.0_4
    hyper_parameters_b%alpha = hyper_parameters_b%alpha + a_b(:, :, 6)
    a_b(:, :, 6) = 0.0_4
    hyper_parameters_b%cst = 0.0_4
    hyper_parameters_b%cst = hyper_parameters_b%cst + a_b(:, :, 5)
    a_b(:, :, 5) = 0.0_4
    hyper_parameters_b%cft = 0.0_4
    hyper_parameters_b%cft = hyper_parameters_b%cft + a_b(:, :, 4)
    a_b(:, :, 4) = 0.0_4
    hyper_parameters_b%beta = 0.0_4
    hyper_parameters_b%beta = hyper_parameters_b%beta + a_b(:, :, 3)
    a_b(:, :, 3) = 0.0_4
    hyper_parameters_b%cp = 0.0_4
    hyper_parameters_b%cp = hyper_parameters_b%cp + a_b(:, :, 2)
    a_b(:, :, 2) = 0.0_4
    hyper_parameters_b%ci = 0.0_4
    hyper_parameters_b%ci = hyper_parameters_b%ci + a_b(:, :, 1)
  END SUBROUTINE GET_HYPER_PARAMETERS_B

  SUBROUTINE GET_HYPER_PARAMETERS(hyper_parameters, a)
    IMPLICIT NONE
    TYPE(HYPER_PARAMETERSDT), INTENT(IN) :: hyper_parameters
    REAL(sp), DIMENSION(:, :, :), INTENT(INOUT) :: a
    a(:, :, 1) = hyper_parameters%ci(:, :)
    a(:, :, 2) = hyper_parameters%cp(:, :)
    a(:, :, 3) = hyper_parameters%beta(:, :)
    a(:, :, 4) = hyper_parameters%cft(:, :)
    a(:, :, 5) = hyper_parameters%cst(:, :)
    a(:, :, 6) = hyper_parameters%alpha(:, :)
    a(:, :, 7) = hyper_parameters%exc(:, :)
    a(:, :, 8) = hyper_parameters%lr(:, :)
  END SUBROUTINE GET_HYPER_PARAMETERS

  SUBROUTINE SET3D_HYPER_PARAMETERS(hyper_parameters, a)
    IMPLICIT NONE
    TYPE(HYPER_PARAMETERSDT), INTENT(INOUT) :: hyper_parameters
    REAL(sp), DIMENSION(:, :, :), INTENT(IN) :: a
    hyper_parameters%ci(:, :) = a(:, :, 1)
    hyper_parameters%cp(:, :) = a(:, :, 2)
    hyper_parameters%beta(:, :) = a(:, :, 3)
    hyper_parameters%cft(:, :) = a(:, :, 4)
    hyper_parameters%cst(:, :) = a(:, :, 5)
    hyper_parameters%alpha(:, :) = a(:, :, 6)
    hyper_parameters%exc(:, :) = a(:, :, 7)
    hyper_parameters%lr(:, :) = a(:, :, 8)
  END SUBROUTINE SET3D_HYPER_PARAMETERS

  SUBROUTINE SET1D_HYPER_PARAMETERS(hyper_parameters, a)
    IMPLICIT NONE
    TYPE(HYPER_PARAMETERSDT), INTENT(INOUT) :: hyper_parameters
    REAL(sp), DIMENSION(np), INTENT(IN) :: a
    hyper_parameters%ci(:, :) = a(1)
    hyper_parameters%cp(:, :) = a(2)
    hyper_parameters%beta(:, :) = a(3)
    hyper_parameters%cft(:, :) = a(4)
    hyper_parameters%cst(:, :) = a(5)
    hyper_parameters%alpha(:, :) = a(6)
    hyper_parameters%exc(:, :) = a(7)
    hyper_parameters%lr(:, :) = a(8)
  END SUBROUTINE SET1D_HYPER_PARAMETERS

  SUBROUTINE SET0D_HYPER_PARAMETERS(hyper_parameters, a)
    IMPLICIT NONE
    TYPE(HYPER_PARAMETERSDT), INTENT(INOUT) :: hyper_parameters
    REAL(sp), INTENT(IN) :: a
    REAL(sp), DIMENSION(np) :: a1d
    a1d(:) = a
    CALL SET1D_HYPER_PARAMETERS(hyper_parameters, a1d)
  END SUBROUTINE SET0D_HYPER_PARAMETERS

!  Differentiation of hyper_parameters_to_parameters in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.lr)
!   with respect to varying inputs: *(hyper_parameters.ci) *(hyper_parameters.cp)
!                *(hyper_parameters.beta) *(hyper_parameters.cft)
!                *(hyper_parameters.cst) *(hyper_parameters.alpha)
!                *(hyper_parameters.exc) *(hyper_parameters.lr)
!   Plus diff mem management of: hyper_parameters.ci:in hyper_parameters.cp:in
!                hyper_parameters.beta:in hyper_parameters.cft:in
!                hyper_parameters.cst:in hyper_parameters.alpha:in
!                hyper_parameters.exc:in hyper_parameters.lr:in
!%      TODO comment
  SUBROUTINE HYPER_PARAMETERS_TO_PARAMETERS_D(hyper_parameters, &
&   hyper_parameters_d, parameters, parameters_d, setup, input_data)
    IMPLICIT NONE
    TYPE(HYPER_PARAMETERSDT), INTENT(IN) :: hyper_parameters
    TYPE(HYPER_PARAMETERSDT), INTENT(IN) :: hyper_parameters_d
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_d
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(hyper_parameters%cp, 1), SIZE(&
&   hyper_parameters%cp, 2), np) :: hyper_parameters_matrix
    REAL(sp), DIMENSION(SIZE(hyper_parameters%cp, 1), SIZE(&
&   hyper_parameters%cp, 2), np) :: hyper_parameters_matrix_d
    REAL(sp), DIMENSION(SIZE(parameters%cp, 1), SIZE(parameters%cp, 2), &
&   np) :: parameters_matrix
    REAL(sp), DIMENSION(SIZE(parameters%cp, 1), SIZE(parameters%cp, 2), &
&   np) :: parameters_matrix_d
    REAL(sp), DIMENSION(SIZE(parameters%cp, 1), SIZE(parameters%cp, 2)) &
&   :: d, dpb
    REAL(sp), DIMENSION(SIZE(parameters%cp, 1), SIZE(parameters%cp, 2)) &
&   :: dpb_d
    INTEGER :: i, j
    REAL(sp) :: a, b
    REAL(sp) :: a_d, b_d
    INTRINSIC TRIM
    INTRINSIC EXP
    REAL(sp), DIMENSION(size(parameters%cp, 1), size(parameters%cp, 2)) &
&   :: temp
    REAL(sp), DIMENSION(SIZE(parameters%cp, 1), SIZE(parameters%cp, 2)) &
&   :: temp0
    CALL GET_HYPER_PARAMETERS_D(hyper_parameters, hyper_parameters_d, &
&                         hyper_parameters_matrix, &
&                         hyper_parameters_matrix_d)
    CALL GET_PARAMETERS(parameters, parameters_matrix)
    parameters_matrix_d = 0.0_4
    a_d = 0.0_4
    b_d = 0.0_4
!% Add mask later here
!% 1 in dim2 will be replace with k and apply where on Omega
    DO i=1,np
      parameters_matrix_d(:, :, i) = hyper_parameters_matrix_d(1, 1, i)
      parameters_matrix(:, :, i) = hyper_parameters_matrix(1, 1, i)
      DO j=1,setup%nd
        d = input_data%descriptor(:, :, j)
        SELECT CASE  (TRIM(setup%optimize%mapping)) 
        CASE ('hyper-linear') 
          a_d = hyper_parameters_matrix_d(j+1, 1, i)
          a = hyper_parameters_matrix(j+1, 1, i)
          b = 1._sp
          b_d = 0.0_4
        CASE ('hyper-polynomial') 
          a_d = hyper_parameters_matrix_d(2*j, 1, i)
          a = hyper_parameters_matrix(2*j, 1, i)
          b_d = hyper_parameters_matrix_d(2*j+1, 1, i)
          b = hyper_parameters_matrix(2*j+1, 1, i)
        END SELECT
        temp = d**b
        WHERE (d .LE. 0.0) 
          dpb_d = 0.0_4
        ELSEWHERE
          dpb_d = temp*LOG(d)*b_d
        END WHERE
        dpb = temp
        parameters_matrix_d(:, :, i) = parameters_matrix_d(:, :, i) + &
&         dpb*a_d + a*dpb_d
        parameters_matrix(:, :, i) = parameters_matrix(:, :, i) + a*dpb
      END DO
!% sigmoid transformation lambda = 1
      temp0 = (setup%optimize%ub_parameters(i)-setup%optimize%&
&       lb_parameters(i))/(EXP(-parameters_matrix(:, :, i))+1._sp)
      parameters_matrix_d(:, :, i) = temp0*EXP(-parameters_matrix(:, :, &
&       i))*parameters_matrix_d(:, :, i)/(EXP(-parameters_matrix(:, :, i&
&       ))+1._sp)
      parameters_matrix(:, :, i) = setup%optimize%lb_parameters(i) + &
&       temp0
    END DO
    CALL SET_PARAMETERS_D(parameters, parameters_d, parameters_matrix, &
&                   parameters_matrix_d)
  END SUBROUTINE HYPER_PARAMETERS_TO_PARAMETERS_D

!  Differentiation of hyper_parameters_to_parameters in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.lr)
!   with respect to varying inputs: *(hyper_parameters.ci) *(hyper_parameters.cp)
!                *(hyper_parameters.beta) *(hyper_parameters.cft)
!                *(hyper_parameters.cst) *(hyper_parameters.alpha)
!                *(hyper_parameters.exc) *(hyper_parameters.lr)
!   Plus diff mem management of: hyper_parameters.ci:in hyper_parameters.cp:in
!                hyper_parameters.beta:in hyper_parameters.cft:in
!                hyper_parameters.cst:in hyper_parameters.alpha:in
!                hyper_parameters.exc:in hyper_parameters.lr:in
!%      TODO comment
  SUBROUTINE HYPER_PARAMETERS_TO_PARAMETERS_B(hyper_parameters, &
&   hyper_parameters_b, parameters, parameters_b, setup, input_data)
    IMPLICIT NONE
    TYPE(HYPER_PARAMETERSDT), INTENT(IN) :: hyper_parameters
    TYPE(HYPER_PARAMETERSDT) :: hyper_parameters_b
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_b
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(hyper_parameters%cp, 1), SIZE(&
&   hyper_parameters%cp, 2), np) :: hyper_parameters_matrix
    REAL(sp), DIMENSION(SIZE(hyper_parameters%cp, 1), SIZE(&
&   hyper_parameters%cp, 2), np) :: hyper_parameters_matrix_b
    REAL(sp), DIMENSION(SIZE(parameters%cp, 1), SIZE(parameters%cp, 2), &
&   np) :: parameters_matrix
    REAL(sp), DIMENSION(SIZE(parameters%cp, 1), SIZE(parameters%cp, 2), &
&   np) :: parameters_matrix_b
    REAL(sp), DIMENSION(SIZE(parameters%cp, 1), SIZE(parameters%cp, 2)) &
&   :: d, dpb
    REAL(sp), DIMENSION(SIZE(parameters%cp, 1), SIZE(parameters%cp, 2)) &
&   :: dpb_b
    INTEGER :: i, j
    REAL(sp) :: a, b
    REAL(sp) :: a_b, b_b
    INTRINSIC TRIM
    INTRINSIC EXP
    REAL(sp), DIMENSION(SIZE(parameters%cp, 1), SIZE(parameters%cp, 2)) &
&   :: temp
    INTEGER :: branch
    CALL GET_HYPER_PARAMETERS(hyper_parameters, hyper_parameters_matrix)
!% Add mask later here
!% 1 in dim2 will be replace with k and apply where on Omega
    DO i=1,np
      parameters_matrix(:, :, i) = hyper_parameters_matrix(1, 1, i)
      DO j=1,setup%nd
        d = input_data%descriptor(:, :, j)
        SELECT CASE  (TRIM(setup%optimize%mapping)) 
        CASE ('hyper-linear') 
          CALL PUSHREAL4(a)
          a = hyper_parameters_matrix(j+1, 1, i)
          CALL PUSHREAL4(b)
          b = 1._sp
          CALL PUSHCONTROL2B(1)
        CASE ('hyper-polynomial') 
          CALL PUSHREAL4(a)
          a = hyper_parameters_matrix(2*j, 1, i)
          CALL PUSHREAL4(b)
          b = hyper_parameters_matrix(2*j+1, 1, i)
          CALL PUSHCONTROL2B(2)
        CASE DEFAULT
          CALL PUSHCONTROL2B(0)
        END SELECT
        dpb = d**b
        parameters_matrix(:, :, i) = parameters_matrix(:, :, i) + a*dpb
      END DO
    END DO
    CALL SET_PARAMETERS(parameters, parameters_matrix)
    CALL SET_PARAMETERS_B(parameters, parameters_b, parameters_matrix, &
&                   parameters_matrix_b)
    hyper_parameters_matrix_b = 0.0_4
    a_b = 0.0_4
    b_b = 0.0_4
    DO i=np,1,-1
      temp = EXP(-parameters_matrix(:, :, i)) + 1._sp
      parameters_matrix_b(:, :, i) = EXP(-parameters_matrix(:, :, i))*(&
&       setup%optimize%ub_parameters(i)-setup%optimize%lb_parameters(i))&
&       *parameters_matrix_b(:, :, i)/temp**2
      DO j=setup%nd,1,-1
        d = input_data%descriptor(:, :, j)
        dpb = d**b
        dpb_b = 0.0_4
        a_b = a_b + SUM(dpb*parameters_matrix_b(:, :, i))
        dpb_b = a*parameters_matrix_b(:, :, i)
        b_b = b_b + SUM(d**b*LOG(d)*dpb_b, MASK=.NOT.d.LE.0.0)
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .EQ. 1) THEN
            CALL POPREAL4(b)
            CALL POPREAL4(a)
            hyper_parameters_matrix_b(j+1, 1, i) = &
&             hyper_parameters_matrix_b(j+1, 1, i) + a_b
            a_b = 0.0_4
            b_b = 0.0_4
          ELSE
            CALL POPREAL4(b)
            hyper_parameters_matrix_b(2*j+1, 1, i) = &
&             hyper_parameters_matrix_b(2*j+1, 1, i) + b_b
            CALL POPREAL4(a)
            hyper_parameters_matrix_b(2*j, 1, i) = &
&             hyper_parameters_matrix_b(2*j, 1, i) + a_b
            a_b = 0.0_4
            b_b = 0.0_4
          END IF
        END IF
      END DO
      hyper_parameters_matrix_b(1, 1, i) = hyper_parameters_matrix_b(1, &
&       1, i) + SUM(parameters_matrix_b(:, :, i))
      parameters_matrix_b(:, :, i) = 0.0_4
    END DO
    CALL GET_HYPER_PARAMETERS_B(hyper_parameters, hyper_parameters_b, &
&                         hyper_parameters_matrix, &
&                         hyper_parameters_matrix_b)
  END SUBROUTINE HYPER_PARAMETERS_TO_PARAMETERS_B

!%      TODO comment
  SUBROUTINE HYPER_PARAMETERS_TO_PARAMETERS(hyper_parameters, parameters&
&   , setup, input_data)
    IMPLICIT NONE
    TYPE(HYPER_PARAMETERSDT), INTENT(IN) :: hyper_parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(hyper_parameters%cp, 1), SIZE(&
&   hyper_parameters%cp, 2), np) :: hyper_parameters_matrix
    REAL(sp), DIMENSION(SIZE(parameters%cp, 1), SIZE(parameters%cp, 2), &
&   np) :: parameters_matrix
    REAL(sp), DIMENSION(SIZE(parameters%cp, 1), SIZE(parameters%cp, 2)) &
&   :: d, dpb
    INTEGER :: i, j
    REAL(sp) :: a, b
    INTRINSIC TRIM
    INTRINSIC EXP
    CALL GET_HYPER_PARAMETERS(hyper_parameters, hyper_parameters_matrix)
    CALL GET_PARAMETERS(parameters, parameters_matrix)
!% Add mask later here
!% 1 in dim2 will be replace with k and apply where on Omega
    DO i=1,np
      parameters_matrix(:, :, i) = hyper_parameters_matrix(1, 1, i)
      DO j=1,setup%nd
        d = input_data%descriptor(:, :, j)
        SELECT CASE  (TRIM(setup%optimize%mapping)) 
        CASE ('hyper-linear') 
          a = hyper_parameters_matrix(j+1, 1, i)
          b = 1._sp
        CASE ('hyper-polynomial') 
          a = hyper_parameters_matrix(2*j, 1, i)
          b = hyper_parameters_matrix(2*j+1, 1, i)
        END SELECT
        dpb = d**b
        parameters_matrix(:, :, i) = parameters_matrix(:, :, i) + a*dpb
      END DO
!% sigmoid transformation lambda = 1
      parameters_matrix(:, :, i) = (setup%optimize%ub_parameters(i)-&
&       setup%optimize%lb_parameters(i))*(1._sp/(1._sp+EXP(-&
&       parameters_matrix(:, :, i)))) + setup%optimize%lb_parameters(i)
    END DO
    CALL SET_PARAMETERS(parameters, parameters_matrix)
  END SUBROUTINE HYPER_PARAMETERS_TO_PARAMETERS

END MODULE MWD_PARAMETERS_MANIPULATION_DIFF

MODULE MWD_STATES_MANIPULATION_DIFF
  USE MD_COMMON
  USE MWD_SETUP
  USE MWD_INPUT_DATA
  USE MWD_STATES_DIFF
  IMPLICIT NONE
  INTERFACE SET_STATES
      MODULE PROCEDURE SET0D_STATES
      MODULE PROCEDURE SET1D_STATES
      MODULE PROCEDURE SET3D_STATES
  END INTERFACE SET_STATES

  INTERFACE SET_STATES_D
      MODULE PROCEDURE SET3D_STATES_D
  END INTERFACE

  INTERFACE SET_STATES_B
      MODULE PROCEDURE SET3D_STATES_B
  END INTERFACE

  INTERFACE SET_HYPER_STATES
      MODULE PROCEDURE SET0D_HYPER_STATES
      MODULE PROCEDURE SET1D_HYPER_STATES
      MODULE PROCEDURE SET3D_HYPER_STATES
  END INTERFACE SET_HYPER_STATES


CONTAINS
!  Differentiation of get_states in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: a
!   with respect to varying inputs: *(states.hi) *(states.hp) *(states.hft)
!                *(states.hst) *(states.hlr)
!   Plus diff mem management of: states.hi:in states.hp:in states.hft:in
!                states.hst:in states.hlr:in
!%      TODO comment  
  SUBROUTINE GET_STATES_D(states, states_d, a, a_d)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(IN) :: states
    TYPE(STATESDT), INTENT(IN) :: states_d
    REAL(sp), DIMENSION(:, :, :), INTENT(INOUT) :: a
    REAL(sp), DIMENSION(:, :, :), INTENT(INOUT) :: a_d
    a_d = 0.0_4
    a_d(:, :, 1) = states_d%hi(:, :)
    a(:, :, 1) = states%hi(:, :)
    a_d(:, :, 2) = states_d%hp(:, :)
    a(:, :, 2) = states%hp(:, :)
    a_d(:, :, 3) = states_d%hft(:, :)
    a(:, :, 3) = states%hft(:, :)
    a_d(:, :, 4) = states_d%hst(:, :)
    a(:, :, 4) = states%hst(:, :)
    a_d(:, :, 5) = states_d%hlr(:, :)
    a(:, :, 5) = states%hlr(:, :)
  END SUBROUTINE GET_STATES_D

!  Differentiation of get_states in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: a
!   with respect to varying inputs: *(states.hi) *(states.hp) *(states.hft)
!                *(states.hst) *(states.hlr)
!   Plus diff mem management of: states.hi:in states.hp:in states.hft:in
!                states.hst:in states.hlr:in
!%      TODO comment  
  SUBROUTINE GET_STATES_B(states, states_b, a, a_b)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(IN) :: states
    TYPE(STATESDT) :: states_b
    REAL(sp), DIMENSION(:, :, :), INTENT(INOUT) :: a
    REAL(sp), DIMENSION(:, :, :), INTENT(INOUT) :: a_b
    states_b%hlr = 0.0_4
    states_b%hlr = states_b%hlr + a_b(:, :, 5)
    a_b(:, :, 5) = 0.0_4
    states_b%hst = 0.0_4
    states_b%hst = states_b%hst + a_b(:, :, 4)
    a_b(:, :, 4) = 0.0_4
    states_b%hft = 0.0_4
    states_b%hft = states_b%hft + a_b(:, :, 3)
    a_b(:, :, 3) = 0.0_4
    states_b%hp = 0.0_4
    states_b%hp = states_b%hp + a_b(:, :, 2)
    a_b(:, :, 2) = 0.0_4
    states_b%hi = 0.0_4
    states_b%hi = states_b%hi + a_b(:, :, 1)
  END SUBROUTINE GET_STATES_B

!%      TODO comment  
  SUBROUTINE GET_STATES(states, a)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(IN) :: states
    REAL(sp), DIMENSION(:, :, :), INTENT(INOUT) :: a
    a(:, :, 1) = states%hi(:, :)
    a(:, :, 2) = states%hp(:, :)
    a(:, :, 3) = states%hft(:, :)
    a(:, :, 4) = states%hst(:, :)
    a(:, :, 5) = states%hlr(:, :)
  END SUBROUTINE GET_STATES

!  Differentiation of set3d_states in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: *(states.hi) *(states.hp) *(states.hft)
!                *(states.hst) *(states.hlr)
!   with respect to varying inputs: a
!   Plus diff mem management of: states.hi:in states.hp:in states.hft:in
!                states.hst:in states.hlr:in
  SUBROUTINE SET3D_STATES_D(states, states_d, a, a_d)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(STATESDT), INTENT(INOUT) :: states_d
    REAL(sp), DIMENSION(:, :, :), INTENT(IN) :: a
    REAL(sp), DIMENSION(:, :, :), INTENT(IN) :: a_d
    states_d%hi = 0.0_4
    states_d%hi(:, :) = a_d(:, :, 1)
    states%hi(:, :) = a(:, :, 1)
    states_d%hp = 0.0_4
    states_d%hp(:, :) = a_d(:, :, 2)
    states%hp(:, :) = a(:, :, 2)
    states_d%hft = 0.0_4
    states_d%hft(:, :) = a_d(:, :, 3)
    states%hft(:, :) = a(:, :, 3)
    states_d%hst = 0.0_4
    states_d%hst(:, :) = a_d(:, :, 4)
    states%hst(:, :) = a(:, :, 4)
    states_d%hlr = 0.0_4
    states_d%hlr(:, :) = a_d(:, :, 5)
    states%hlr(:, :) = a(:, :, 5)
  END SUBROUTINE SET3D_STATES_D

!  Differentiation of set3d_states in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: *(states.hi) *(states.hp) *(states.hft)
!                *(states.hst) *(states.hlr)
!   with respect to varying inputs: a
!   Plus diff mem management of: states.hi:in states.hp:in states.hft:in
!                states.hst:in states.hlr:in
  SUBROUTINE SET3D_STATES_B(states, states_b, a, a_b)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(STATESDT), INTENT(INOUT) :: states_b
    REAL(sp), DIMENSION(:, :, :), INTENT(IN) :: a
    REAL(sp), DIMENSION(:, :, :) :: a_b
    a_b = 0.0_4
    a_b(:, :, 5) = a_b(:, :, 5) + states_b%hlr
    a_b(:, :, 4) = a_b(:, :, 4) + states_b%hst
    a_b(:, :, 3) = a_b(:, :, 3) + states_b%hft
    a_b(:, :, 2) = a_b(:, :, 2) + states_b%hp
    a_b(:, :, 1) = a_b(:, :, 1) + states_b%hi
  END SUBROUTINE SET3D_STATES_B

  SUBROUTINE SET3D_STATES(states, a)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(INOUT) :: states
    REAL(sp), DIMENSION(:, :, :), INTENT(IN) :: a
    states%hi(:, :) = a(:, :, 1)
    states%hp(:, :) = a(:, :, 2)
    states%hft(:, :) = a(:, :, 3)
    states%hst(:, :) = a(:, :, 4)
    states%hlr(:, :) = a(:, :, 5)
  END SUBROUTINE SET3D_STATES

  SUBROUTINE SET1D_STATES(states, a)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(INOUT) :: states
    REAL(sp), DIMENSION(ns), INTENT(IN) :: a
    states%hi(:, :) = a(1)
    states%hp(:, :) = a(2)
    states%hft(:, :) = a(3)
    states%hst(:, :) = a(4)
    states%hlr(:, :) = a(5)
  END SUBROUTINE SET1D_STATES

  SUBROUTINE SET0D_STATES(states, a)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(INOUT) :: states
    REAL(sp), INTENT(IN) :: a
    REAL(sp), DIMENSION(ns) :: a1d
    a1d(:) = a
    CALL SET1D_STATES(states, a1d)
  END SUBROUTINE SET0D_STATES

!  Differentiation of get_hyper_states in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: a
!   with respect to varying inputs: *(hyper_states.hi) *(hyper_states.hp)
!                *(hyper_states.hft) *(hyper_states.hst) *(hyper_states.hlr)
!   Plus diff mem management of: hyper_states.hi:in hyper_states.hp:in
!                hyper_states.hft:in hyper_states.hst:in hyper_states.hlr:in
  SUBROUTINE GET_HYPER_STATES_D(hyper_states, hyper_states_d, a, a_d)
    IMPLICIT NONE
    TYPE(HYPER_STATESDT), INTENT(IN) :: hyper_states
    TYPE(HYPER_STATESDT), INTENT(IN) :: hyper_states_d
    REAL(sp), DIMENSION(:, :, :), INTENT(INOUT) :: a
    REAL(sp), DIMENSION(:, :, :), INTENT(INOUT) :: a_d
    a_d = 0.0_4
    a_d(:, :, 1) = hyper_states_d%hi(:, :)
    a(:, :, 1) = hyper_states%hi(:, :)
    a_d(:, :, 2) = hyper_states_d%hp(:, :)
    a(:, :, 2) = hyper_states%hp(:, :)
    a_d(:, :, 3) = hyper_states_d%hft(:, :)
    a(:, :, 3) = hyper_states%hft(:, :)
    a_d(:, :, 4) = hyper_states_d%hst(:, :)
    a(:, :, 4) = hyper_states%hst(:, :)
    a_d(:, :, 5) = hyper_states_d%hlr(:, :)
    a(:, :, 5) = hyper_states%hlr(:, :)
  END SUBROUTINE GET_HYPER_STATES_D

!  Differentiation of get_hyper_states in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: a
!   with respect to varying inputs: *(hyper_states.hi) *(hyper_states.hp)
!                *(hyper_states.hft) *(hyper_states.hst) *(hyper_states.hlr)
!   Plus diff mem management of: hyper_states.hi:in hyper_states.hp:in
!                hyper_states.hft:in hyper_states.hst:in hyper_states.hlr:in
  SUBROUTINE GET_HYPER_STATES_B(hyper_states, hyper_states_b, a, a_b)
    IMPLICIT NONE
    TYPE(HYPER_STATESDT), INTENT(IN) :: hyper_states
    TYPE(HYPER_STATESDT) :: hyper_states_b
    REAL(sp), DIMENSION(:, :, :), INTENT(INOUT) :: a
    REAL(sp), DIMENSION(:, :, :), INTENT(INOUT) :: a_b
    hyper_states_b%hlr = 0.0_4
    hyper_states_b%hlr = hyper_states_b%hlr + a_b(:, :, 5)
    a_b(:, :, 5) = 0.0_4
    hyper_states_b%hst = 0.0_4
    hyper_states_b%hst = hyper_states_b%hst + a_b(:, :, 4)
    a_b(:, :, 4) = 0.0_4
    hyper_states_b%hft = 0.0_4
    hyper_states_b%hft = hyper_states_b%hft + a_b(:, :, 3)
    a_b(:, :, 3) = 0.0_4
    hyper_states_b%hp = 0.0_4
    hyper_states_b%hp = hyper_states_b%hp + a_b(:, :, 2)
    a_b(:, :, 2) = 0.0_4
    hyper_states_b%hi = 0.0_4
    hyper_states_b%hi = hyper_states_b%hi + a_b(:, :, 1)
  END SUBROUTINE GET_HYPER_STATES_B

  SUBROUTINE GET_HYPER_STATES(hyper_states, a)
    IMPLICIT NONE
    TYPE(HYPER_STATESDT), INTENT(IN) :: hyper_states
    REAL(sp), DIMENSION(:, :, :), INTENT(INOUT) :: a
    a(:, :, 1) = hyper_states%hi(:, :)
    a(:, :, 2) = hyper_states%hp(:, :)
    a(:, :, 3) = hyper_states%hft(:, :)
    a(:, :, 4) = hyper_states%hst(:, :)
    a(:, :, 5) = hyper_states%hlr(:, :)
  END SUBROUTINE GET_HYPER_STATES

  SUBROUTINE SET3D_HYPER_STATES(hyper_states, a)
    IMPLICIT NONE
    TYPE(HYPER_STATESDT), INTENT(INOUT) :: hyper_states
    REAL(sp), DIMENSION(:, :, :), INTENT(IN) :: a
    hyper_states%hi(:, :) = a(:, :, 1)
    hyper_states%hp(:, :) = a(:, :, 2)
    hyper_states%hft(:, :) = a(:, :, 3)
    hyper_states%hst(:, :) = a(:, :, 4)
    hyper_states%hlr(:, :) = a(:, :, 5)
  END SUBROUTINE SET3D_HYPER_STATES

  SUBROUTINE SET1D_HYPER_STATES(hyper_states, a)
    IMPLICIT NONE
    TYPE(HYPER_STATESDT), INTENT(INOUT) :: hyper_states
    REAL(sp), DIMENSION(ns), INTENT(IN) :: a
    hyper_states%hi(:, :) = a(1)
    hyper_states%hp(:, :) = a(2)
    hyper_states%hft(:, :) = a(3)
    hyper_states%hst(:, :) = a(4)
    hyper_states%hlr(:, :) = a(5)
  END SUBROUTINE SET1D_HYPER_STATES

  SUBROUTINE SET0D_HYPER_STATES(hyper_states, a)
    IMPLICIT NONE
    TYPE(HYPER_STATESDT), INTENT(INOUT) :: hyper_states
    REAL(sp), INTENT(IN) :: a
    REAL(sp), DIMENSION(ns) :: a1d
    a1d(:) = a
    CALL SET1D_HYPER_STATES(hyper_states, a1d)
  END SUBROUTINE SET0D_HYPER_STATES

!  Differentiation of hyper_states_to_states in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: *(states.hi) *(states.hp) *(states.hft)
!                *(states.hst) *(states.hlr)
!   with respect to varying inputs: *(hyper_states.hi) *(hyper_states.hp)
!                *(hyper_states.hft) *(hyper_states.hst) *(hyper_states.hlr)
!   Plus diff mem management of: hyper_states.hi:in hyper_states.hp:in
!                hyper_states.hft:in hyper_states.hst:in hyper_states.hlr:in
!%      TODO comment
  SUBROUTINE HYPER_STATES_TO_STATES_D(hyper_states, hyper_states_d, &
&   states, states_d, setup, input_data)
    IMPLICIT NONE
    TYPE(HYPER_STATESDT), INTENT(IN) :: hyper_states
    TYPE(HYPER_STATESDT), INTENT(IN) :: hyper_states_d
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(STATESDT), INTENT(INOUT) :: states_d
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(hyper_states%hp, 1), SIZE(hyper_states%hp, &
&   2), ns) :: hyper_states_matrix
    REAL(sp), DIMENSION(SIZE(hyper_states%hp, 1), SIZE(hyper_states%hp, &
&   2), ns) :: hyper_states_matrix_d
    REAL(sp), DIMENSION(SIZE(states%hp, 1), SIZE(states%hp, 2), ns) :: &
&   states_matrix
    REAL(sp), DIMENSION(SIZE(states%hp, 1), SIZE(states%hp, 2), ns) :: &
&   states_matrix_d
    REAL(sp), DIMENSION(SIZE(states%hp, 1), SIZE(states%hp, 2)) :: d, &
&   dpb
    REAL(sp), DIMENSION(SIZE(states%hp, 1), SIZE(states%hp, 2)) :: dpb_d
    INTEGER :: i, j
    REAL(sp) :: a, b
    REAL(sp) :: a_d, b_d
    INTRINSIC TRIM
    INTRINSIC EXP
    REAL(sp), DIMENSION(size(states%hp, 1), size(states%hp, 2)) :: temp
    REAL(sp), DIMENSION(SIZE(states%hp, 1), SIZE(states%hp, 2)) :: temp0
    CALL GET_HYPER_STATES_D(hyper_states, hyper_states_d, &
&                     hyper_states_matrix, hyper_states_matrix_d)
    CALL GET_STATES(states, states_matrix)
    states_matrix_d = 0.0_4
    a_d = 0.0_4
    b_d = 0.0_4
!% Add mask later here
!% 1 in dim2 will be replace with k and apply where on Omega
    DO i=1,ns
      states_matrix_d(:, :, i) = hyper_states_matrix_d(1, 1, i)
      states_matrix(:, :, i) = hyper_states_matrix(1, 1, i)
      DO j=1,setup%nd
        d = input_data%descriptor(:, :, j)
        SELECT CASE  (TRIM(setup%optimize%mapping)) 
        CASE ('hyper-linear') 
          a_d = hyper_states_matrix_d(j+1, 1, i)
          a = hyper_states_matrix(j+1, 1, i)
          b = 1._sp
          b_d = 0.0_4
        CASE ('hyper-polynomial') 
          a_d = hyper_states_matrix_d(2*j, 1, i)
          a = hyper_states_matrix(2*j, 1, i)
          b_d = hyper_states_matrix_d(2*j+1, 1, i)
          b = hyper_states_matrix(2*j+1, 1, i)
        END SELECT
        temp = d**b
        WHERE (d .LE. 0.0) 
          dpb_d = 0.0_4
        ELSEWHERE
          dpb_d = temp*LOG(d)*b_d
        END WHERE
        dpb = temp
        states_matrix_d(:, :, i) = states_matrix_d(:, :, i) + dpb*a_d + &
&         a*dpb_d
        states_matrix(:, :, i) = states_matrix(:, :, i) + a*dpb
      END DO
!% sigmoid transformation lambda = 1
      temp0 = (setup%optimize%ub_states(i)-setup%optimize%lb_states(i))/&
&       (EXP(-states_matrix(:, :, i))+1._sp)
      states_matrix_d(:, :, i) = temp0*EXP(-states_matrix(:, :, i))*&
&       states_matrix_d(:, :, i)/(EXP(-states_matrix(:, :, i))+1._sp)
      states_matrix(:, :, i) = setup%optimize%lb_states(i) + temp0
    END DO
    CALL SET_STATES_D(states, states_d, states_matrix, states_matrix_d)
  END SUBROUTINE HYPER_STATES_TO_STATES_D

!  Differentiation of hyper_states_to_states in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: *(states.hi) *(states.hp) *(states.hft)
!                *(states.hst) *(states.hlr)
!   with respect to varying inputs: *(hyper_states.hi) *(hyper_states.hp)
!                *(hyper_states.hft) *(hyper_states.hst) *(hyper_states.hlr)
!   Plus diff mem management of: hyper_states.hi:in hyper_states.hp:in
!                hyper_states.hft:in hyper_states.hst:in hyper_states.hlr:in
!%      TODO comment
  SUBROUTINE HYPER_STATES_TO_STATES_B(hyper_states, hyper_states_b, &
&   states, states_b, setup, input_data)
    IMPLICIT NONE
    TYPE(HYPER_STATESDT), INTENT(IN) :: hyper_states
    TYPE(HYPER_STATESDT) :: hyper_states_b
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(STATESDT), INTENT(INOUT) :: states_b
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(hyper_states%hp, 1), SIZE(hyper_states%hp, &
&   2), ns) :: hyper_states_matrix
    REAL(sp), DIMENSION(SIZE(hyper_states%hp, 1), SIZE(hyper_states%hp, &
&   2), ns) :: hyper_states_matrix_b
    REAL(sp), DIMENSION(SIZE(states%hp, 1), SIZE(states%hp, 2), ns) :: &
&   states_matrix
    REAL(sp), DIMENSION(SIZE(states%hp, 1), SIZE(states%hp, 2), ns) :: &
&   states_matrix_b
    REAL(sp), DIMENSION(SIZE(states%hp, 1), SIZE(states%hp, 2)) :: d, &
&   dpb
    REAL(sp), DIMENSION(SIZE(states%hp, 1), SIZE(states%hp, 2)) :: dpb_b
    INTEGER :: i, j
    REAL(sp) :: a, b
    REAL(sp) :: a_b, b_b
    INTRINSIC TRIM
    INTRINSIC EXP
    REAL(sp), DIMENSION(SIZE(states%hp, 1), SIZE(states%hp, 2)) :: temp
    INTEGER :: branch
    CALL GET_HYPER_STATES(hyper_states, hyper_states_matrix)
!% Add mask later here
!% 1 in dim2 will be replace with k and apply where on Omega
    DO i=1,ns
      states_matrix(:, :, i) = hyper_states_matrix(1, 1, i)
      DO j=1,setup%nd
        d = input_data%descriptor(:, :, j)
        SELECT CASE  (TRIM(setup%optimize%mapping)) 
        CASE ('hyper-linear') 
          CALL PUSHREAL4(a)
          a = hyper_states_matrix(j+1, 1, i)
          CALL PUSHREAL4(b)
          b = 1._sp
          CALL PUSHCONTROL2B(1)
        CASE ('hyper-polynomial') 
          CALL PUSHREAL4(a)
          a = hyper_states_matrix(2*j, 1, i)
          CALL PUSHREAL4(b)
          b = hyper_states_matrix(2*j+1, 1, i)
          CALL PUSHCONTROL2B(2)
        CASE DEFAULT
          CALL PUSHCONTROL2B(0)
        END SELECT
        dpb = d**b
        states_matrix(:, :, i) = states_matrix(:, :, i) + a*dpb
      END DO
    END DO
    CALL SET_STATES(states, states_matrix)
    CALL SET_STATES_B(states, states_b, states_matrix, states_matrix_b)
    hyper_states_matrix_b = 0.0_4
    a_b = 0.0_4
    b_b = 0.0_4
    DO i=ns,1,-1
      temp = EXP(-states_matrix(:, :, i)) + 1._sp
      states_matrix_b(:, :, i) = EXP(-states_matrix(:, :, i))*(setup%&
&       optimize%ub_states(i)-setup%optimize%lb_states(i))*&
&       states_matrix_b(:, :, i)/temp**2
      DO j=setup%nd,1,-1
        d = input_data%descriptor(:, :, j)
        dpb = d**b
        dpb_b = 0.0_4
        a_b = a_b + SUM(dpb*states_matrix_b(:, :, i))
        dpb_b = a*states_matrix_b(:, :, i)
        b_b = b_b + SUM(d**b*LOG(d)*dpb_b, MASK=.NOT.d.LE.0.0)
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .EQ. 1) THEN
            CALL POPREAL4(b)
            CALL POPREAL4(a)
            hyper_states_matrix_b(j+1, 1, i) = hyper_states_matrix_b(j+1&
&             , 1, i) + a_b
            a_b = 0.0_4
            b_b = 0.0_4
          ELSE
            CALL POPREAL4(b)
            hyper_states_matrix_b(2*j+1, 1, i) = hyper_states_matrix_b(2&
&             *j+1, 1, i) + b_b
            CALL POPREAL4(a)
            hyper_states_matrix_b(2*j, 1, i) = hyper_states_matrix_b(2*j&
&             , 1, i) + a_b
            a_b = 0.0_4
            b_b = 0.0_4
          END IF
        END IF
      END DO
      hyper_states_matrix_b(1, 1, i) = hyper_states_matrix_b(1, 1, i) + &
&       SUM(states_matrix_b(:, :, i))
      states_matrix_b(:, :, i) = 0.0_4
    END DO
    CALL GET_HYPER_STATES_B(hyper_states, hyper_states_b, &
&                     hyper_states_matrix, hyper_states_matrix_b)
  END SUBROUTINE HYPER_STATES_TO_STATES_B

!%      TODO comment
  SUBROUTINE HYPER_STATES_TO_STATES(hyper_states, states, setup, &
&   input_data)
    IMPLICIT NONE
    TYPE(HYPER_STATESDT), INTENT(IN) :: hyper_states
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(hyper_states%hp, 1), SIZE(hyper_states%hp, &
&   2), ns) :: hyper_states_matrix
    REAL(sp), DIMENSION(SIZE(states%hp, 1), SIZE(states%hp, 2), ns) :: &
&   states_matrix
    REAL(sp), DIMENSION(SIZE(states%hp, 1), SIZE(states%hp, 2)) :: d, &
&   dpb
    INTEGER :: i, j
    REAL(sp) :: a, b
    INTRINSIC TRIM
    INTRINSIC EXP
    CALL GET_HYPER_STATES(hyper_states, hyper_states_matrix)
    CALL GET_STATES(states, states_matrix)
!% Add mask later here
!% 1 in dim2 will be replace with k and apply where on Omega
    DO i=1,ns
      states_matrix(:, :, i) = hyper_states_matrix(1, 1, i)
      DO j=1,setup%nd
        d = input_data%descriptor(:, :, j)
        SELECT CASE  (TRIM(setup%optimize%mapping)) 
        CASE ('hyper-linear') 
          a = hyper_states_matrix(j+1, 1, i)
          b = 1._sp
        CASE ('hyper-polynomial') 
          a = hyper_states_matrix(2*j, 1, i)
          b = hyper_states_matrix(2*j+1, 1, i)
        END SELECT
        dpb = d**b
        states_matrix(:, :, i) = states_matrix(:, :, i) + a*dpb
      END DO
!% sigmoid transformation lambda = 1
      states_matrix(:, :, i) = (setup%optimize%ub_states(i)-setup%&
&       optimize%lb_states(i))*(1._sp/(1._sp+EXP(-states_matrix(:, :, i)&
&       ))) + setup%optimize%lb_states(i)
    END DO
    CALL SET_STATES(states, states_matrix)
  END SUBROUTINE HYPER_STATES_TO_STATES

END MODULE MWD_STATES_MANIPULATION_DIFF

!%    This module `mwd_cost` encapsulates all SMASH cost (type, subroutines, functions)
!%    This module is wrapped and differentiated.
!%
!%      contains
!%
!%      [1]  compute_jobs
!%      [2]  compute_jreg
!%      [3]  compute_cost
!%      [4]  nse
!%      [5]  kge_components
!%      [6]  kge
!%      [7]  se
!%      [8]  rmse
!%      [9]  logarithmique
!%      [10] reg_prior
MODULE MWD_COST_DIFF
!% only: sp, dp, lchar, np, ns
  USE MD_COMMON
!% only: SetupDT
  USE MWD_SETUP
!%only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: ParametersDT, Hyper_ParametersDT
  USE MWD_PARAMETERS_DIFF
!% only: StatesDT, Hyper_StatesDT
  USE MWD_STATES_DIFF
!% only: OutputDT
  USE MWD_OUTPUT_DIFF
  USE MWD_PARAMETERS_MANIPULATION_DIFF
  USE MWD_STATES_MANIPULATION_DIFF
  IMPLICIT NONE
  PUBLIC :: compute_jobs, compute_jreg, compute_cost
  PUBLIC :: compute_jobs_d, compute_jreg_d, compute_cost_d, &
& compute_jobs_b, compute_jreg_b, compute_cost_b

CONTAINS
!  Differentiation of compute_jobs in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: jobs
!   with respect to varying inputs: *(output.qsim)
!   Plus diff mem management of: output.qsim:in
  SUBROUTINE COMPUTE_JOBS_D(setup, mesh, input_data, output, output_d, &
&   jobs, jobs_d)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_d
    REAL(sp), INTENT(OUT) :: jobs
    REAL(sp), INTENT(OUT) :: jobs_d
    REAL(sp), DIMENSION(setup%ntime_step-setup%optimize%optim_start_step&
&   +1) :: qo, qs
    REAL(sp), DIMENSION(setup%ntime_step-setup%optimize%optim_start_step&
&   +1) :: qs_d
    REAL(sp), DIMENSION(mesh%ng) :: gauge_jobs
    REAL(sp), DIMENSION(mesh%ng) :: gauge_jobs_d
    REAL(sp) :: imd
    REAL(sp) :: imd_d
    INTEGER :: g, row, col
    INTRINSIC REAL
    INTRINSIC ANY
    gauge_jobs_d = 0.0_4
    DO g=1,mesh%ng
      qs_d = setup%dt*1e3_sp*output_d%qsim(g, setup%optimize%&
&       optim_start_step:setup%ntime_step)/mesh%area(g)
      qs = output%qsim(g, setup%optimize%optim_start_step:setup%&
&       ntime_step)*setup%dt/mesh%area(g)*1e3_sp
      row = mesh%gauge_pos(g, 1)
      col = mesh%gauge_pos(g, 2)
      qo = input_data%qobs(g, setup%optimize%optim_start_step:setup%&
&       ntime_step)*setup%dt/(REAL(mesh%drained_area(row, col))*mesh%dx*&
&       mesh%dx)*1e3_sp
      IF (ANY(qo .GE. 0._sp)) THEN
        SELECT CASE  (setup%optimize%jobs_fun) 
        CASE ('nse') 
          gauge_jobs_d(g) = NSE_D(qo, qs, qs_d, gauge_jobs(g))
        CASE ('kge') 
          gauge_jobs_d(g) = KGE_D(qo, qs, qs_d, gauge_jobs(g))
        CASE ('kge2') 
          imd_d = KGE_D(qo, qs, qs_d, imd)
          gauge_jobs_d(g) = 2*imd*imd_d
        CASE ('se') 
          gauge_jobs_d(g) = SE_D(qo, qs, qs_d, gauge_jobs(g))
        CASE ('rmse') 
          gauge_jobs_d(g) = RMSE_D(qo, qs, qs_d, gauge_jobs(g))
        CASE ('logarithmique') 
          gauge_jobs_d(g) = LOGARITHMIQUE_D(qo, qs, qs_d, gauge_jobs(g))
        END SELECT
      END IF
    END DO
    jobs_d = 0.0_4
    DO g=1,mesh%ng
      jobs_d = jobs_d + setup%optimize%wgauge(g)*gauge_jobs_d(g)
    END DO
  END SUBROUTINE COMPUTE_JOBS_D

!  Differentiation of compute_jobs in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: jobs
!   with respect to varying inputs: *(output.qsim)
!   Plus diff mem management of: output.qsim:in
  SUBROUTINE COMPUTE_JOBS_B(setup, mesh, input_data, output, output_b, &
&   jobs, jobs_b)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_b
    REAL(sp) :: jobs
    REAL(sp) :: jobs_b
    REAL(sp), DIMENSION(setup%ntime_step-setup%optimize%optim_start_step&
&   +1) :: qo, qs
    REAL(sp), DIMENSION(setup%ntime_step-setup%optimize%optim_start_step&
&   +1) :: qs_b
    REAL(sp), DIMENSION(mesh%ng) :: gauge_jobs
    REAL(sp), DIMENSION(mesh%ng) :: gauge_jobs_b
    REAL(sp) :: imd
    REAL(sp) :: imd_b
    INTEGER :: g, row, col
    INTRINSIC REAL
    INTRINSIC ANY
    REAL(sp) :: res
    REAL(sp) :: res_b
    REAL :: res0
    REAL :: res_b0
    REAL :: res1
    REAL :: res_b1
    REAL :: res2
    REAL :: res_b2
    REAL :: res3
    REAL :: res_b3
    INTEGER :: branch
    DO g=1,mesh%ng
      qs = output%qsim(g, setup%optimize%optim_start_step:setup%&
&       ntime_step)*setup%dt/mesh%area(g)*1e3_sp
      row = mesh%gauge_pos(g, 1)
      col = mesh%gauge_pos(g, 2)
      CALL PUSHREAL4ARRAY(qo, setup%ntime_step - setup%optimize%&
&                   optim_start_step + 1)
      qo = input_data%qobs(g, setup%optimize%optim_start_step:setup%&
&       ntime_step)*setup%dt/(REAL(mesh%drained_area(row, col))*mesh%dx*&
&       mesh%dx)*1e3_sp
      IF (ANY(qo .GE. 0._sp)) THEN
        SELECT CASE  (setup%optimize%jobs_fun) 
        CASE ('nse') 
          res = NSE(qo, qs)
          CALL PUSHCONTROL3B(6)
        CASE ('kge') 
          res0 = KGE(qo, qs)
          CALL PUSHCONTROL3B(5)
        CASE ('kge2') 
          CALL PUSHREAL4(imd)
          imd = KGE(qo, qs)
          CALL PUSHCONTROL3B(4)
        CASE ('se') 
          res1 = SE(qo, qs)
          CALL PUSHCONTROL3B(3)
        CASE ('rmse') 
          res2 = RMSE(qo, qs)
          CALL PUSHCONTROL3B(2)
        CASE ('logarithmique') 
          res3 = LOGARITHMIQUE(qo, qs)
          CALL PUSHCONTROL3B(1)
        CASE DEFAULT
          CALL PUSHCONTROL3B(7)
        END SELECT
      ELSE
        CALL PUSHCONTROL3B(0)
      END IF
    END DO
    gauge_jobs_b = 0.0_4
    DO g=mesh%ng,1,-1
      gauge_jobs_b(g) = gauge_jobs_b(g) + setup%optimize%wgauge(g)*&
&       jobs_b
    END DO
    output_b%qsim = 0.0_4
    DO g=mesh%ng,1,-1
      CALL POPCONTROL3B(branch)
      IF (branch .LT. 4) THEN
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) THEN
            qs_b = 0.0_4
          ELSE
            qs = output%qsim(g, setup%optimize%optim_start_step:setup%&
&             ntime_step)*setup%dt/mesh%area(g)*1e3_sp
            qs_b = 0.0_4
            res_b3 = gauge_jobs_b(g)
            gauge_jobs_b(g) = 0.0_4
            CALL LOGARITHMIQUE_B(qo, qs, qs_b, res_b3)
          END IF
        ELSE IF (branch .EQ. 2) THEN
          qs = output%qsim(g, setup%optimize%optim_start_step:setup%&
&           ntime_step)*setup%dt/mesh%area(g)*1e3_sp
          qs_b = 0.0_4
          res_b2 = gauge_jobs_b(g)
          gauge_jobs_b(g) = 0.0_4
          CALL RMSE_B(qo, qs, qs_b, res_b2)
        ELSE
          qs = output%qsim(g, setup%optimize%optim_start_step:setup%&
&           ntime_step)*setup%dt/mesh%area(g)*1e3_sp
          qs_b = 0.0_4
          res_b1 = gauge_jobs_b(g)
          gauge_jobs_b(g) = 0.0_4
          CALL SE_B(qo, qs, qs_b, res_b1)
        END IF
      ELSE IF (branch .LT. 6) THEN
        IF (branch .EQ. 4) THEN
          imd_b = 2*imd*gauge_jobs_b(g)
          gauge_jobs_b(g) = 0.0_4
          qs = output%qsim(g, setup%optimize%optim_start_step:setup%&
&           ntime_step)*setup%dt/mesh%area(g)*1e3_sp
          CALL POPREAL4(imd)
          CALL KGE_B(qo, qs, qs_b, imd_b)
        ELSE
          qs = output%qsim(g, setup%optimize%optim_start_step:setup%&
&           ntime_step)*setup%dt/mesh%area(g)*1e3_sp
          qs_b = 0.0_4
          res_b0 = gauge_jobs_b(g)
          gauge_jobs_b(g) = 0.0_4
          CALL KGE_B(qo, qs, qs_b, res_b0)
        END IF
      ELSE IF (branch .EQ. 6) THEN
        qs = output%qsim(g, setup%optimize%optim_start_step:setup%&
&         ntime_step)*setup%dt/mesh%area(g)*1e3_sp
        qs_b = 0.0_4
        res_b = gauge_jobs_b(g)
        gauge_jobs_b(g) = 0.0_4
        CALL NSE_B(qo, qs, qs_b, res_b)
      ELSE
        qs_b = 0.0_4
      END IF
      CALL POPREAL4ARRAY(qo, setup%ntime_step - setup%optimize%&
&                  optim_start_step + 1)
      output_b%qsim(g, setup%optimize%optim_start_step:setup%ntime_step)&
&      = output_b%qsim(g, setup%optimize%optim_start_step:setup%&
&       ntime_step) + setup%dt*1e3_sp*qs_b/mesh%area(g)
    END DO
  END SUBROUTINE COMPUTE_JOBS_B

  SUBROUTINE COMPUTE_JOBS(setup, mesh, input_data, output, jobs)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    REAL(sp), INTENT(OUT) :: jobs
    REAL(sp), DIMENSION(setup%ntime_step-setup%optimize%optim_start_step&
&   +1) :: qo, qs
    REAL(sp), DIMENSION(mesh%ng) :: gauge_jobs
    REAL(sp) :: imd
    INTEGER :: g, row, col
    INTRINSIC REAL
    INTRINSIC ANY
    jobs = 0._sp
    gauge_jobs = 0._sp
    DO g=1,mesh%ng
      qs = output%qsim(g, setup%optimize%optim_start_step:setup%&
&       ntime_step)*setup%dt/mesh%area(g)*1e3_sp
      row = mesh%gauge_pos(g, 1)
      col = mesh%gauge_pos(g, 2)
      qo = input_data%qobs(g, setup%optimize%optim_start_step:setup%&
&       ntime_step)*setup%dt/(REAL(mesh%drained_area(row, col))*mesh%dx*&
&       mesh%dx)*1e3_sp
      IF (ANY(qo .GE. 0._sp)) THEN
        SELECT CASE  (setup%optimize%jobs_fun) 
        CASE ('nse') 
          gauge_jobs(g) = NSE(qo, qs)
        CASE ('kge') 
          gauge_jobs(g) = KGE(qo, qs)
        CASE ('kge2') 
          imd = KGE(qo, qs)
          gauge_jobs(g) = imd*imd
        CASE ('se') 
          gauge_jobs(g) = SE(qo, qs)
        CASE ('rmse') 
          gauge_jobs(g) = RMSE(qo, qs)
        CASE ('logarithmique') 
          gauge_jobs(g) = LOGARITHMIQUE(qo, qs)
        END SELECT
      END IF
    END DO
    DO g=1,mesh%ng
      jobs = jobs + setup%optimize%wgauge(g)*gauge_jobs(g)
    END DO
  END SUBROUTINE COMPUTE_JOBS

!  Differentiation of compute_jreg in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: jreg
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.lr)
!                *(states.hi) *(states.hp) *(states.hft) *(states.hst)
!                *(states.hlr)
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.lr:in
!                states.hi:in states.hp:in states.hft:in states.hst:in
!                states.hlr:in
!% WIP
  SUBROUTINE COMPUTE_JREG_D(setup, mesh, parameters, parameters_d, &
&   parameters_bgd, states, states_d, states_bgd, jreg, jreg_d)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters, parameters_bgd
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters_d
    TYPE(STATESDT), INTENT(IN) :: states, states_bgd
    TYPE(STATESDT), INTENT(IN) :: states_d
    REAL(sp), INTENT(INOUT) :: jreg
    REAL(sp), INTENT(INOUT) :: jreg_d
    REAL(sp) :: parameters_jreg, states_jreg
    REAL(sp) :: parameters_jreg_d, states_jreg_d
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, np) :: parameters_matrix, &
&   parameters_bgd_matrix
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, np) :: parameters_matrix_d
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, ns) :: states_matrix, &
&   states_bgd_matrix
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, ns) :: states_matrix_d
    CALL GET_PARAMETERS_D(parameters, parameters_d, parameters_matrix, &
&                   parameters_matrix_d)
    CALL GET_PARAMETERS(parameters_bgd, parameters_bgd_matrix)
    CALL GET_STATES_D(states, states_d, states_matrix, states_matrix_d)
    CALL GET_STATES(states_bgd, states_bgd_matrix)
    SELECT CASE  (setup%optimize%jreg_fun) 
    CASE ('prior') 
!% Normalize prior between parameters and states
      parameters_jreg_d = REG_PRIOR_D(mesh, np, parameters_matrix, &
&       parameters_matrix_d, parameters_bgd_matrix, parameters_jreg)
      states_jreg_d = REG_PRIOR_D(mesh, ns, states_matrix, &
&       states_matrix_d, states_bgd_matrix, states_jreg)
    CASE DEFAULT
      parameters_jreg_d = 0.0_4
      states_jreg_d = 0.0_4
    END SELECT
    jreg_d = parameters_jreg_d + states_jreg_d
  END SUBROUTINE COMPUTE_JREG_D

!  Differentiation of compute_jreg in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: jreg
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.lr)
!                *(states.hi) *(states.hp) *(states.hft) *(states.hst)
!                *(states.hlr)
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.lr:in
!                states.hi:in states.hp:in states.hft:in states.hst:in
!                states.hlr:in
!% WIP
  SUBROUTINE COMPUTE_JREG_B(setup, mesh, parameters, parameters_b, &
&   parameters_bgd, states, states_b, states_bgd, jreg, jreg_b)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters, parameters_bgd
    TYPE(PARAMETERSDT) :: parameters_b
    TYPE(STATESDT), INTENT(IN) :: states, states_bgd
    TYPE(STATESDT) :: states_b
    REAL(sp), INTENT(INOUT) :: jreg
    REAL(sp), INTENT(INOUT) :: jreg_b
    REAL(sp) :: parameters_jreg, states_jreg
    REAL(sp) :: parameters_jreg_b, states_jreg_b
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, np) :: parameters_matrix, &
&   parameters_bgd_matrix
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, np) :: parameters_matrix_b
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, ns) :: states_matrix, &
&   states_bgd_matrix
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, ns) :: states_matrix_b
    REAL(sp) :: res
    REAL(sp) :: res_b
    REAL(sp) :: res0
    REAL(sp) :: res_b0
    INTEGER :: branch
    CALL GET_PARAMETERS(parameters, parameters_matrix)
    CALL GET_PARAMETERS(parameters_bgd, parameters_bgd_matrix)
    CALL GET_STATES(states, states_matrix)
    CALL GET_STATES(states_bgd, states_bgd_matrix)
    SELECT CASE  (setup%optimize%jreg_fun) 
    CASE ('prior') 
!% Normalize prior between parameters and states
      res = REG_PRIOR(mesh, np, parameters_matrix, parameters_bgd_matrix&
&       )
      res0 = REG_PRIOR(mesh, ns, states_matrix, states_bgd_matrix)
      CALL PUSHCONTROL1B(1)
    CASE DEFAULT
      CALL PUSHCONTROL1B(0)
    END SELECT
    parameters_jreg_b = jreg_b
    states_jreg_b = jreg_b
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      states_matrix_b = 0.0_4
      parameters_matrix_b = 0.0_4
    ELSE
      states_matrix_b = 0.0_4
      res_b0 = states_jreg_b
      CALL REG_PRIOR_B(mesh, ns, states_matrix, states_matrix_b, &
&                states_bgd_matrix, res_b0)
      parameters_matrix_b = 0.0_4
      res_b = parameters_jreg_b
      CALL REG_PRIOR_B(mesh, np, parameters_matrix, parameters_matrix_b&
&                , parameters_bgd_matrix, res_b)
    END IF
    CALL GET_STATES_B(states, states_b, states_matrix, states_matrix_b)
    CALL GET_PARAMETERS_B(parameters, parameters_b, parameters_matrix, &
&                   parameters_matrix_b)
  END SUBROUTINE COMPUTE_JREG_B

!% WIP
  SUBROUTINE COMPUTE_JREG(setup, mesh, parameters, parameters_bgd, &
&   states, states_bgd, jreg)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters, parameters_bgd
    TYPE(STATESDT), INTENT(IN) :: states, states_bgd
    REAL(sp), INTENT(INOUT) :: jreg
    REAL(sp) :: parameters_jreg, states_jreg
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, np) :: parameters_matrix, &
&   parameters_bgd_matrix
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, ns) :: states_matrix, &
&   states_bgd_matrix
    CALL GET_PARAMETERS(parameters, parameters_matrix)
    CALL GET_PARAMETERS(parameters_bgd, parameters_bgd_matrix)
    CALL GET_STATES(states, states_matrix)
    CALL GET_STATES(states_bgd, states_bgd_matrix)
    jreg = 0._sp
    parameters_jreg = 0._sp
    states_jreg = 0._sp
    SELECT CASE  (setup%optimize%jreg_fun) 
    CASE ('prior') 
!% Normalize prior between parameters and states
      parameters_jreg = REG_PRIOR(mesh, np, parameters_matrix, &
&       parameters_bgd_matrix)
      states_jreg = REG_PRIOR(mesh, ns, states_matrix, states_bgd_matrix&
&       )
    END SELECT
    jreg = parameters_jreg + states_jreg
  END SUBROUTINE COMPUTE_JREG

!  Differentiation of compute_cost in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: cost
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.lr)
!                *(output.qsim) *(states.hi) *(states.hp) *(states.hft)
!                *(states.hst) *(states.hlr)
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.lr:in
!                output.qsim:in states.hi:in states.hp:in states.hft:in
!                states.hst:in states.hlr:in
  SUBROUTINE COMPUTE_COST_D(setup, mesh, input_data, parameters, &
&   parameters_d, parameters_bgd, states, states_d, states_bgd, output, &
&   output_d, cost, cost_d)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters, parameters_bgd
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters_d
    TYPE(STATESDT), INTENT(IN) :: states, states_bgd
    TYPE(STATESDT), INTENT(IN) :: states_d
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_d
    REAL(sp), INTENT(INOUT) :: cost
    REAL(sp), INTENT(INOUT) :: cost_d
    REAL(sp) :: jobs, jreg
    REAL(sp) :: jobs_d, jreg_d
    CALL COMPUTE_JOBS_D(setup, mesh, input_data, output, output_d, jobs&
&                 , jobs_d)
!% Only compute in case wjreg > 0
    IF (setup%optimize%wjreg .GT. 0._sp) THEN
      CALL COMPUTE_JREG_D(setup, mesh, parameters, parameters_d, &
&                   parameters_bgd, states, states_d, states_bgd, jreg, &
&                   jreg_d)
    ELSE
      jreg_d = 0.0_4
    END IF
    cost_d = jobs_d + setup%optimize%wjreg*jreg_d
  END SUBROUTINE COMPUTE_COST_D

!  Differentiation of compute_cost in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: cost
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.lr)
!                *(output.qsim) *(states.hi) *(states.hp) *(states.hft)
!                *(states.hst) *(states.hlr)
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.lr:in
!                output.qsim:in states.hi:in states.hp:in states.hft:in
!                states.hst:in states.hlr:in
  SUBROUTINE COMPUTE_COST_B(setup, mesh, input_data, parameters, &
&   parameters_b, parameters_bgd, states, states_b, states_bgd, output, &
&   output_b, cost, cost_b)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters, parameters_bgd
    TYPE(PARAMETERSDT) :: parameters_b
    TYPE(STATESDT), INTENT(IN) :: states, states_bgd
    TYPE(STATESDT) :: states_b
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_b
    REAL(sp), INTENT(INOUT) :: cost
    REAL(sp), INTENT(INOUT) :: cost_b
    REAL(sp) :: jobs, jreg
    REAL(sp) :: jobs_b, jreg_b
    INTEGER :: branch
    CALL COMPUTE_JOBS(setup, mesh, input_data, output, jobs)
!% Only compute in case wjreg > 0
    IF (setup%optimize%wjreg .GT. 0._sp) THEN
      CALL COMPUTE_JREG(setup, mesh, parameters, parameters_bgd, states&
&                 , states_bgd, jreg)
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    jobs_b = cost_b
    jreg_b = setup%optimize%wjreg*cost_b
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL COMPUTE_JREG_B(setup, mesh, parameters, parameters_b, &
&                   parameters_bgd, states, states_b, states_bgd, jreg, &
&                   jreg_b)
    ELSE
      parameters_b%ci = 0.0_4
      parameters_b%cp = 0.0_4
      parameters_b%beta = 0.0_4
      parameters_b%cft = 0.0_4
      parameters_b%cst = 0.0_4
      parameters_b%alpha = 0.0_4
      parameters_b%exc = 0.0_4
      parameters_b%lr = 0.0_4
      states_b%hi = 0.0_4
      states_b%hp = 0.0_4
      states_b%hft = 0.0_4
      states_b%hst = 0.0_4
      states_b%hlr = 0.0_4
    END IF
    CALL COMPUTE_JOBS_B(setup, mesh, input_data, output, output_b, jobs&
&                 , jobs_b)
  END SUBROUTINE COMPUTE_COST_B

  SUBROUTINE COMPUTE_COST(setup, mesh, input_data, parameters, &
&   parameters_bgd, states, states_bgd, output, cost)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters, parameters_bgd
    TYPE(STATESDT), INTENT(IN) :: states, states_bgd
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    REAL(sp), INTENT(INOUT) :: cost
    REAL(sp) :: jobs, jreg
    CALL COMPUTE_JOBS(setup, mesh, input_data, output, jobs)
!% Only compute in case wjreg > 0
    IF (setup%optimize%wjreg .GT. 0._sp) THEN
      CALL COMPUTE_JREG(setup, mesh, parameters, parameters_bgd, states&
&                 , states_bgd, jreg)
    ELSE
      jreg = 0._sp
    END IF
    cost = jobs + setup%optimize%wjreg*jreg
    output%cost = cost
  END SUBROUTINE COMPUTE_COST

!  Differentiation of hyper_compute_cost in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: cost
!   with respect to varying inputs: *(output.qsim)
!   Plus diff mem management of: output.qsim:in
!% TODO comment and refactorize
  SUBROUTINE HYPER_COMPUTE_COST_D(setup, mesh, input_data, &
&   hyper_parameters, hyper_parameters_bgd, hyper_states, &
&   hyper_states_bgd, output, output_d, cost, cost_d)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(HYPER_PARAMETERSDT), INTENT(IN) :: hyper_parameters, &
&   hyper_parameters_bgd
    TYPE(HYPER_STATESDT), INTENT(IN) :: hyper_states, hyper_states_bgd
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_d
    REAL(sp), INTENT(INOUT) :: cost
    REAL(sp), INTENT(INOUT) :: cost_d
    REAL(sp) :: jobs, jreg
    REAL(sp) :: jobs_d
    CALL COMPUTE_JOBS_D(setup, mesh, input_data, output, output_d, jobs&
&                 , jobs_d)
    cost_d = jobs_d
  END SUBROUTINE HYPER_COMPUTE_COST_D

!  Differentiation of hyper_compute_cost in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: cost
!   with respect to varying inputs: *(output.qsim)
!   Plus diff mem management of: output.qsim:in
!% TODO comment and refactorize
  SUBROUTINE HYPER_COMPUTE_COST_B(setup, mesh, input_data, &
&   hyper_parameters, hyper_parameters_bgd, hyper_states, &
&   hyper_states_bgd, output, output_b, cost, cost_b)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(HYPER_PARAMETERSDT), INTENT(IN) :: hyper_parameters, &
&   hyper_parameters_bgd
    TYPE(HYPER_STATESDT), INTENT(IN) :: hyper_states, hyper_states_bgd
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_b
    REAL(sp), INTENT(INOUT) :: cost
    REAL(sp), INTENT(INOUT) :: cost_b
    REAL(sp) :: jobs, jreg
    REAL(sp) :: jobs_b
    CALL COMPUTE_JOBS(setup, mesh, input_data, output, jobs)
    jobs_b = cost_b
    CALL COMPUTE_JOBS_B(setup, mesh, input_data, output, output_b, jobs&
&                 , jobs_b)
  END SUBROUTINE HYPER_COMPUTE_COST_B

!% TODO comment and refactorize
  SUBROUTINE HYPER_COMPUTE_COST(setup, mesh, input_data, &
&   hyper_parameters, hyper_parameters_bgd, hyper_states, &
&   hyper_states_bgd, output, cost)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(HYPER_PARAMETERSDT), INTENT(IN) :: hyper_parameters, &
&   hyper_parameters_bgd
    TYPE(HYPER_STATESDT), INTENT(IN) :: hyper_states, hyper_states_bgd
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    REAL(sp), INTENT(INOUT) :: cost
    REAL(sp) :: jobs, jreg
    CALL COMPUTE_JOBS(setup, mesh, input_data, output, jobs)
    jreg = 0._sp
    cost = jobs + setup%optimize%wjreg*jreg
    output%cost = cost
  END SUBROUTINE HYPER_COMPUTE_COST

!  Differentiation of nse in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: res
!   with respect to varying inputs: y
  FUNCTION NSE_D(x, y, y_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:), INTENT(IN) :: y_d
    REAL(sp) :: res
    REAL(sp) :: res_d
    REAL(sp) :: sum_x, sum_xx, sum_yy, sum_xy, mean_x, num, den
    REAL(sp) :: sum_yy_d, sum_xy_d, num_d
    INTEGER :: i, n
    INTRINSIC SIZE
!% Metric computation
    n = 0
    sum_x = 0.
    sum_xx = 0.
    sum_yy_d = 0.0_4
    sum_xy_d = 0.0_4
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0.) THEN
        n = n + 1
        sum_x = sum_x + x(i)
        sum_xx = sum_xx + x(i)*x(i)
        sum_yy_d = sum_yy_d + 2*y(i)*y_d(i)
        sum_xy_d = sum_xy_d + x(i)*y_d(i)
      END IF
    END DO
    mean_x = sum_x/n
!% NSE numerator / denominator
    num_d = sum_yy_d - 2*sum_xy_d
    den = sum_xx - n*mean_x*mean_x
!% NSE criterion
    res_d = num_d/den
  END FUNCTION NSE_D

!  Differentiation of nse in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: res
!   with respect to varying inputs: y
  SUBROUTINE NSE_B(x, y, y_b, res_b)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:) :: y_b
    REAL(sp) :: res
    REAL(sp) :: res_b
    REAL(sp) :: sum_x, sum_xx, sum_yy, sum_xy, mean_x, num, den
    REAL(sp) :: sum_yy_b, sum_xy_b, num_b
    INTEGER :: i, n
    INTRINSIC SIZE
    INTEGER :: ad_to
    INTEGER :: branch
!% Metric computation
    n = 0
    sum_x = 0.
    sum_xx = 0.
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0.) THEN
        n = n + 1
        sum_x = sum_x + x(i)
        sum_xx = sum_xx + x(i)*x(i)
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    CALL PUSHINTEGER4(i - 1)
    mean_x = sum_x/n
!% NSE numerator / denominator
    den = sum_xx - n*mean_x*mean_x
!% NSE criterion
    num_b = res_b/den
    sum_yy_b = num_b
    sum_xy_b = -(2*num_b)
    y_b = 0.0_4
    CALL POPINTEGER4(ad_to)
    DO i=ad_to,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) y_b(i) = y_b(i) + x(i)*sum_xy_b + 2*y(i)*&
&         sum_yy_b
    END DO
  END SUBROUTINE NSE_B

  FUNCTION NSE(x, y) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp) :: res
    REAL(sp) :: sum_x, sum_xx, sum_yy, sum_xy, mean_x, num, den
    INTEGER :: i, n
    INTRINSIC SIZE
!% Metric computation
    n = 0
    sum_x = 0.
    sum_xx = 0.
    sum_yy = 0.
    sum_xy = 0.
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0.) THEN
        n = n + 1
        sum_x = sum_x + x(i)
        sum_xx = sum_xx + x(i)*x(i)
        sum_yy = sum_yy + y(i)*y(i)
        sum_xy = sum_xy + x(i)*y(i)
      END IF
    END DO
    mean_x = sum_x/n
!% NSE numerator / denominator
    num = sum_xx - 2*sum_xy + sum_yy
    den = sum_xx - n*mean_x*mean_x
!% NSE criterion
    res = num/den
  END FUNCTION NSE

!  Differentiation of kge_components in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: r a b
!   with respect to varying inputs: y
  SUBROUTINE KGE_COMPONENTS_D(x, y, y_d, r, r_d, a, a_d, b, b_d)
    IMPLICIT NONE
    REAL, DIMENSION(:), INTENT(IN) :: x, y
    REAL, DIMENSION(:), INTENT(IN) :: y_d
    REAL, INTENT(INOUT) :: r, a, b
    REAL, INTENT(INOUT) :: r_d, a_d, b_d
    REAL :: sum_x, sum_y, sum_xx, sum_yy, sum_xy, mean_x, mean_y, var_x&
&   , var_y, cov
    REAL :: sum_y_d, sum_yy_d, sum_xy_d, mean_y_d, var_y_d, cov_d
    INTEGER :: n, i
    INTRINSIC SIZE
    INTRINSIC SQRT
    REAL :: result1
    REAL :: result1_d
    REAL :: result2
    REAL :: result2_d
    REAL :: temp
! Metric computation
    n = 0
    sum_x = 0.
    sum_y = 0.
    sum_xx = 0.
    sum_yy = 0.
    sum_xy = 0.
    sum_yy_d = 0.0
    sum_y_d = 0.0
    sum_xy_d = 0.0
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0.) THEN
        n = n + 1
        sum_x = sum_x + x(i)
        sum_y_d = sum_y_d + y_d(i)
        sum_y = sum_y + y(i)
        sum_xx = sum_xx + x(i)*x(i)
        sum_yy_d = sum_yy_d + 2*y(i)*y_d(i)
        sum_yy = sum_yy + y(i)*y(i)
        sum_xy_d = sum_xy_d + x(i)*y_d(i)
        sum_xy = sum_xy + x(i)*y(i)
      END IF
    END DO
    mean_x = sum_x/n
    mean_y_d = sum_y_d/n
    mean_y = sum_y/n
    var_x = sum_xx/n - mean_x*mean_x
    var_y_d = sum_yy_d/n - 2*mean_y*mean_y_d
    var_y = sum_yy/n - mean_y*mean_y
    cov_d = sum_xy_d/n - mean_x*mean_y_d
    cov = sum_xy/n - mean_x*mean_y
! KGE components (r, alpha, beta)
    result1 = SQRT(var_x)
    temp = SQRT(var_y)
    IF (var_y .EQ. 0.0) THEN
      result2_d = 0.0
    ELSE
      result2_d = var_y_d/(2.0*temp)
    END IF
    result2 = temp
    temp = cov/(result1*result2)
    r_d = (cov_d-temp*result1*result2_d)/(result1*result2)
    r = temp
    temp = SQRT(var_y)
    IF (var_y .EQ. 0.0) THEN
      result1_d = 0.0
    ELSE
      result1_d = var_y_d/(2.0*temp)
    END IF
    result1 = temp
    result2 = SQRT(var_x)
    a_d = result1_d/result2
    a = result1/result2
    b_d = mean_y_d/mean_x
    b = mean_y/mean_x
  END SUBROUTINE KGE_COMPONENTS_D

!  Differentiation of kge_components in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: r a b
!   with respect to varying inputs: y
  SUBROUTINE KGE_COMPONENTS_B(x, y, y_b, r, r_b, a, a_b, b, b_b)
    IMPLICIT NONE
    REAL, DIMENSION(:), INTENT(IN) :: x, y
    REAL, DIMENSION(:) :: y_b
    REAL, INTENT(INOUT) :: r, a, b
    REAL, INTENT(INOUT) :: r_b, a_b, b_b
    REAL :: sum_x, sum_y, sum_xx, sum_yy, sum_xy, mean_x, mean_y, var_x&
&   , var_y, cov
    REAL :: sum_y_b, sum_yy_b, sum_xy_b, mean_y_b, var_y_b, cov_b
    INTEGER :: n, i
    INTRINSIC SIZE
    INTRINSIC SQRT
    REAL :: result1
    REAL :: result1_b
    REAL :: result2
    REAL :: result2_b
    REAL :: temp_b
    INTEGER :: ad_to
    INTEGER :: branch
! Metric computation
    n = 0
    sum_x = 0.
    sum_y = 0.
    sum_xx = 0.
    sum_yy = 0.
    sum_xy = 0.
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0.) THEN
        n = n + 1
        sum_x = sum_x + x(i)
        sum_y = sum_y + y(i)
        sum_xx = sum_xx + x(i)*x(i)
        sum_yy = sum_yy + y(i)*y(i)
        sum_xy = sum_xy + x(i)*y(i)
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    CALL PUSHINTEGER4(i - 1)
    mean_x = sum_x/n
    mean_y = sum_y/n
    var_x = sum_xx/n - mean_x*mean_x
    var_y = sum_yy/n - mean_y*mean_y
    cov = sum_xy/n - mean_x*mean_y
! KGE components (r, alpha, beta)
    result1 = SQRT(var_x)
    result2 = SQRT(var_y)
    CALL PUSHREAL4(result2)
    result2 = SQRT(var_x)
    result1_b = a_b/result2
    CALL POPREAL4(result2)
    IF (var_y .EQ. 0.0) THEN
      var_y_b = 0.0
    ELSE
      var_y_b = result1_b/(2.0*SQRT(var_y))
    END IF
    temp_b = r_b/(result1*result2)
    cov_b = temp_b
    result2_b = -(cov*temp_b/result2)
    IF (.NOT.var_y .EQ. 0.0) var_y_b = var_y_b + result2_b/(2.0*SQRT(&
&       var_y))
    mean_y_b = b_b/mean_x - mean_x*cov_b - 2*mean_y*var_y_b
    sum_xy_b = cov_b/n
    sum_yy_b = var_y_b/n
    sum_y_b = mean_y_b/n
    y_b = 0.0
    CALL POPINTEGER4(ad_to)
    DO i=ad_to,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) y_b(i) = y_b(i) + x(i)*sum_xy_b + 2*y(i)*&
&         sum_yy_b + sum_y_b
    END DO
  END SUBROUTINE KGE_COMPONENTS_B

  SUBROUTINE KGE_COMPONENTS(x, y, r, a, b)
    IMPLICIT NONE
    REAL, DIMENSION(:), INTENT(IN) :: x, y
    REAL, INTENT(INOUT) :: r, a, b
    REAL :: sum_x, sum_y, sum_xx, sum_yy, sum_xy, mean_x, mean_y, var_x&
&   , var_y, cov
    INTEGER :: n, i
    INTRINSIC SIZE
    INTRINSIC SQRT
    REAL :: result1
    REAL :: result2
! Metric computation
    n = 0
    sum_x = 0.
    sum_y = 0.
    sum_xx = 0.
    sum_yy = 0.
    sum_xy = 0.
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0.) THEN
        n = n + 1
        sum_x = sum_x + x(i)
        sum_y = sum_y + y(i)
        sum_xx = sum_xx + x(i)*x(i)
        sum_yy = sum_yy + y(i)*y(i)
        sum_xy = sum_xy + x(i)*y(i)
      END IF
    END DO
    mean_x = sum_x/n
    mean_y = sum_y/n
    var_x = sum_xx/n - mean_x*mean_x
    var_y = sum_yy/n - mean_y*mean_y
    cov = sum_xy/n - mean_x*mean_y
! KGE components (r, alpha, beta)
    result1 = SQRT(var_x)
    result2 = SQRT(var_y)
    r = cov/result1/result2
    result1 = SQRT(var_y)
    result2 = SQRT(var_x)
    a = result1/result2
    b = mean_y/mean_x
  END SUBROUTINE KGE_COMPONENTS

!  Differentiation of kge in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: res
!   with respect to varying inputs: y
  FUNCTION KGE_D(x, y, y_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL, DIMENSION(:), INTENT(IN) :: x, y
    REAL, DIMENSION(:), INTENT(IN) :: y_d
    REAL :: res
    REAL :: res_d
    REAL :: r, a, b
    REAL :: r_d, a_d, b_d
    INTRINSIC SQRT
    REAL :: arg1
    REAL :: arg1_d
    REAL :: temp
    CALL KGE_COMPONENTS_D(x, y, y_d, r, r_d, a, a_d, b, b_d)
! KGE criterion
    arg1_d = 2*(r-1)*r_d + 2*(b-1)*b_d + 2*(a-1)*a_d
    arg1 = (r-1)*(r-1) + (b-1)*(b-1) + (a-1)*(a-1)
    temp = SQRT(arg1)
    IF (arg1 .EQ. 0.0) THEN
      res_d = 0.0
    ELSE
      res_d = arg1_d/(2.0*temp)
    END IF
    res = temp
  END FUNCTION KGE_D

!  Differentiation of kge in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: res
!   with respect to varying inputs: y
  SUBROUTINE KGE_B(x, y, y_b, res_b)
    IMPLICIT NONE
    REAL, DIMENSION(:), INTENT(IN) :: x, y
    REAL, DIMENSION(:) :: y_b
    REAL :: res
    REAL :: res_b
    REAL :: r, a, b
    REAL :: r_b, a_b, b_b
    INTRINSIC SQRT
    REAL :: arg1
    REAL :: arg1_b
    CALL KGE_COMPONENTS(x, y, r, a, b)
! KGE criterion
    arg1 = (r-1)*(r-1) + (b-1)*(b-1) + (a-1)*(a-1)
    arg1 = (r-1)*(r-1) + (b-1)*(b-1) + (a-1)*(a-1)
    IF (arg1 .EQ. 0.0) THEN
      arg1_b = 0.0
    ELSE
      arg1_b = res_b/(2.0*SQRT(arg1))
    END IF
    r_b = 2*(r-1)*arg1_b
    b_b = 2*(b-1)*arg1_b
    a_b = 2*(a-1)*arg1_b
    CALL KGE_COMPONENTS_B(x, y, y_b, r, r_b, a, a_b, b, b_b)
  END SUBROUTINE KGE_B

  FUNCTION KGE(x, y) RESULT (RES)
    IMPLICIT NONE
    REAL, DIMENSION(:), INTENT(IN) :: x, y
    REAL :: res
    REAL :: r, a, b
    INTRINSIC SQRT
    REAL :: arg1
    CALL KGE_COMPONENTS(x, y, r, a, b)
! KGE criterion
    arg1 = (r-1)*(r-1) + (b-1)*(b-1) + (a-1)*(a-1)
    res = SQRT(arg1)
  END FUNCTION KGE

!  Differentiation of se in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: res
!   with respect to varying inputs: y
  FUNCTION SE_D(x, y, y_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL, DIMENSION(:), INTENT(IN) :: x, y
    REAL, DIMENSION(:), INTENT(IN) :: y_d
    REAL :: res
    REAL :: res_d
    INTEGER :: i
    INTRINSIC SIZE
    res = 0.
    res_d = 0.0
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0.) THEN
        res_d = res_d - 2*(x(i)-y(i))*y_d(i)
        res = res + (x(i)-y(i))*(x(i)-y(i))
      END IF
    END DO
  END FUNCTION SE_D

!  Differentiation of se in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: res
!   with respect to varying inputs: y
  SUBROUTINE SE_B(x, y, y_b, res_b)
    IMPLICIT NONE
    REAL, DIMENSION(:), INTENT(IN) :: x, y
    REAL, DIMENSION(:) :: y_b
    REAL :: res
    REAL :: res_b
    INTEGER :: i
    INTRINSIC SIZE
    INTEGER :: ad_to
    INTEGER :: branch
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0.) THEN
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    ad_to = i - 1
    y_b = 0.0
    DO i=ad_to,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) y_b(i) = y_b(i) - 2*(x(i)-y(i))*res_b
    END DO
  END SUBROUTINE SE_B

  FUNCTION SE(x, y) RESULT (RES)
    IMPLICIT NONE
    REAL, DIMENSION(:), INTENT(IN) :: x, y
    REAL :: res
    INTEGER :: i
    INTRINSIC SIZE
    res = 0.
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0.) res = res + (x(i)-y(i))*(x(i)-y(i))
    END DO
  END FUNCTION SE

!  Differentiation of rmse in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: res
!   with respect to varying inputs: y
  FUNCTION RMSE_D(x, y, y_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL, DIMENSION(:), INTENT(IN) :: x, y
    REAL, DIMENSION(:), INTENT(IN) :: y_d
    REAL :: res
    REAL :: res_d
    INTEGER :: i, n
    INTRINSIC SIZE
    INTRINSIC SQRT
    REAL :: result1
    REAL :: result1_d
    REAL :: temp
    n = 0
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0.) n = n + 1
    END DO
    result1_d = SE_D(x, y, y_d, result1)
    temp = SQRT(result1/n)
    IF (result1/n .EQ. 0.0) THEN
      res_d = 0.0
    ELSE
      res_d = result1_d/(2.0*temp*n)
    END IF
    res = temp
  END FUNCTION RMSE_D

!  Differentiation of rmse in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: res
!   with respect to varying inputs: y
  SUBROUTINE RMSE_B(x, y, y_b, res_b)
    IMPLICIT NONE
    REAL, DIMENSION(:), INTENT(IN) :: x, y
    REAL, DIMENSION(:) :: y_b
    REAL :: res
    REAL :: res_b
    INTEGER :: i, n
    INTRINSIC SIZE
    INTRINSIC SQRT
    REAL :: result1
    REAL :: result1_b
    INTEGER :: ad_to
    INTEGER :: branch
    n = 0
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0.) THEN
        CALL PUSHCONTROL1B(1)
        n = n + 1
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    CALL PUSHINTEGER4(i - 1)
    result1 = SE(x, y)
    IF (result1/n .EQ. 0.0) THEN
      result1_b = 0.0
    ELSE
      result1_b = res_b/(n*2.0*SQRT(result1/n))
    END IF
    CALL SE_B(x, y, y_b, result1_b)
    CALL POPINTEGER4(ad_to)
    DO i=ad_to,1,-1
      CALL POPCONTROL1B(branch)
    END DO
  END SUBROUTINE RMSE_B

  FUNCTION RMSE(x, y) RESULT (RES)
    IMPLICIT NONE
    REAL, DIMENSION(:), INTENT(IN) :: x, y
    REAL :: res
    INTEGER :: i, n
    INTRINSIC SIZE
    INTRINSIC SQRT
    REAL :: result1
    n = 0
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0.) n = n + 1
    END DO
    result1 = SE(x, y)
    res = SQRT(result1/n)
  END FUNCTION RMSE

!  Differentiation of logarithmique in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: res
!   with respect to varying inputs: y
  FUNCTION LOGARITHMIQUE_D(x, y, y_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL, DIMENSION(:), INTENT(IN) :: x, y
    REAL, DIMENSION(:), INTENT(IN) :: y_d
    REAL :: res
    REAL :: res_d
    INTEGER :: i
    INTRINSIC SIZE
    INTRINSIC LOG
    REAL :: arg1
    REAL :: arg1_d
    REAL :: arg2
    REAL :: arg2_d
    REAL :: temp
    REAL :: temp0
    res_d = 0.0
    DO i=1,SIZE(x)
      IF (x(i) .GT. 0. .AND. y(i) .GT. 0.) THEN
        arg1_d = y_d(i)/x(i)
        arg1 = y(i)/x(i)
        arg2_d = y_d(i)/x(i)
        arg2 = y(i)/x(i)
        temp = LOG(arg2)
        temp0 = LOG(arg1)
        res_d = res_d + x(i)*(temp*arg1_d/arg1+temp0*arg2_d/arg2)
      END IF
    END DO
  END FUNCTION LOGARITHMIQUE_D

!  Differentiation of logarithmique in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: res
!   with respect to varying inputs: y
  SUBROUTINE LOGARITHMIQUE_B(x, y, y_b, res_b)
    IMPLICIT NONE
    REAL, DIMENSION(:), INTENT(IN) :: x, y
    REAL, DIMENSION(:) :: y_b
    REAL :: res
    REAL :: res_b
    INTEGER :: i
    INTRINSIC SIZE
    INTRINSIC LOG
    REAL :: arg1
    REAL :: arg1_b
    REAL :: arg2
    REAL :: arg2_b
    INTEGER :: ad_to
    INTEGER :: branch
    DO i=1,SIZE(x)
      IF (x(i) .GT. 0. .AND. y(i) .GT. 0.) THEN
        CALL PUSHREAL4(arg1)
        arg1 = y(i)/x(i)
        CALL PUSHREAL4(arg2)
        arg2 = y(i)/x(i)
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    ad_to = i - 1
    y_b = 0.0
    DO i=ad_to,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        arg1_b = LOG(arg2)*x(i)*res_b/arg1
        arg2_b = LOG(arg1)*x(i)*res_b/arg2
        CALL POPREAL4(arg2)
        y_b(i) = y_b(i) + arg2_b/x(i) + arg1_b/x(i)
        CALL POPREAL4(arg1)
      END IF
    END DO
  END SUBROUTINE LOGARITHMIQUE_B

  FUNCTION LOGARITHMIQUE(x, y) RESULT (RES)
    IMPLICIT NONE
    REAL, DIMENSION(:), INTENT(IN) :: x, y
    REAL :: res
    INTEGER :: i
    INTRINSIC SIZE
    INTRINSIC LOG
    REAL :: arg1
    REAL :: arg2
    res = 0.
    DO i=1,SIZE(x)
      IF (x(i) .GT. 0. .AND. y(i) .GT. 0.) THEN
        arg1 = y(i)/x(i)
        arg2 = y(i)/x(i)
        res = res + x(i)*LOG(arg1)*LOG(arg2)
      END IF
    END DO
  END FUNCTION LOGARITHMIQUE

!  Differentiation of reg_prior in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: res
!   with respect to varying inputs: matrix
!% TODO refactorize
  FUNCTION REG_PRIOR_D(mesh, size_mat3, matrix, matrix_d, matrix_bgd, &
&   res) RESULT (RES_D)
    IMPLICIT NONE
    TYPE(MESHDT), INTENT(IN) :: mesh
    INTEGER, INTENT(IN) :: size_mat3
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, size_mat3), INTENT(IN) :: &
&   matrix, matrix_bgd
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, size_mat3), INTENT(IN) :: &
&   matrix_d
    REAL(sp) :: res
    REAL(sp) :: res_d
    INTRINSIC SUM
    res_d = SUM(2*(matrix-matrix_bgd)*matrix_d)
    res = SUM((matrix-matrix_bgd)*(matrix-matrix_bgd))
  END FUNCTION REG_PRIOR_D

!  Differentiation of reg_prior in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: res
!   with respect to varying inputs: matrix
!% TODO refactorize
  SUBROUTINE REG_PRIOR_B(mesh, size_mat3, matrix, matrix_b, matrix_bgd, &
&   res_b)
    IMPLICIT NONE
    TYPE(MESHDT), INTENT(IN) :: mesh
    INTEGER, INTENT(IN) :: size_mat3
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, size_mat3), INTENT(IN) :: &
&   matrix, matrix_bgd
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, size_mat3) :: matrix_b
    REAL(sp) :: res
    REAL(sp) :: res_b
    INTRINSIC SUM
    matrix_b = 0.0_4
    matrix_b = 2*(matrix-matrix_bgd)*res_b
  END SUBROUTINE REG_PRIOR_B

!% TODO refactorize
  FUNCTION REG_PRIOR(mesh, size_mat3, matrix, matrix_bgd) RESULT (RES)
    IMPLICIT NONE
    TYPE(MESHDT), INTENT(IN) :: mesh
    INTEGER, INTENT(IN) :: size_mat3
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, size_mat3), INTENT(IN) :: &
&   matrix, matrix_bgd
    REAL(sp) :: res
    INTRINSIC SUM
    res = SUM((matrix-matrix_bgd)*(matrix-matrix_bgd))
  END FUNCTION REG_PRIOR

END MODULE MWD_COST_DIFF

!  Differentiation of base_forward in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: cost
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.lr)
!                *(states.hi) *(states.hp) *(states.hft) *(states.hst)
!                *(states.hlr)
!   RW status of diff variables: parameters.ci:(loc) *(parameters.ci):in
!                parameters.cp:(loc) *(parameters.cp):in parameters.beta:(loc)
!                *(parameters.beta):in parameters.cft:(loc) *(parameters.cft):in
!                parameters.cst:(loc) *(parameters.cst):in parameters.alpha:(loc)
!                *(parameters.alpha):in parameters.exc:(loc) *(parameters.exc):in
!                parameters.lr:(loc) *(parameters.lr):in *(output.qsim):(loc)
!                states.hi:(loc) *(states.hi):in-killed states.hp:(loc)
!                *(states.hp):in-killed states.hft:(loc) *(states.hft):in-killed
!                states.hst:(loc) *(states.hst):in-killed states.hlr:(loc)
!                *(states.hlr):in-killed cost:out
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.lr:in
!                output.qsim:in states.hi:in-out states.hp:in-out
!                states.hft:in-out states.hst:in-out states.hlr:in-out
SUBROUTINE BASE_FORWARD_D(setup, mesh, input_data, parameters, &
& parameters_d, parameters_bgd, states, states_d, states_bgd, output, &
& output_d, cost, cost_d)
!% only: sp
  USE MD_COMMON
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: Hyper_ParametersDT
  USE MWD_PARAMETERS_DIFF
!% only: Hyper_StatesDT
  USE MWD_STATES_DIFF
!% only: OutputDT
  USE MWD_OUTPUT_DIFF
!% only: gr_interception, gr_production, gr_exchange, &
  USE MD_GR_OPERATOR_DIFF
!% & gr_transfer
!% only: upstream_discharge, sparse_upstream_discharge, linear_routing
  USE MD_ROUTING_OPERATOR_DIFF
!% only: compute_cost, hyper_compuste_cost
  USE MWD_COST_DIFF
  IMPLICIT NONE
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
  TYPE(SETUPDT), INTENT(IN) :: setup
  TYPE(MESHDT), INTENT(IN) :: mesh
  TYPE(INPUT_DATADT), INTENT(IN) :: input_data
  TYPE(PARAMETERSDT), INTENT(IN) :: parameters, parameters_bgd
  TYPE(PARAMETERSDT), INTENT(IN) :: parameters_d
  TYPE(STATESDT), INTENT(INOUT) :: states, states_bgd
  TYPE(STATESDT), INTENT(INOUT) :: states_d
  TYPE(OUTPUTDT), INTENT(INOUT) :: output
  TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_d
  REAL(sp), INTENT(INOUT) :: cost
  REAL(sp), INTENT(INOUT) :: cost_d
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
  TYPE(STATESDT) :: states_imd
  TYPE(STATESDT) :: states_imd_d
  REAL(sp), DIMENSION(:, :), ALLOCATABLE :: q
  REAL(sp), DIMENSION(:, :), ALLOCATABLE :: q_d
  REAL(sp), DIMENSION(:), ALLOCATABLE :: sparse_q
  REAL(sp), DIMENSION(:), ALLOCATABLE :: sparse_q_d
  REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prl, prd, qd, qr&
& , ql, qt, qup, qrout
  REAL(sp) :: ei_d, pn_d, en_d, pr_d, perc_d, l_d, prr_d, prl_d, prd_d, &
& qd_d, qr_d, ql_d, qt_d, qup_d, qrout_d
  INTEGER :: t, i, row, col, k, g
  INTRINSIC MIN
  INTRINSIC MAX
  INTRINSIC REAL
  REAL(sp) :: temp
  REAL :: temp0
  states_imd_d = states_d
  states_imd = states
  IF (setup%sparse_storage) THEN
    ALLOCATE(sparse_q_d(mesh%nac))
    ALLOCATE(sparse_q(mesh%nac))
    output_d%qsim = 0.0_4
  ELSE
    ALLOCATE(q_d(mesh%nrow, mesh%ncol))
    ALLOCATE(q(mesh%nrow, mesh%ncol))
    output_d%qsim = 0.0_4
  END IF
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
  DO t=1,setup%ntime_step
!% [ DO SPACE ]
    DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialisation for time step (t) and cell (i)
!% =============================================================================================================== %!
      ei = 0._sp
      pn = 0._sp
      pr = 0._sp
      perc = 0._sp
      l = 0._sp
      qd = 0._sp
      qr = 0._sp
      ql = 0._sp
!% [ END IF PATH ]
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of drained area 
!% =========================================================================================================== %!
      IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
!% [ IF PATH ]
        row = mesh%path(1, i)
        col = mesh%path(2, i)
        IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, col&
&           )
!% [ END IF ACTIVE CELL ]
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
        IF (mesh%active_cell(row, col) .EQ. 1 .AND. mesh%&
&           local_active_cell(row, col) .EQ. 1) THEN
!% [ IF ACTIVE CELL ]
          IF (setup%sparse_storage) THEN
            prcp = input_data%sparse_prcp(k, t)
            pet = input_data%sparse_pet(k, t)
          ELSE
            prcp = input_data%prcp(row, col, t)
            pet = input_data%pet(row, col, t)
          END IF
!% [ END IF PRCP GAP ]
          IF (prcp .GE. 0 .AND. pet .GE. 0) THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module case [ 0 - 1 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%interception_module) 
            CASE (0) 
              IF (pet .GT. prcp) THEN
                ei = prcp
              ELSE
                ei = pet
              END IF
              IF (0._sp .LT. prcp - ei) THEN
                pn = prcp - ei
                ei_d = 0.0_4
                pn_d = 0.0_4
              ELSE
                pn = 0._sp
                ei_d = 0.0_4
                pn_d = 0.0_4
              END IF
            CASE (1) 
              CALL GR_INTERCEPTION_D(prcp, pet, parameters%ci(row, col)&
&                              , parameters_d%ci(row, col), states%hi(&
&                              row, col), states_d%hi(row, col), pn, &
&                              pn_d, ei, ei_d)
            CASE DEFAULT
              ei_d = 0.0_4
              pn_d = 0.0_4
            END SELECT
            en_d = -ei_d
            en = pet - ei
!% =============================================================================================== %!
!%   Production module case [ 0 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%production_module) 
            CASE (0) 
              CALL GR_PRODUCTION_D(pn, pn_d, en, en_d, parameters%cp(row&
&                            , col), parameters_d%cp(row, col), &
&                            parameters%beta(row, col), parameters_d%&
&                            beta(row, col), states%hp(row, col), &
&                            states_d%hp(row, col), pr, pr_d, perc, &
&                            perc_d)
            CASE DEFAULT
              perc_d = 0.0_4
              pr_d = 0.0_4
            END SELECT
!% =============================================================================================== %!
!%   Exchange module case [ 0 - 1 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%exchange_module) 
            CASE (0) 
              l = 0._sp
              l_d = 0.0_4
            CASE (1) 
              CALL GR_EXCHANGE_D(parameters%exc(row, col), parameters_d%&
&                          exc(row, col), states%hft(row, col), states_d&
&                          %hft(row, col), l, l_d)
            CASE DEFAULT
              l_d = 0.0_4
            END SELECT
          ELSE
            l_d = 0.0_4
            perc_d = 0.0_4
            pr_d = 0.0_4
          END IF
!% =================================================================================================== %!
!%   Transfer module case [ 0 ]
!% =================================================================================================== %!
          SELECT CASE  (setup%transfer_module) 
          CASE (0) 
            prr_d = (pr+perc)*parameters_d%alpha(row, col) + parameters%&
&             alpha(row, col)*(pr_d+perc_d) + l_d
            prr = parameters%alpha(row, col)*(pr+perc) + l
            prd_d = (1._sp-parameters%alpha(row, col))*(pr_d+perc_d) - (&
&             pr+perc)*parameters_d%alpha(row, col)
            prd = (1._sp-parameters%alpha(row, col))*(pr+perc)
            CALL GR_TRANSFER_D(5._sp, prcp, prr, prr_d, parameters%cft(&
&                        row, col), parameters_d%cft(row, col), states%&
&                        hft(row, col), states_d%hft(row, col), qr, qr_d&
&                       )
            IF (0._sp .LT. prd + l) THEN
              qd_d = prd_d + l_d
              qd = prd + l
              ql_d = 0.0_4
            ELSE
              qd = 0._sp
              qd_d = 0.0_4
              ql_d = 0.0_4
            END IF
          CASE (1) 
            prr_d = 0.9_sp*((pr+perc)*parameters_d%alpha(row, col)+&
&             parameters%alpha(row, col)*(pr_d+perc_d)) + l_d
            prr = 0.9_sp*parameters%alpha(row, col)*(pr+perc) + l
            prl_d = 0.9_sp*((1._sp-parameters%alpha(row, col))*(pr_d+&
&             perc_d)-(pr+perc)*parameters_d%alpha(row, col))
            prl = 0.9_sp*(1._sp-parameters%alpha(row, col))*(pr+perc)
            prd_d = 0.1_sp*(pr_d+perc_d)
            prd = 0.1_sp*(pr+perc)
            CALL GR_TRANSFER_D(5._sp, prcp, prr, prr_d, parameters%cft(&
&                        row, col), parameters_d%cft(row, col), states%&
&                        hft(row, col), states_d%hft(row, col), qr, qr_d&
&                       )
            CALL GR_TRANSFER_D(5._sp, prcp, prl, prl_d, parameters%cst(&
&                        row, col), parameters_d%cst(row, col), states%&
&                        hst(row, col), states_d%hst(row, col), ql, ql_d&
&                       )
            IF (0._sp .LT. prd + l) THEN
              qd_d = prd_d + l_d
              qd = prd + l
            ELSE
              qd = 0._sp
              qd_d = 0.0_4
            END IF
          CASE DEFAULT
            qd_d = 0.0_4
            ql_d = 0.0_4
            qr_d = 0.0_4
          END SELECT
          qt_d = qd_d + qr_d + ql_d
          qt = qd + qr + ql
!% =================================================================================================== %!
!%   Routing module case [ 0 - 1 ]
!% =================================================================================================== %!
          SELECT CASE  (setup%routing_module) 
          CASE (0) 
            IF (setup%sparse_storage) THEN
              CALL SPARSE_UPSTREAM_DISCHARGE_D(setup%dt, mesh%dx, mesh%&
&                                        nrow, mesh%ncol, mesh%nac, mesh&
&                                        %flwdir, mesh%drained_area, &
&                                        mesh%rowcol_to_ind_sparse, row&
&                                        , col, sparse_q, sparse_q_d, &
&                                        qup, qup_d)
              temp = 0.001_sp*(mesh%dx*mesh%dx)
              temp0 = REAL(mesh%drained_area(row, col) - 1)
              sparse_q_d(k) = temp*(qt_d+temp0*qup_d)/setup%dt
              sparse_q(k) = temp*((qt+temp0*qup)/setup%dt)
            ELSE
              CALL UPSTREAM_DISCHARGE_D(setup%dt, mesh%dx, mesh%nrow, &
&                                 mesh%ncol, mesh%flwdir, mesh%&
&                                 drained_area, row, col, q, q_d, qup, &
&                                 qup_d)
              temp = 0.001_sp*(mesh%dx*mesh%dx)
              temp0 = REAL(mesh%drained_area(row, col) - 1)
              q_d(row, col) = temp*(qt_d+temp0*qup_d)/setup%dt
              q(row, col) = temp*((qt+temp0*qup)/setup%dt)
            END IF
          CASE (1) 
            IF (setup%sparse_storage) THEN
              CALL SPARSE_UPSTREAM_DISCHARGE_D(setup%dt, mesh%dx, mesh%&
&                                        nrow, mesh%ncol, mesh%nac, mesh&
&                                        %flwdir, mesh%drained_area, &
&                                        mesh%rowcol_to_ind_sparse, row&
&                                        , col, sparse_q, sparse_q_d, &
&                                        qup, qup_d)
              CALL LINEAR_ROUTING_D(setup%dt, qup, qup_d, parameters%lr(&
&                             row, col), parameters_d%lr(row, col), &
&                             states%hlr(row, col), states_d%hlr(row, &
&                             col), qrout, qrout_d)
              temp = 0.001_sp*(mesh%dx*mesh%dx)
              temp0 = REAL(mesh%drained_area(row, col) - 1)
              sparse_q_d(k) = temp*(qt_d+temp0*qrout_d)/setup%dt
              sparse_q(k) = temp*((qt+temp0*qrout)/setup%dt)
            ELSE
              CALL UPSTREAM_DISCHARGE_D(setup%dt, mesh%dx, mesh%nrow, &
&                                 mesh%ncol, mesh%flwdir, mesh%&
&                                 drained_area, row, col, q, q_d, qup, &
&                                 qup_d)
              CALL LINEAR_ROUTING_D(setup%dt, qup, qup_d, parameters%lr(&
&                             row, col), parameters_d%lr(row, col), &
&                             states%hlr(row, col), states_d%hlr(row, &
&                             col), qrout, qrout_d)
              temp = 0.001_sp*(mesh%dx*mesh%dx)
              temp0 = REAL(mesh%drained_area(row, col) - 1)
              q_d(row, col) = temp*(qt_d+temp0*qrout_d)/setup%dt
              q(row, col) = temp*((qt+temp0*qrout)/setup%dt)
            END IF
          END SELECT
        END IF
      END IF
    END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
    DO g=1,mesh%ng
      row = mesh%gauge_pos(g, 1)
      col = mesh%gauge_pos(g, 2)
      IF (setup%sparse_storage) THEN
        k = mesh%rowcol_to_ind_sparse(row, col)
        output_d%qsim(g, t) = sparse_q_d(k)
        output%qsim(g, t) = sparse_q(k)
      ELSE
        output_d%qsim(g, t) = q_d(row, col)
        output%qsim(g, t) = q(row, col)
      END IF
    END DO
  END DO
!% [ END DO TIME ]
!% =============================================================================================================== %!
!%   Store states at final time step and reset states
!% =============================================================================================================== %!
  states_d = states_imd_d
  states = states_imd
!% =================================================================================================================== %!
!%   Compute J
!% =================================================================================================================== %!
  CALL COMPUTE_COST_D(setup, mesh, input_data, parameters, parameters_d&
&               , parameters_bgd, states, states_d, states_bgd, output, &
&               output_d, cost, cost_d)
END SUBROUTINE BASE_FORWARD_D

!  Differentiation of base_forward in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: cost
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.lr)
!                *(states.hi) *(states.hp) *(states.hft) *(states.hst)
!                *(states.hlr)
!   RW status of diff variables: parameters.ci:(loc) *(parameters.ci):out
!                parameters.cp:(loc) *(parameters.cp):out parameters.beta:(loc)
!                *(parameters.beta):out parameters.cft:(loc) *(parameters.cft):out
!                parameters.cst:(loc) *(parameters.cst):out parameters.alpha:(loc)
!                *(parameters.alpha):out parameters.exc:(loc) *(parameters.exc):out
!                parameters.lr:(loc) *(parameters.lr):out *(output.qsim):(loc)
!                states.hi:(loc) *(states.hi):out states.hp:(loc)
!                *(states.hp):out states.hft:(loc) *(states.hft):out
!                states.hst:(loc) *(states.hst):out states.hlr:(loc)
!                *(states.hlr):out cost:in-killed
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.lr:in
!                output.qsim:in states.hi:in-out states.hp:in-out
!                states.hft:in-out states.hst:in-out states.hlr:in-out
SUBROUTINE BASE_FORWARD_B(setup, mesh, input_data, parameters, &
& parameters_b, parameters_bgd, states, states_b, states_bgd, output, &
& output_b, cost, cost_b)
!% only: sp
  USE MD_COMMON
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: Hyper_ParametersDT
  USE MWD_PARAMETERS_DIFF
!% only: Hyper_StatesDT
  USE MWD_STATES_DIFF
!% only: OutputDT
  USE MWD_OUTPUT_DIFF
!% only: gr_interception, gr_production, gr_exchange, &
  USE MD_GR_OPERATOR_DIFF
!% & gr_transfer
!% only: upstream_discharge, sparse_upstream_discharge, linear_routing
  USE MD_ROUTING_OPERATOR_DIFF
!% only: compute_cost, hyper_compuste_cost
  USE MWD_COST_DIFF
  IMPLICIT NONE
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
  TYPE(SETUPDT), INTENT(IN) :: setup
  TYPE(MESHDT), INTENT(IN) :: mesh
  TYPE(INPUT_DATADT), INTENT(IN) :: input_data
  TYPE(PARAMETERSDT), INTENT(IN) :: parameters, parameters_bgd
  TYPE(PARAMETERSDT) :: parameters_b
  TYPE(STATESDT), INTENT(INOUT) :: states, states_bgd
  TYPE(STATESDT), INTENT(INOUT) :: states_b
  TYPE(OUTPUTDT), INTENT(INOUT) :: output
  TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_b
  REAL(sp), INTENT(INOUT) :: cost
  REAL(sp), INTENT(INOUT) :: cost_b
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
  TYPE(STATESDT) :: states_imd
  TYPE(STATESDT) :: states_imd_b
  REAL(sp), DIMENSION(:, :), ALLOCATABLE :: q
  REAL(sp), DIMENSION(:, :), ALLOCATABLE :: q_b
  REAL(sp), DIMENSION(:), ALLOCATABLE :: sparse_q
  REAL(sp), DIMENSION(:), ALLOCATABLE :: sparse_q_b
  REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prl, prd, qd, qr&
& , ql, qt, qup, qrout
  REAL(sp) :: ei_b, pn_b, en_b, pr_b, perc_b, l_b, prr_b, prl_b, prd_b, &
& qd_b, qr_b, ql_b, qt_b, qup_b, qrout_b
  INTEGER :: t, i, row, col, k, g
  INTRINSIC MIN
  INTRINSIC MAX
  INTRINSIC REAL
  REAL(sp) :: temp_b
  REAL*4 :: temp_b0
  INTEGER :: branch
  states_imd_b = states_b
  states_imd = states
  IF (setup%sparse_storage) THEN
    ALLOCATE(sparse_q_b(mesh%nac))
    sparse_q_b = 0.0_4
    ALLOCATE(sparse_q(mesh%nac))
    CALL PUSHCONTROL1B(1)
  ELSE
    ALLOCATE(q_b(mesh%nrow, mesh%ncol))
    q_b = 0.0_4
    ALLOCATE(q(mesh%nrow, mesh%ncol))
    CALL PUSHCONTROL1B(0)
  END IF
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
  DO t=1,setup%ntime_step
!% [ DO SPACE ]
    DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialisation for time step (t) and cell (i)
!% =============================================================================================================== %!
      ei = 0._sp
      CALL PUSHREAL4(pn)
      pn = 0._sp
      CALL PUSHREAL4(pr)
      pr = 0._sp
      CALL PUSHREAL4(perc)
      perc = 0._sp
      l = 0._sp
      qd = 0._sp
      qr = 0._sp
      ql = 0._sp
!% [ END IF PATH ]
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of drained area 
!% =========================================================================================================== %!
      IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
!% [ IF PATH ]
        CALL PUSHINTEGER4(row)
        row = mesh%path(1, i)
        CALL PUSHINTEGER4(col)
        col = mesh%path(2, i)
        IF (setup%sparse_storage) THEN
          CALL PUSHINTEGER4(k)
          k = mesh%rowcol_to_ind_sparse(row, col)
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!% [ END IF ACTIVE CELL ]
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
        IF (mesh%active_cell(row, col) .EQ. 1 .AND. mesh%&
&           local_active_cell(row, col) .EQ. 1) THEN
!% [ IF ACTIVE CELL ]
          IF (setup%sparse_storage) THEN
            CALL PUSHREAL4(prcp)
            prcp = input_data%sparse_prcp(k, t)
            CALL PUSHREAL4(pet)
            pet = input_data%sparse_pet(k, t)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHREAL4(prcp)
            prcp = input_data%prcp(row, col, t)
            CALL PUSHREAL4(pet)
            pet = input_data%pet(row, col, t)
            CALL PUSHCONTROL1B(1)
          END IF
!% [ END IF PRCP GAP ]
          IF (prcp .GE. 0 .AND. pet .GE. 0) THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module case [ 0 - 1 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%interception_module) 
            CASE (0) 
              IF (pet .GT. prcp) THEN
                ei = prcp
              ELSE
                ei = pet
              END IF
              IF (0._sp .LT. prcp - ei) THEN
                CALL PUSHCONTROL2B(2)
                pn = prcp - ei
              ELSE
                CALL PUSHCONTROL2B(2)
                pn = 0._sp
              END IF
            CASE (1) 
              CALL PUSHREAL4(states%hi(row, col))
              CALL GR_INTERCEPTION(prcp, pet, parameters%ci(row, col), &
&                            states%hi(row, col), pn, ei)
              CALL PUSHCONTROL2B(1)
            CASE DEFAULT
              CALL PUSHCONTROL2B(0)
            END SELECT
            CALL PUSHREAL4(en)
            en = pet - ei
!% =============================================================================================== %!
!%   Production module case [ 0 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%production_module) 
            CASE (0) 
              CALL PUSHREAL4(states%hp(row, col))
              CALL GR_PRODUCTION(pn, en, parameters%cp(row, col), &
&                          parameters%beta(row, col), states%hp(row, col&
&                          ), pr, perc)
              CALL PUSHCONTROL1B(1)
            CASE DEFAULT
              CALL PUSHCONTROL1B(0)
            END SELECT
!% =============================================================================================== %!
!%   Exchange module case [ 0 - 1 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%exchange_module) 
            CASE (0) 
              CALL PUSHCONTROL2B(0)
              l = 0._sp
            CASE (1) 
              CALL GR_EXCHANGE(parameters%exc(row, col), states%hft(row&
&                        , col), l)
              CALL PUSHCONTROL2B(1)
            CASE DEFAULT
              CALL PUSHCONTROL2B(0)
            END SELECT
          ELSE
            CALL PUSHCONTROL2B(2)
          END IF
!% =================================================================================================== %!
!%   Transfer module case [ 0 ]
!% =================================================================================================== %!
          SELECT CASE  (setup%transfer_module) 
          CASE (0) 
            CALL PUSHREAL4(prr)
            prr = parameters%alpha(row, col)*(pr+perc) + l
            prd = (1._sp-parameters%alpha(row, col))*(pr+perc)
            CALL PUSHREAL4(states%hft(row, col))
            CALL GR_TRANSFER(5._sp, prcp, prr, parameters%cft(row, col)&
&                      , states%hft(row, col), qr)
            IF (0._sp .LT. prd + l) THEN
              qd = prd + l
              CALL PUSHCONTROL3B(2)
            ELSE
              qd = 0._sp
              CALL PUSHCONTROL3B(1)
            END IF
          CASE (1) 
            CALL PUSHREAL4(prr)
            prr = 0.9_sp*parameters%alpha(row, col)*(pr+perc) + l
            prl = 0.9_sp*(1._sp-parameters%alpha(row, col))*(pr+perc)
            prd = 0.1_sp*(pr+perc)
            CALL PUSHREAL4(states%hft(row, col))
            CALL GR_TRANSFER(5._sp, prcp, prr, parameters%cft(row, col)&
&                      , states%hft(row, col), qr)
            CALL PUSHREAL4(states%hst(row, col))
            CALL GR_TRANSFER(5._sp, prcp, prl, parameters%cst(row, col)&
&                      , states%hst(row, col), ql)
            IF (0._sp .LT. prd + l) THEN
              qd = prd + l
              CALL PUSHCONTROL3B(4)
            ELSE
              qd = 0._sp
              CALL PUSHCONTROL3B(3)
            END IF
          CASE DEFAULT
            CALL PUSHCONTROL3B(0)
          END SELECT
          qt = qd + qr + ql
!% =================================================================================================== %!
!%   Routing module case [ 0 - 1 ]
!% =================================================================================================== %!
          SELECT CASE  (setup%routing_module) 
          CASE (0) 
            IF (setup%sparse_storage) THEN
              CALL PUSHREAL4(qup)
              CALL SPARSE_UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%&
&                                      nrow, mesh%ncol, mesh%nac, mesh%&
&                                      flwdir, mesh%drained_area, mesh%&
&                                      rowcol_to_ind_sparse, row, col, &
&                                      sparse_q, qup)
              sparse_q(k) = (qt+qup*REAL(mesh%drained_area(row, col)-1))&
&               *mesh%dx*mesh%dx*0.001_sp/setup%dt
              CALL PUSHCONTROL3B(5)
            ELSE
              CALL PUSHREAL4(qup)
              CALL UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%nrow, mesh&
&                               %ncol, mesh%flwdir, mesh%drained_area, &
&                               row, col, q, qup)
              q(row, col) = (qt+qup*REAL(mesh%drained_area(row, col)-1))&
&               *mesh%dx*mesh%dx*0.001_sp/setup%dt
              CALL PUSHCONTROL3B(4)
            END IF
          CASE (1) 
            IF (setup%sparse_storage) THEN
              CALL PUSHREAL4(qup)
              CALL SPARSE_UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%&
&                                      nrow, mesh%ncol, mesh%nac, mesh%&
&                                      flwdir, mesh%drained_area, mesh%&
&                                      rowcol_to_ind_sparse, row, col, &
&                                      sparse_q, qup)
              CALL PUSHREAL4(states%hlr(row, col))
              CALL LINEAR_ROUTING(setup%dt, qup, parameters%lr(row, col)&
&                           , states%hlr(row, col), qrout)
              sparse_q(k) = (qt+qrout*REAL(mesh%drained_area(row, col)-1&
&               ))*mesh%dx*mesh%dx*0.001_sp/setup%dt
              CALL PUSHCONTROL3B(3)
            ELSE
              CALL PUSHREAL4(qup)
              CALL UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%nrow, mesh&
&                               %ncol, mesh%flwdir, mesh%drained_area, &
&                               row, col, q, qup)
              CALL PUSHREAL4(states%hlr(row, col))
              CALL LINEAR_ROUTING(setup%dt, qup, parameters%lr(row, col)&
&                           , states%hlr(row, col), qrout)
              q(row, col) = (qt+qrout*REAL(mesh%drained_area(row, col)-1&
&               ))*mesh%dx*mesh%dx*0.001_sp/setup%dt
              CALL PUSHCONTROL3B(2)
            END IF
          CASE DEFAULT
            CALL PUSHCONTROL3B(6)
          END SELECT
        ELSE
          CALL PUSHCONTROL3B(1)
        END IF
      ELSE
        CALL PUSHCONTROL3B(0)
      END IF
    END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
    DO g=1,mesh%ng
      CALL PUSHINTEGER4(row)
      row = mesh%gauge_pos(g, 1)
      CALL PUSHINTEGER4(col)
      col = mesh%gauge_pos(g, 2)
      IF (setup%sparse_storage) THEN
        CALL PUSHINTEGER4(k)
        k = mesh%rowcol_to_ind_sparse(row, col)
        output%qsim(g, t) = sparse_q(k)
        CALL PUSHCONTROL1B(1)
      ELSE
        output%qsim(g, t) = q(row, col)
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
  END DO
!% [ END DO TIME ]
!% =============================================================================================================== %!
!%   Store states at final time step and reset states
!% =============================================================================================================== %!
  states_b = states_imd_b
  states = states_imd
!% =================================================================================================================== %!
!%   Compute J
!% =================================================================================================================== %!
  CALL COMPUTE_COST(setup, mesh, input_data, parameters, parameters_bgd&
&             , states, states_bgd, output, cost)
  CALL SET_PARAMETERS(parameters_b, 0.0_4)
  CALL SET_STATES(states_b, 0.0_4)
  CALL COMPUTE_COST_B(setup, mesh, input_data, parameters, parameters_b&
&               , parameters_bgd, states, states_b, states_bgd, output, &
&               output_b, cost, cost_b)
  DO t=setup%ntime_step,1,-1
    DO g=mesh%ng,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        row = mesh%gauge_pos(g, 1)
        col = mesh%gauge_pos(g, 2)
        q_b(row, col) = q_b(row, col) + output_b%qsim(g, t)
        output_b%qsim(g, t) = 0.0_4
      ELSE
        sparse_q_b(k) = sparse_q_b(k) + output_b%qsim(g, t)
        output_b%qsim(g, t) = 0.0_4
        CALL POPINTEGER4(k)
      END IF
      CALL POPINTEGER4(col)
      CALL POPINTEGER4(row)
    END DO
    DO i=mesh%nrow*mesh%ncol,1,-1
      CALL POPCONTROL3B(branch)
      IF (branch .LT. 3) THEN
        IF (branch .EQ. 0) THEN
          GOTO 130
        ELSE IF (branch .EQ. 1) THEN
          GOTO 120
        ELSE
          row = mesh%path(1, i)
          col = mesh%path(2, i)
          temp_b0 = mesh%dx**2*0.001_sp*q_b(row, col)/setup%dt
          q_b(row, col) = 0.0_4
          qt_b = temp_b0
          qrout_b = REAL(mesh%drained_area(row, col)-1)*temp_b0
          CALL POPREAL4(states%hlr(row, col))
          CALL LINEAR_ROUTING_B(setup%dt, qup, qup_b, parameters%lr(row&
&                         , col), parameters_b%lr(row, col), states%hlr(&
&                         row, col), states_b%hlr(row, col), qrout, &
&                         qrout_b)
          CALL POPREAL4(qup)
          CALL UPSTREAM_DISCHARGE_B(setup%dt, mesh%dx, mesh%nrow, mesh%&
&                             ncol, mesh%flwdir, mesh%drained_area, row&
&                             , col, q, q_b, qup, qup_b)
        END IF
      ELSE IF (branch .LT. 5) THEN
        IF (branch .EQ. 3) THEN
          row = mesh%path(1, i)
          col = mesh%path(2, i)
          temp_b0 = mesh%dx**2*0.001_sp*sparse_q_b(k)/setup%dt
          sparse_q_b(k) = 0.0_4
          qt_b = temp_b0
          qrout_b = REAL(mesh%drained_area(row, col)-1)*temp_b0
          CALL POPREAL4(states%hlr(row, col))
          CALL LINEAR_ROUTING_B(setup%dt, qup, qup_b, parameters%lr(row&
&                         , col), parameters_b%lr(row, col), states%hlr(&
&                         row, col), states_b%hlr(row, col), qrout, &
&                         qrout_b)
          CALL POPREAL4(qup)
          CALL SPARSE_UPSTREAM_DISCHARGE_B(setup%dt, mesh%dx, mesh%nrow&
&                                    , mesh%ncol, mesh%nac, mesh%flwdir&
&                                    , mesh%drained_area, mesh%&
&                                    rowcol_to_ind_sparse, row, col, &
&                                    sparse_q, sparse_q_b, qup, qup_b)
        ELSE
          row = mesh%path(1, i)
          col = mesh%path(2, i)
          temp_b0 = mesh%dx**2*0.001_sp*q_b(row, col)/setup%dt
          q_b(row, col) = 0.0_4
          qt_b = temp_b0
          qup_b = REAL(mesh%drained_area(row, col)-1)*temp_b0
          CALL POPREAL4(qup)
          CALL UPSTREAM_DISCHARGE_B(setup%dt, mesh%dx, mesh%nrow, mesh%&
&                             ncol, mesh%flwdir, mesh%drained_area, row&
&                             , col, q, q_b, qup, qup_b)
        END IF
      ELSE IF (branch .EQ. 5) THEN
        row = mesh%path(1, i)
        col = mesh%path(2, i)
        temp_b0 = mesh%dx**2*0.001_sp*sparse_q_b(k)/setup%dt
        sparse_q_b(k) = 0.0_4
        qt_b = temp_b0
        qup_b = REAL(mesh%drained_area(row, col)-1)*temp_b0
        CALL POPREAL4(qup)
        CALL SPARSE_UPSTREAM_DISCHARGE_B(setup%dt, mesh%dx, mesh%nrow, &
&                                  mesh%ncol, mesh%nac, mesh%flwdir, &
&                                  mesh%drained_area, mesh%&
&                                  rowcol_to_ind_sparse, row, col, &
&                                  sparse_q, sparse_q_b, qup, qup_b)
      ELSE
        qt_b = 0.0_4
      END IF
      qd_b = qt_b
      qr_b = qt_b
      ql_b = qt_b
      CALL POPCONTROL3B(branch)
      IF (branch .LT. 2) THEN
        IF (branch .EQ. 0) THEN
          l_b = 0.0_4
          perc_b = 0.0_4
          pr_b = 0.0_4
          GOTO 100
        ELSE
          l_b = 0.0_4
          prd_b = 0.0_4
        END IF
      ELSE IF (branch .EQ. 2) THEN
        prd_b = qd_b
        l_b = qd_b
      ELSE
        IF (branch .EQ. 3) THEN
          l_b = 0.0_4
          prd_b = 0.0_4
        ELSE
          prd_b = qd_b
          l_b = qd_b
        END IF
        prl = 0.9_sp*(1._sp-parameters%alpha(row, col))*(pr+perc)
        CALL POPREAL4(states%hst(row, col))
        CALL GR_TRANSFER_B(5._sp, prcp, prl, prl_b, parameters%cst(row, &
&                    col), parameters_b%cst(row, col), states%hst(row, &
&                    col), states_b%hst(row, col), ql, ql_b)
        CALL POPREAL4(states%hft(row, col))
        CALL GR_TRANSFER_B(5._sp, prcp, prr, prr_b, parameters%cft(row, &
&                    col), parameters_b%cft(row, col), states%hft(row, &
&                    col), states_b%hft(row, col), qr, qr_b)
        parameters_b%alpha(row, col) = parameters_b%alpha(row, col) + (&
&         pr+perc)*0.9_sp*prr_b - (pr+perc)*0.9_sp*prl_b
        temp_b = (1._sp-parameters%alpha(row, col))*0.9_sp*prl_b
        pr_b = 0.1_sp*prd_b + temp_b
        perc_b = 0.1_sp*prd_b + temp_b
        CALL POPREAL4(prr)
        temp_b = parameters%alpha(row, col)*0.9_sp*prr_b
        l_b = l_b + prr_b
        pr_b = pr_b + temp_b
        perc_b = perc_b + temp_b
        GOTO 100
      END IF
      CALL POPREAL4(states%hft(row, col))
      CALL GR_TRANSFER_B(5._sp, prcp, prr, prr_b, parameters%cft(row, &
&                  col), parameters_b%cft(row, col), states%hft(row, col&
&                  ), states_b%hft(row, col), qr, qr_b)
      parameters_b%alpha(row, col) = parameters_b%alpha(row, col) + (pr+&
&       perc)*prr_b - (pr+perc)*prd_b
      temp_b = (1._sp-parameters%alpha(row, col))*prd_b
      pr_b = temp_b
      perc_b = temp_b
      CALL POPREAL4(prr)
      temp_b = parameters%alpha(row, col)*prr_b
      l_b = l_b + prr_b
      pr_b = pr_b + temp_b
      perc_b = perc_b + temp_b
 100  CALL POPCONTROL2B(branch)
      IF (branch .NE. 0) THEN
        IF (branch .EQ. 1) THEN
          CALL GR_EXCHANGE_B(parameters%exc(row, col), parameters_b%exc(&
&                      row, col), states%hft(row, col), states_b%hft(row&
&                      , col), l, l_b)
        ELSE
          GOTO 110
        END IF
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        en_b = 0.0_4
        pn_b = 0.0_4
      ELSE
        CALL POPREAL4(states%hp(row, col))
        CALL GR_PRODUCTION_B(pn, pn_b, en, en_b, parameters%cp(row, col)&
&                      , parameters_b%cp(row, col), parameters%beta(row&
&                      , col), parameters_b%beta(row, col), states%hp(&
&                      row, col), states_b%hp(row, col), pr, pr_b, perc&
&                      , perc_b)
      END IF
      CALL POPREAL4(en)
      ei_b = -en_b
      CALL POPCONTROL2B(branch)
      IF (branch .NE. 0) THEN
        IF (branch .EQ. 1) THEN
          CALL POPREAL4(states%hi(row, col))
          CALL GR_INTERCEPTION_B(prcp, pet, parameters%ci(row, col), &
&                          parameters_b%ci(row, col), states%hi(row, col&
&                          ), states_b%hi(row, col), pn, pn_b, ei, ei_b)
        END IF
      END IF
 110  CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL4(pet)
        CALL POPREAL4(prcp)
      ELSE
        CALL POPREAL4(pet)
        CALL POPREAL4(prcp)
      END IF
 120  CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) CALL POPINTEGER4(k)
      CALL POPINTEGER4(col)
      CALL POPINTEGER4(row)
 130  CALL POPREAL4(perc)
      CALL POPREAL4(pr)
      CALL POPREAL4(pn)
    END DO
  END DO
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    DEALLOCATE(q)
    DEALLOCATE(q_b)
  ELSE
    DEALLOCATE(sparse_q)
    DEALLOCATE(sparse_q_b)
  END IF
END SUBROUTINE BASE_FORWARD_B

SUBROUTINE BASE_FORWARD_NODIFF(setup, mesh, input_data, parameters, &
& parameters_bgd, states, states_bgd, output, cost)
!% only: sp
  USE MD_COMMON
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: Hyper_ParametersDT
  USE MWD_PARAMETERS_DIFF
!% only: Hyper_StatesDT
  USE MWD_STATES_DIFF
!% only: OutputDT
  USE MWD_OUTPUT_DIFF
!% only: gr_interception, gr_production, gr_exchange, &
  USE MD_GR_OPERATOR_DIFF
!% & gr_transfer
!% only: upstream_discharge, sparse_upstream_discharge, linear_routing
  USE MD_ROUTING_OPERATOR_DIFF
!% only: compute_cost, hyper_compuste_cost
  USE MWD_COST_DIFF
  IMPLICIT NONE
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
  TYPE(SETUPDT), INTENT(IN) :: setup
  TYPE(MESHDT), INTENT(IN) :: mesh
  TYPE(INPUT_DATADT), INTENT(IN) :: input_data
  TYPE(PARAMETERSDT), INTENT(IN) :: parameters, parameters_bgd
  TYPE(STATESDT), INTENT(INOUT) :: states, states_bgd
  TYPE(OUTPUTDT), INTENT(INOUT) :: output
  REAL(sp), INTENT(INOUT) :: cost
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
  TYPE(STATESDT) :: states_imd
  REAL(sp), DIMENSION(:, :), ALLOCATABLE :: q
  REAL(sp), DIMENSION(:), ALLOCATABLE :: sparse_q
  REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prl, prd, qd, qr&
& , ql, qt, qup, qrout
  INTEGER :: t, i, row, col, k, g
  INTRINSIC MIN
  INTRINSIC MAX
  INTRINSIC REAL
  cost = 0._sp
  states_imd = states
  IF (setup%sparse_storage) THEN
    ALLOCATE(sparse_q(mesh%nac))
  ELSE
    ALLOCATE(q(mesh%nrow, mesh%ncol))
  END IF
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
  DO t=1,setup%ntime_step
!% [ DO SPACE ]
    DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialisation for time step (t) and cell (i)
!% =============================================================================================================== %!
      ei = 0._sp
      pn = 0._sp
      en = 0._sp
      pr = 0._sp
      perc = 0._sp
      l = 0._sp
      prr = 0._sp
      prl = 0._sp
      prd = 0._sp
      qd = 0._sp
      qr = 0._sp
      ql = 0._sp
      qup = 0._sp
      qrout = 0._sp
!% [ END IF PATH ]
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of drained area 
!% =========================================================================================================== %!
      IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
!% [ IF PATH ]
        row = mesh%path(1, i)
        col = mesh%path(2, i)
        IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, col&
&           )
!% [ END IF ACTIVE CELL ]
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
        IF (mesh%active_cell(row, col) .EQ. 1 .AND. mesh%&
&           local_active_cell(row, col) .EQ. 1) THEN
!% [ IF ACTIVE CELL ]
          IF (setup%sparse_storage) THEN
            prcp = input_data%sparse_prcp(k, t)
            pet = input_data%sparse_pet(k, t)
          ELSE
            prcp = input_data%prcp(row, col, t)
            pet = input_data%pet(row, col, t)
          END IF
!% [ END IF PRCP GAP ]
          IF (prcp .GE. 0 .AND. pet .GE. 0) THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module case [ 0 - 1 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%interception_module) 
            CASE (0) 
              IF (pet .GT. prcp) THEN
                ei = prcp
              ELSE
                ei = pet
              END IF
              IF (0._sp .LT. prcp - ei) THEN
                pn = prcp - ei
              ELSE
                pn = 0._sp
              END IF
            CASE (1) 
              CALL GR_INTERCEPTION(prcp, pet, parameters%ci(row, col), &
&                            states%hi(row, col), pn, ei)
            END SELECT
            en = pet - ei
!% =============================================================================================== %!
!%   Production module case [ 0 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%production_module) 
            CASE (0) 
              CALL GR_PRODUCTION(pn, en, parameters%cp(row, col), &
&                          parameters%beta(row, col), states%hp(row, col&
&                          ), pr, perc)
            END SELECT
!% =============================================================================================== %!
!%   Exchange module case [ 0 - 1 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%exchange_module) 
            CASE (0) 
              l = 0._sp
            CASE (1) 
              CALL GR_EXCHANGE(parameters%exc(row, col), states%hft(row&
&                        , col), l)
            END SELECT
          END IF
!% =================================================================================================== %!
!%   Transfer module case [ 0 ]
!% =================================================================================================== %!
          SELECT CASE  (setup%transfer_module) 
          CASE (0) 
            prr = parameters%alpha(row, col)*(pr+perc) + l
            prd = (1._sp-parameters%alpha(row, col))*(pr+perc)
            CALL GR_TRANSFER(5._sp, prcp, prr, parameters%cft(row, col)&
&                      , states%hft(row, col), qr)
            IF (0._sp .LT. prd + l) THEN
              qd = prd + l
            ELSE
              qd = 0._sp
            END IF
          CASE (1) 
            prr = 0.9_sp*parameters%alpha(row, col)*(pr+perc) + l
            prl = 0.9_sp*(1._sp-parameters%alpha(row, col))*(pr+perc)
            prd = 0.1_sp*(pr+perc)
            CALL GR_TRANSFER(5._sp, prcp, prr, parameters%cft(row, col)&
&                      , states%hft(row, col), qr)
            CALL GR_TRANSFER(5._sp, prcp, prl, parameters%cst(row, col)&
&                      , states%hst(row, col), ql)
            IF (0._sp .LT. prd + l) THEN
              qd = prd + l
            ELSE
              qd = 0._sp
            END IF
          END SELECT
          qt = qd + qr + ql
!% =================================================================================================== %!
!%   Routing module case [ 0 - 1 ]
!% =================================================================================================== %!
          SELECT CASE  (setup%routing_module) 
          CASE (0) 
            IF (setup%sparse_storage) THEN
              CALL SPARSE_UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%&
&                                      nrow, mesh%ncol, mesh%nac, mesh%&
&                                      flwdir, mesh%drained_area, mesh%&
&                                      rowcol_to_ind_sparse, row, col, &
&                                      sparse_q, qup)
              sparse_q(k) = (qt+qup*REAL(mesh%drained_area(row, col)-1))&
&               *mesh%dx*mesh%dx*0.001_sp/setup%dt
            ELSE
              CALL UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%nrow, mesh&
&                               %ncol, mesh%flwdir, mesh%drained_area, &
&                               row, col, q, qup)
              q(row, col) = (qt+qup*REAL(mesh%drained_area(row, col)-1))&
&               *mesh%dx*mesh%dx*0.001_sp/setup%dt
            END IF
          CASE (1) 
            IF (setup%sparse_storage) THEN
              CALL SPARSE_UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%&
&                                      nrow, mesh%ncol, mesh%nac, mesh%&
&                                      flwdir, mesh%drained_area, mesh%&
&                                      rowcol_to_ind_sparse, row, col, &
&                                      sparse_q, qup)
              CALL LINEAR_ROUTING(setup%dt, qup, parameters%lr(row, col)&
&                           , states%hlr(row, col), qrout)
              sparse_q(k) = (qt+qrout*REAL(mesh%drained_area(row, col)-1&
&               ))*mesh%dx*mesh%dx*0.001_sp/setup%dt
            ELSE
              CALL UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%nrow, mesh&
&                               %ncol, mesh%flwdir, mesh%drained_area, &
&                               row, col, q, qup)
              CALL LINEAR_ROUTING(setup%dt, qup, parameters%lr(row, col)&
&                           , states%hlr(row, col), qrout)
              q(row, col) = (qt+qrout*REAL(mesh%drained_area(row, col)-1&
&               ))*mesh%dx*mesh%dx*0.001_sp/setup%dt
            END IF
          END SELECT
        END IF
      END IF
    END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
    DO g=1,mesh%ng
      row = mesh%gauge_pos(g, 1)
      col = mesh%gauge_pos(g, 2)
      IF (setup%sparse_storage) THEN
        k = mesh%rowcol_to_ind_sparse(row, col)
        output%qsim(g, t) = sparse_q(k)
      ELSE
        output%qsim(g, t) = q(row, col)
      END IF
    END DO
!% =============================================================================================================== %!
!%   Store simulated discharge on domain (optional)
!% =============================================================================================================== %!
    IF (setup%save_qsim_domain) THEN
      IF (setup%sparse_storage) THEN
        output%sparse_qsim_domain(:, t) = sparse_q
      ELSE
        output%qsim_domain(:, :, t) = q
      END IF
    END IF
!% =============================================================================================================== %!
!%   Store simulated net rainfall on domain (optional)
!%   The net rainfall over a surface is a fictitious quantity that corresponds to 
!%   the part of the rainfall water depth that actually causes runoff. 
!% =============================================================================================================== %!
    IF (setup%save_net_prcp_domain) THEN
      IF (setup%sparse_storage) THEN
        output%sparse_net_prcp_domain(:, t) = qt
      ELSE
        output%net_prcp_domain(:, :, t) = qt
      END IF
    END IF
  END DO
!% [ END DO TIME ]
!% =============================================================================================================== %!
!%   Store states at final time step and reset states
!% =============================================================================================================== %!
  output%fstates = states
  states = states_imd
!% =================================================================================================================== %!
!%   Compute J
!% =================================================================================================================== %!
  CALL COMPUTE_COST(setup, mesh, input_data, parameters, parameters_bgd&
&             , states, states_bgd, output, cost)
END SUBROUTINE BASE_FORWARD_NODIFF

!  Differentiation of base_hyper_forward in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: cost
!   with respect to varying inputs: *(hyper_states.hi) *(hyper_states.hp)
!                *(hyper_states.hft) *(hyper_states.hst) *(hyper_states.hlr)
!                *(hyper_parameters.ci) *(hyper_parameters.cp)
!                *(hyper_parameters.beta) *(hyper_parameters.cft)
!                *(hyper_parameters.cst) *(hyper_parameters.alpha)
!                *(hyper_parameters.exc) *(hyper_parameters.lr)
!   RW status of diff variables: hyper_states.hi:(loc) *(hyper_states.hi):in
!                hyper_states.hp:(loc) *(hyper_states.hp):in hyper_states.hft:(loc)
!                *(hyper_states.hft):in hyper_states.hst:(loc)
!                *(hyper_states.hst):in hyper_states.hlr:(loc)
!                *(hyper_states.hlr):in hyper_parameters.ci:(loc)
!                *(hyper_parameters.ci):in hyper_parameters.cp:(loc)
!                *(hyper_parameters.cp):in hyper_parameters.beta:(loc)
!                *(hyper_parameters.beta):in hyper_parameters.cft:(loc)
!                *(hyper_parameters.cft):in hyper_parameters.cst:(loc)
!                *(hyper_parameters.cst):in hyper_parameters.alpha:(loc)
!                *(hyper_parameters.alpha):in hyper_parameters.exc:(loc)
!                *(hyper_parameters.exc):in hyper_parameters.lr:(loc)
!                *(hyper_parameters.lr):in *(output.qsim):(loc)
!                cost:out
!   Plus diff mem management of: hyper_states.hi:in hyper_states.hp:in
!                hyper_states.hft:in hyper_states.hst:in hyper_states.hlr:in
!                hyper_parameters.ci:in hyper_parameters.cp:in
!                hyper_parameters.beta:in hyper_parameters.cft:in
!                hyper_parameters.cst:in hyper_parameters.alpha:in
!                hyper_parameters.exc:in hyper_parameters.lr:in
!                output.qsim:in
!% Subroutine is a copy of forward
!% Find a way to avoid a full copy
!% WARNING: Differentiated module
SUBROUTINE BASE_HYPER_FORWARD_D(setup, mesh, input_data, &
& hyper_parameters, hyper_parameters_d, hyper_parameters_bgd, &
& hyper_states, hyper_states_d, hyper_states_bgd, output, output_d, cost&
& , cost_d)
!% only: sp
  USE MD_COMMON
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: Hyper_ParametersDT, ParametersDT_initialise, hyper_parameters_to_parameters
  USE MWD_PARAMETERS_DIFF
!% only: Hyper_StatesDT, StatesDT_initialise, hyper_states_to_states
  USE MWD_STATES_DIFF
!% only: OutputDT
  USE MWD_OUTPUT_DIFF
!% only: gr_interception, gr_production, gr_exchange, &
  USE MD_GR_OPERATOR_DIFF
!% & gr_transfer
!% only: upstream_discharge, sparse_upstream_discharge, linear_routing
  USE MD_ROUTING_OPERATOR_DIFF
!% only: compute_cost
  USE MWD_COST_DIFF
  IMPLICIT NONE
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
  TYPE(SETUPDT), INTENT(IN) :: setup
  TYPE(MESHDT), INTENT(IN) :: mesh
  TYPE(INPUT_DATADT), INTENT(INOUT) :: input_data
  TYPE(HYPER_PARAMETERSDT), INTENT(IN) :: hyper_parameters, &
& hyper_parameters_bgd
  TYPE(HYPER_PARAMETERSDT), INTENT(IN) :: hyper_parameters_d
  TYPE(HYPER_STATESDT), INTENT(INOUT) :: hyper_states, hyper_states_bgd
  TYPE(HYPER_STATESDT), INTENT(INOUT) :: hyper_states_d
  TYPE(OUTPUTDT), INTENT(INOUT) :: output
  TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_d
  REAL(sp), INTENT(INOUT) :: cost
  REAL(sp), INTENT(INOUT) :: cost_d
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
  TYPE(PARAMETERSDT) :: parameters
  TYPE(PARAMETERSDT) :: parameters_d
  TYPE(STATESDT) :: states
  TYPE(STATESDT) :: states_d
  REAL(sp), DIMENSION(:, :), ALLOCATABLE :: q
  REAL(sp), DIMENSION(:, :), ALLOCATABLE :: q_d
  REAL(sp), DIMENSION(:), ALLOCATABLE :: sparse_q
  REAL(sp), DIMENSION(:), ALLOCATABLE :: sparse_q_d
  REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prl, prd, qd, qr&
& , ql, qt, qup, qrout
  REAL(sp) :: ei_d, pn_d, en_d, pr_d, perc_d, l_d, prr_d, prl_d, prd_d, &
& qd_d, qr_d, ql_d, qt_d, qup_d, qrout_d
  INTEGER :: t, i, row, col, k, g
  INTRINSIC MIN
  INTRINSIC MAX
  INTRINSIC REAL
  REAL(sp) :: temp
  REAL :: temp0
  CALL PARAMETERSDT_INITIALISE_D(parameters, parameters_d, mesh)
  CALL STATESDT_INITIALISE_D(states, states_d, mesh)
  CALL HYPER_PARAMETERS_TO_PARAMETERS_D(hyper_parameters, &
&                                 hyper_parameters_d, parameters, &
&                                 parameters_d, setup, input_data)
  CALL HYPER_STATES_TO_STATES_D(hyper_states, hyper_states_d, states, &
&                         states_d, setup, input_data)
  IF (setup%sparse_storage) THEN
    ALLOCATE(sparse_q_d(mesh%nac))
    ALLOCATE(sparse_q(mesh%nac))
    output_d%qsim = 0.0_4
  ELSE
    ALLOCATE(q_d(mesh%nrow, mesh%ncol))
    ALLOCATE(q(mesh%nrow, mesh%ncol))
    output_d%qsim = 0.0_4
  END IF
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
  DO t=1,setup%ntime_step
!% [ DO SPACE ]
    DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialisation for time step (t) and cell (i)
!% =============================================================================================================== %!
      ei = 0._sp
      pn = 0._sp
      pr = 0._sp
      perc = 0._sp
      l = 0._sp
      qd = 0._sp
      qr = 0._sp
      ql = 0._sp
!% [ END IF PATH ]
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of drained area 
!% =========================================================================================================== %!
      IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
!% [ IF PATH ]
        row = mesh%path(1, i)
        col = mesh%path(2, i)
        IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, col&
&           )
!% [ END IF ACTIVE CELL ]
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
        IF (mesh%active_cell(row, col) .EQ. 1 .AND. mesh%&
&           local_active_cell(row, col) .EQ. 1) THEN
!% [ IF ACTIVE CELL ]
          IF (setup%sparse_storage) THEN
            prcp = input_data%sparse_prcp(k, t)
            pet = input_data%sparse_pet(k, t)
          ELSE
            prcp = input_data%prcp(row, col, t)
            pet = input_data%pet(row, col, t)
          END IF
!% [ END IF PRCP GAP ]
          IF (prcp .GE. 0 .AND. pet .GE. 0) THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module case [ 0 - 1 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%interception_module) 
            CASE (0) 
              IF (pet .GT. prcp) THEN
                ei = prcp
              ELSE
                ei = pet
              END IF
              IF (0._sp .LT. prcp - ei) THEN
                pn = prcp - ei
                ei_d = 0.0_4
                pn_d = 0.0_4
              ELSE
                pn = 0._sp
                ei_d = 0.0_4
                pn_d = 0.0_4
              END IF
            CASE (1) 
              CALL GR_INTERCEPTION_D(prcp, pet, parameters%ci(row, col)&
&                              , parameters_d%ci(row, col), states%hi(&
&                              row, col), states_d%hi(row, col), pn, &
&                              pn_d, ei, ei_d)
            CASE DEFAULT
              ei_d = 0.0_4
              pn_d = 0.0_4
            END SELECT
            en_d = -ei_d
            en = pet - ei
!% =============================================================================================== %!
!%   Production module case [ 0 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%production_module) 
            CASE (0) 
              CALL GR_PRODUCTION_D(pn, pn_d, en, en_d, parameters%cp(row&
&                            , col), parameters_d%cp(row, col), &
&                            parameters%beta(row, col), parameters_d%&
&                            beta(row, col), states%hp(row, col), &
&                            states_d%hp(row, col), pr, pr_d, perc, &
&                            perc_d)
            CASE DEFAULT
              perc_d = 0.0_4
              pr_d = 0.0_4
            END SELECT
!% =============================================================================================== %!
!%   Exchange module case [ 0 - 1 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%exchange_module) 
            CASE (0) 
              l = 0._sp
              l_d = 0.0_4
            CASE (1) 
              CALL GR_EXCHANGE_D(parameters%exc(row, col), parameters_d%&
&                          exc(row, col), states%hft(row, col), states_d&
&                          %hft(row, col), l, l_d)
            CASE DEFAULT
              l_d = 0.0_4
            END SELECT
          ELSE
            l_d = 0.0_4
            perc_d = 0.0_4
            pr_d = 0.0_4
          END IF
!% =================================================================================================== %!
!%   Transfer module case [ 0 ]
!% =================================================================================================== %!
          SELECT CASE  (setup%transfer_module) 
          CASE (0) 
            prr_d = (pr+perc)*parameters_d%alpha(row, col) + parameters%&
&             alpha(row, col)*(pr_d+perc_d) + l_d
            prr = parameters%alpha(row, col)*(pr+perc) + l
            prd_d = (1._sp-parameters%alpha(row, col))*(pr_d+perc_d) - (&
&             pr+perc)*parameters_d%alpha(row, col)
            prd = (1._sp-parameters%alpha(row, col))*(pr+perc)
            CALL GR_TRANSFER_D(5._sp, prcp, prr, prr_d, parameters%cft(&
&                        row, col), parameters_d%cft(row, col), states%&
&                        hft(row, col), states_d%hft(row, col), qr, qr_d&
&                       )
            IF (0._sp .LT. prd + l) THEN
              qd_d = prd_d + l_d
              qd = prd + l
              ql_d = 0.0_4
            ELSE
              qd = 0._sp
              qd_d = 0.0_4
              ql_d = 0.0_4
            END IF
          CASE (1) 
            prr_d = 0.9_sp*((pr+perc)*parameters_d%alpha(row, col)+&
&             parameters%alpha(row, col)*(pr_d+perc_d)) + l_d
            prr = 0.9_sp*parameters%alpha(row, col)*(pr+perc) + l
            prl_d = 0.9_sp*((1._sp-parameters%alpha(row, col))*(pr_d+&
&             perc_d)-(pr+perc)*parameters_d%alpha(row, col))
            prl = 0.9_sp*(1._sp-parameters%alpha(row, col))*(pr+perc)
            prd_d = 0.1_sp*(pr_d+perc_d)
            prd = 0.1_sp*(pr+perc)
            CALL GR_TRANSFER_D(5._sp, prcp, prr, prr_d, parameters%cft(&
&                        row, col), parameters_d%cft(row, col), states%&
&                        hft(row, col), states_d%hft(row, col), qr, qr_d&
&                       )
            CALL GR_TRANSFER_D(5._sp, prcp, prl, prl_d, parameters%cst(&
&                        row, col), parameters_d%cst(row, col), states%&
&                        hst(row, col), states_d%hst(row, col), ql, ql_d&
&                       )
            IF (0._sp .LT. prd + l) THEN
              qd_d = prd_d + l_d
              qd = prd + l
            ELSE
              qd = 0._sp
              qd_d = 0.0_4
            END IF
          CASE DEFAULT
            qd_d = 0.0_4
            ql_d = 0.0_4
            qr_d = 0.0_4
          END SELECT
          qt_d = qd_d + qr_d + ql_d
          qt = qd + qr + ql
!% =================================================================================================== %!
!%   Routing module case [ 0 - 1 ]
!% =================================================================================================== %!
          SELECT CASE  (setup%routing_module) 
          CASE (0) 
            IF (setup%sparse_storage) THEN
              CALL SPARSE_UPSTREAM_DISCHARGE_D(setup%dt, mesh%dx, mesh%&
&                                        nrow, mesh%ncol, mesh%nac, mesh&
&                                        %flwdir, mesh%drained_area, &
&                                        mesh%rowcol_to_ind_sparse, row&
&                                        , col, sparse_q, sparse_q_d, &
&                                        qup, qup_d)
              temp = 0.001_sp*(mesh%dx*mesh%dx)
              temp0 = REAL(mesh%drained_area(row, col) - 1)
              sparse_q_d(k) = temp*(qt_d+temp0*qup_d)/setup%dt
              sparse_q(k) = temp*((qt+temp0*qup)/setup%dt)
            ELSE
              CALL UPSTREAM_DISCHARGE_D(setup%dt, mesh%dx, mesh%nrow, &
&                                 mesh%ncol, mesh%flwdir, mesh%&
&                                 drained_area, row, col, q, q_d, qup, &
&                                 qup_d)
              temp = 0.001_sp*(mesh%dx*mesh%dx)
              temp0 = REAL(mesh%drained_area(row, col) - 1)
              q_d(row, col) = temp*(qt_d+temp0*qup_d)/setup%dt
              q(row, col) = temp*((qt+temp0*qup)/setup%dt)
            END IF
          CASE (1) 
            IF (setup%sparse_storage) THEN
              CALL SPARSE_UPSTREAM_DISCHARGE_D(setup%dt, mesh%dx, mesh%&
&                                        nrow, mesh%ncol, mesh%nac, mesh&
&                                        %flwdir, mesh%drained_area, &
&                                        mesh%rowcol_to_ind_sparse, row&
&                                        , col, sparse_q, sparse_q_d, &
&                                        qup, qup_d)
              CALL LINEAR_ROUTING_D(setup%dt, qup, qup_d, parameters%lr(&
&                             row, col), parameters_d%lr(row, col), &
&                             states%hlr(row, col), states_d%hlr(row, &
&                             col), qrout, qrout_d)
              temp = 0.001_sp*(mesh%dx*mesh%dx)
              temp0 = REAL(mesh%drained_area(row, col) - 1)
              sparse_q_d(k) = temp*(qt_d+temp0*qrout_d)/setup%dt
              sparse_q(k) = temp*((qt+temp0*qrout)/setup%dt)
            ELSE
              CALL UPSTREAM_DISCHARGE_D(setup%dt, mesh%dx, mesh%nrow, &
&                                 mesh%ncol, mesh%flwdir, mesh%&
&                                 drained_area, row, col, q, q_d, qup, &
&                                 qup_d)
              CALL LINEAR_ROUTING_D(setup%dt, qup, qup_d, parameters%lr(&
&                             row, col), parameters_d%lr(row, col), &
&                             states%hlr(row, col), states_d%hlr(row, &
&                             col), qrout, qrout_d)
              temp = 0.001_sp*(mesh%dx*mesh%dx)
              temp0 = REAL(mesh%drained_area(row, col) - 1)
              q_d(row, col) = temp*(qt_d+temp0*qrout_d)/setup%dt
              q(row, col) = temp*((qt+temp0*qrout)/setup%dt)
            END IF
          END SELECT
        END IF
      END IF
    END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
    DO g=1,mesh%ng
      row = mesh%gauge_pos(g, 1)
      col = mesh%gauge_pos(g, 2)
      IF (setup%sparse_storage) THEN
        k = mesh%rowcol_to_ind_sparse(row, col)
        output_d%qsim(g, t) = sparse_q_d(k)
        output%qsim(g, t) = sparse_q(k)
      ELSE
        output_d%qsim(g, t) = q_d(row, col)
        output%qsim(g, t) = q(row, col)
      END IF
    END DO
  END DO
!% [ END DO TIME ]
!% =============================================================================================================== %!
!%   Store states at final time step
!% =============================================================================================================== %!
!% =================================================================================================================== %!
!%   Compute J
!% =================================================================================================================== %!
  CALL HYPER_COMPUTE_COST_D(setup, mesh, input_data, hyper_parameters, &
&                     hyper_parameters_bgd, hyper_states, &
&                     hyper_states_bgd, output, output_d, cost, cost_d)
END SUBROUTINE BASE_HYPER_FORWARD_D

!  Differentiation of base_hyper_forward in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: cost
!   with respect to varying inputs: *(hyper_states.hi) *(hyper_states.hp)
!                *(hyper_states.hft) *(hyper_states.hst) *(hyper_states.hlr)
!                *(hyper_parameters.ci) *(hyper_parameters.cp)
!                *(hyper_parameters.beta) *(hyper_parameters.cft)
!                *(hyper_parameters.cst) *(hyper_parameters.alpha)
!                *(hyper_parameters.exc) *(hyper_parameters.lr)
!   RW status of diff variables: hyper_states.hi:(loc) *(hyper_states.hi):out
!                hyper_states.hp:(loc) *(hyper_states.hp):out hyper_states.hft:(loc)
!                *(hyper_states.hft):out hyper_states.hst:(loc)
!                *(hyper_states.hst):out hyper_states.hlr:(loc)
!                *(hyper_states.hlr):out hyper_parameters.ci:(loc)
!                *(hyper_parameters.ci):out hyper_parameters.cp:(loc)
!                *(hyper_parameters.cp):out hyper_parameters.beta:(loc)
!                *(hyper_parameters.beta):out hyper_parameters.cft:(loc)
!                *(hyper_parameters.cft):out hyper_parameters.cst:(loc)
!                *(hyper_parameters.cst):out hyper_parameters.alpha:(loc)
!                *(hyper_parameters.alpha):out hyper_parameters.exc:(loc)
!                *(hyper_parameters.exc):out hyper_parameters.lr:(loc)
!                *(hyper_parameters.lr):out *(output.qsim):(loc)
!                cost:in-killed
!   Plus diff mem management of: hyper_states.hi:in hyper_states.hp:in
!                hyper_states.hft:in hyper_states.hst:in hyper_states.hlr:in
!                hyper_parameters.ci:in hyper_parameters.cp:in
!                hyper_parameters.beta:in hyper_parameters.cft:in
!                hyper_parameters.cst:in hyper_parameters.alpha:in
!                hyper_parameters.exc:in hyper_parameters.lr:in
!                output.qsim:in
!% Subroutine is a copy of forward
!% Find a way to avoid a full copy
!% WARNING: Differentiated module
SUBROUTINE BASE_HYPER_FORWARD_B(setup, mesh, input_data, &
& hyper_parameters, hyper_parameters_b, hyper_parameters_bgd, &
& hyper_states, hyper_states_b, hyper_states_bgd, output, output_b, cost&
& , cost_b)
!% only: sp
  USE MD_COMMON
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: Hyper_ParametersDT, ParametersDT_initialise, hyper_parameters_to_parameters
  USE MWD_PARAMETERS_DIFF
!% only: Hyper_StatesDT, StatesDT_initialise, hyper_states_to_states
  USE MWD_STATES_DIFF
!% only: OutputDT
  USE MWD_OUTPUT_DIFF
!% only: gr_interception, gr_production, gr_exchange, &
  USE MD_GR_OPERATOR_DIFF
!% & gr_transfer
!% only: upstream_discharge, sparse_upstream_discharge, linear_routing
  USE MD_ROUTING_OPERATOR_DIFF
!% only: compute_cost
  USE MWD_COST_DIFF
  IMPLICIT NONE
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
  TYPE(SETUPDT), INTENT(IN) :: setup
  TYPE(MESHDT), INTENT(IN) :: mesh
  TYPE(INPUT_DATADT), INTENT(INOUT) :: input_data
  TYPE(HYPER_PARAMETERSDT), INTENT(IN) :: hyper_parameters, &
& hyper_parameters_bgd
  TYPE(HYPER_PARAMETERSDT) :: hyper_parameters_b
  TYPE(HYPER_STATESDT), INTENT(INOUT) :: hyper_states, hyper_states_bgd
  TYPE(HYPER_STATESDT), INTENT(INOUT) :: hyper_states_b
  TYPE(OUTPUTDT), INTENT(INOUT) :: output
  TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_b
  REAL(sp), INTENT(INOUT) :: cost
  REAL(sp), INTENT(INOUT) :: cost_b
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
  TYPE(PARAMETERSDT) :: parameters
  TYPE(PARAMETERSDT) :: parameters_b
  TYPE(STATESDT) :: states
  TYPE(STATESDT) :: states_b
  REAL(sp), DIMENSION(:, :), ALLOCATABLE :: q
  REAL(sp), DIMENSION(:, :), ALLOCATABLE :: q_b
  REAL(sp), DIMENSION(:), ALLOCATABLE :: sparse_q
  REAL(sp), DIMENSION(:), ALLOCATABLE :: sparse_q_b
  REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prl, prd, qd, qr&
& , ql, qt, qup, qrout
  REAL(sp) :: ei_b, pn_b, en_b, pr_b, perc_b, l_b, prr_b, prl_b, prd_b, &
& qd_b, qr_b, ql_b, qt_b, qup_b, qrout_b
  INTEGER :: t, i, row, col, k, g
  INTRINSIC MIN
  INTRINSIC MAX
  INTRINSIC REAL
  REAL(sp) :: temp_b
  REAL*4 :: temp_b0
  INTEGER :: branch
  CALL PARAMETERSDT_INITIALISE_FWD(parameters, parameters_b, mesh)
  CALL STATESDT_INITIALISE_FWD(states, states_b, mesh)
  CALL HYPER_PARAMETERS_TO_PARAMETERS(hyper_parameters, parameters, &
&                               setup, input_data)
  CALL HYPER_STATES_TO_STATES(hyper_states, states, setup, input_data)
  IF (setup%sparse_storage) THEN
    ALLOCATE(sparse_q_b(mesh%nac))
    sparse_q_b = 0.0_4
    ALLOCATE(sparse_q(mesh%nac))
    CALL PUSHCONTROL1B(1)
  ELSE
    ALLOCATE(q_b(mesh%nrow, mesh%ncol))
    q_b = 0.0_4
    ALLOCATE(q(mesh%nrow, mesh%ncol))
    CALL PUSHCONTROL1B(0)
  END IF
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
  DO t=1,setup%ntime_step
!% [ DO SPACE ]
    DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialisation for time step (t) and cell (i)
!% =============================================================================================================== %!
      ei = 0._sp
      CALL PUSHREAL4(pn)
      pn = 0._sp
      CALL PUSHREAL4(pr)
      pr = 0._sp
      CALL PUSHREAL4(perc)
      perc = 0._sp
      l = 0._sp
      qd = 0._sp
      qr = 0._sp
      ql = 0._sp
!% [ END IF PATH ]
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of drained area 
!% =========================================================================================================== %!
      IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
!% [ IF PATH ]
        CALL PUSHINTEGER4(row)
        row = mesh%path(1, i)
        CALL PUSHINTEGER4(col)
        col = mesh%path(2, i)
        IF (setup%sparse_storage) THEN
          CALL PUSHINTEGER4(k)
          k = mesh%rowcol_to_ind_sparse(row, col)
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!% [ END IF ACTIVE CELL ]
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
        IF (mesh%active_cell(row, col) .EQ. 1 .AND. mesh%&
&           local_active_cell(row, col) .EQ. 1) THEN
!% [ IF ACTIVE CELL ]
          IF (setup%sparse_storage) THEN
            CALL PUSHREAL4(prcp)
            prcp = input_data%sparse_prcp(k, t)
            CALL PUSHREAL4(pet)
            pet = input_data%sparse_pet(k, t)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHREAL4(prcp)
            prcp = input_data%prcp(row, col, t)
            CALL PUSHREAL4(pet)
            pet = input_data%pet(row, col, t)
            CALL PUSHCONTROL1B(1)
          END IF
!% [ END IF PRCP GAP ]
          IF (prcp .GE. 0 .AND. pet .GE. 0) THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module case [ 0 - 1 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%interception_module) 
            CASE (0) 
              IF (pet .GT. prcp) THEN
                ei = prcp
              ELSE
                ei = pet
              END IF
              IF (0._sp .LT. prcp - ei) THEN
                CALL PUSHCONTROL2B(2)
                pn = prcp - ei
              ELSE
                CALL PUSHCONTROL2B(2)
                pn = 0._sp
              END IF
            CASE (1) 
              CALL PUSHREAL4(states%hi(row, col))
              CALL GR_INTERCEPTION(prcp, pet, parameters%ci(row, col), &
&                            states%hi(row, col), pn, ei)
              CALL PUSHCONTROL2B(1)
            CASE DEFAULT
              CALL PUSHCONTROL2B(0)
            END SELECT
            CALL PUSHREAL4(en)
            en = pet - ei
!% =============================================================================================== %!
!%   Production module case [ 0 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%production_module) 
            CASE (0) 
              CALL PUSHREAL4(states%hp(row, col))
              CALL GR_PRODUCTION(pn, en, parameters%cp(row, col), &
&                          parameters%beta(row, col), states%hp(row, col&
&                          ), pr, perc)
              CALL PUSHCONTROL1B(1)
            CASE DEFAULT
              CALL PUSHCONTROL1B(0)
            END SELECT
!% =============================================================================================== %!
!%   Exchange module case [ 0 - 1 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%exchange_module) 
            CASE (0) 
              CALL PUSHCONTROL2B(0)
              l = 0._sp
            CASE (1) 
              CALL GR_EXCHANGE(parameters%exc(row, col), states%hft(row&
&                        , col), l)
              CALL PUSHCONTROL2B(1)
            CASE DEFAULT
              CALL PUSHCONTROL2B(0)
            END SELECT
          ELSE
            CALL PUSHCONTROL2B(2)
          END IF
!% =================================================================================================== %!
!%   Transfer module case [ 0 ]
!% =================================================================================================== %!
          SELECT CASE  (setup%transfer_module) 
          CASE (0) 
            CALL PUSHREAL4(prr)
            prr = parameters%alpha(row, col)*(pr+perc) + l
            prd = (1._sp-parameters%alpha(row, col))*(pr+perc)
            CALL PUSHREAL4(states%hft(row, col))
            CALL GR_TRANSFER(5._sp, prcp, prr, parameters%cft(row, col)&
&                      , states%hft(row, col), qr)
            IF (0._sp .LT. prd + l) THEN
              qd = prd + l
              CALL PUSHCONTROL3B(2)
            ELSE
              qd = 0._sp
              CALL PUSHCONTROL3B(1)
            END IF
          CASE (1) 
            CALL PUSHREAL4(prr)
            prr = 0.9_sp*parameters%alpha(row, col)*(pr+perc) + l
            prl = 0.9_sp*(1._sp-parameters%alpha(row, col))*(pr+perc)
            prd = 0.1_sp*(pr+perc)
            CALL PUSHREAL4(states%hft(row, col))
            CALL GR_TRANSFER(5._sp, prcp, prr, parameters%cft(row, col)&
&                      , states%hft(row, col), qr)
            CALL PUSHREAL4(states%hst(row, col))
            CALL GR_TRANSFER(5._sp, prcp, prl, parameters%cst(row, col)&
&                      , states%hst(row, col), ql)
            IF (0._sp .LT. prd + l) THEN
              qd = prd + l
              CALL PUSHCONTROL3B(4)
            ELSE
              qd = 0._sp
              CALL PUSHCONTROL3B(3)
            END IF
          CASE DEFAULT
            CALL PUSHCONTROL3B(0)
          END SELECT
          qt = qd + qr + ql
!% =================================================================================================== %!
!%   Routing module case [ 0 - 1 ]
!% =================================================================================================== %!
          SELECT CASE  (setup%routing_module) 
          CASE (0) 
            IF (setup%sparse_storage) THEN
              CALL PUSHREAL4(qup)
              CALL SPARSE_UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%&
&                                      nrow, mesh%ncol, mesh%nac, mesh%&
&                                      flwdir, mesh%drained_area, mesh%&
&                                      rowcol_to_ind_sparse, row, col, &
&                                      sparse_q, qup)
              sparse_q(k) = (qt+qup*REAL(mesh%drained_area(row, col)-1))&
&               *mesh%dx*mesh%dx*0.001_sp/setup%dt
              CALL PUSHCONTROL3B(5)
            ELSE
              CALL PUSHREAL4(qup)
              CALL UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%nrow, mesh&
&                               %ncol, mesh%flwdir, mesh%drained_area, &
&                               row, col, q, qup)
              q(row, col) = (qt+qup*REAL(mesh%drained_area(row, col)-1))&
&               *mesh%dx*mesh%dx*0.001_sp/setup%dt
              CALL PUSHCONTROL3B(4)
            END IF
          CASE (1) 
            IF (setup%sparse_storage) THEN
              CALL PUSHREAL4(qup)
              CALL SPARSE_UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%&
&                                      nrow, mesh%ncol, mesh%nac, mesh%&
&                                      flwdir, mesh%drained_area, mesh%&
&                                      rowcol_to_ind_sparse, row, col, &
&                                      sparse_q, qup)
              CALL PUSHREAL4(states%hlr(row, col))
              CALL LINEAR_ROUTING(setup%dt, qup, parameters%lr(row, col)&
&                           , states%hlr(row, col), qrout)
              sparse_q(k) = (qt+qrout*REAL(mesh%drained_area(row, col)-1&
&               ))*mesh%dx*mesh%dx*0.001_sp/setup%dt
              CALL PUSHCONTROL3B(3)
            ELSE
              CALL PUSHREAL4(qup)
              CALL UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%nrow, mesh&
&                               %ncol, mesh%flwdir, mesh%drained_area, &
&                               row, col, q, qup)
              CALL PUSHREAL4(states%hlr(row, col))
              CALL LINEAR_ROUTING(setup%dt, qup, parameters%lr(row, col)&
&                           , states%hlr(row, col), qrout)
              q(row, col) = (qt+qrout*REAL(mesh%drained_area(row, col)-1&
&               ))*mesh%dx*mesh%dx*0.001_sp/setup%dt
              CALL PUSHCONTROL3B(2)
            END IF
          CASE DEFAULT
            CALL PUSHCONTROL3B(6)
          END SELECT
        ELSE
          CALL PUSHCONTROL3B(1)
        END IF
      ELSE
        CALL PUSHCONTROL3B(0)
      END IF
    END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
    DO g=1,mesh%ng
      CALL PUSHINTEGER4(row)
      row = mesh%gauge_pos(g, 1)
      CALL PUSHINTEGER4(col)
      col = mesh%gauge_pos(g, 2)
      IF (setup%sparse_storage) THEN
        CALL PUSHINTEGER4(k)
        k = mesh%rowcol_to_ind_sparse(row, col)
        output%qsim(g, t) = sparse_q(k)
        CALL PUSHCONTROL1B(1)
      ELSE
        output%qsim(g, t) = q(row, col)
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
  END DO
!% [ END DO TIME ]
!% =============================================================================================================== %!
!%   Store states at final time step
!% =============================================================================================================== %!
!% =================================================================================================================== %!
!%   Compute J
!% =================================================================================================================== %!
  CALL HYPER_COMPUTE_COST(setup, mesh, input_data, hyper_parameters, &
&                   hyper_parameters_bgd, hyper_states, hyper_states_bgd&
&                   , output, cost)
  CALL SET_HYPER_PARAMETERS(hyper_parameters_b, 0.0_4)
  CALL SET_HYPER_STATES(hyper_states_b, 0.0_4)
  CALL HYPER_COMPUTE_COST_B(setup, mesh, input_data, hyper_parameters, &
&                     hyper_parameters_bgd, hyper_states, &
&                     hyper_states_bgd, output, output_b, cost, cost_b)
  DO t=setup%ntime_step,1,-1
    DO g=mesh%ng,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        row = mesh%gauge_pos(g, 1)
        col = mesh%gauge_pos(g, 2)
        q_b(row, col) = q_b(row, col) + output_b%qsim(g, t)
        output_b%qsim(g, t) = 0.0_4
      ELSE
        sparse_q_b(k) = sparse_q_b(k) + output_b%qsim(g, t)
        output_b%qsim(g, t) = 0.0_4
        CALL POPINTEGER4(k)
      END IF
      CALL POPINTEGER4(col)
      CALL POPINTEGER4(row)
    END DO
    DO i=mesh%nrow*mesh%ncol,1,-1
      CALL POPCONTROL3B(branch)
      IF (branch .LT. 3) THEN
        IF (branch .EQ. 0) THEN
          GOTO 130
        ELSE IF (branch .EQ. 1) THEN
          GOTO 120
        ELSE
          row = mesh%path(1, i)
          col = mesh%path(2, i)
          temp_b0 = mesh%dx**2*0.001_sp*q_b(row, col)/setup%dt
          q_b(row, col) = 0.0_4
          qt_b = temp_b0
          qrout_b = REAL(mesh%drained_area(row, col)-1)*temp_b0
          CALL POPREAL4(states%hlr(row, col))
          CALL LINEAR_ROUTING_B(setup%dt, qup, qup_b, parameters%lr(row&
&                         , col), parameters_b%lr(row, col), states%hlr(&
&                         row, col), states_b%hlr(row, col), qrout, &
&                         qrout_b)
          CALL POPREAL4(qup)
          CALL UPSTREAM_DISCHARGE_B(setup%dt, mesh%dx, mesh%nrow, mesh%&
&                             ncol, mesh%flwdir, mesh%drained_area, row&
&                             , col, q, q_b, qup, qup_b)
        END IF
      ELSE IF (branch .LT. 5) THEN
        IF (branch .EQ. 3) THEN
          row = mesh%path(1, i)
          col = mesh%path(2, i)
          temp_b0 = mesh%dx**2*0.001_sp*sparse_q_b(k)/setup%dt
          sparse_q_b(k) = 0.0_4
          qt_b = temp_b0
          qrout_b = REAL(mesh%drained_area(row, col)-1)*temp_b0
          CALL POPREAL4(states%hlr(row, col))
          CALL LINEAR_ROUTING_B(setup%dt, qup, qup_b, parameters%lr(row&
&                         , col), parameters_b%lr(row, col), states%hlr(&
&                         row, col), states_b%hlr(row, col), qrout, &
&                         qrout_b)
          CALL POPREAL4(qup)
          CALL SPARSE_UPSTREAM_DISCHARGE_B(setup%dt, mesh%dx, mesh%nrow&
&                                    , mesh%ncol, mesh%nac, mesh%flwdir&
&                                    , mesh%drained_area, mesh%&
&                                    rowcol_to_ind_sparse, row, col, &
&                                    sparse_q, sparse_q_b, qup, qup_b)
        ELSE
          row = mesh%path(1, i)
          col = mesh%path(2, i)
          temp_b0 = mesh%dx**2*0.001_sp*q_b(row, col)/setup%dt
          q_b(row, col) = 0.0_4
          qt_b = temp_b0
          qup_b = REAL(mesh%drained_area(row, col)-1)*temp_b0
          CALL POPREAL4(qup)
          CALL UPSTREAM_DISCHARGE_B(setup%dt, mesh%dx, mesh%nrow, mesh%&
&                             ncol, mesh%flwdir, mesh%drained_area, row&
&                             , col, q, q_b, qup, qup_b)
        END IF
      ELSE IF (branch .EQ. 5) THEN
        row = mesh%path(1, i)
        col = mesh%path(2, i)
        temp_b0 = mesh%dx**2*0.001_sp*sparse_q_b(k)/setup%dt
        sparse_q_b(k) = 0.0_4
        qt_b = temp_b0
        qup_b = REAL(mesh%drained_area(row, col)-1)*temp_b0
        CALL POPREAL4(qup)
        CALL SPARSE_UPSTREAM_DISCHARGE_B(setup%dt, mesh%dx, mesh%nrow, &
&                                  mesh%ncol, mesh%nac, mesh%flwdir, &
&                                  mesh%drained_area, mesh%&
&                                  rowcol_to_ind_sparse, row, col, &
&                                  sparse_q, sparse_q_b, qup, qup_b)
      ELSE
        qt_b = 0.0_4
      END IF
      qd_b = qt_b
      qr_b = qt_b
      ql_b = qt_b
      CALL POPCONTROL3B(branch)
      IF (branch .LT. 2) THEN
        IF (branch .EQ. 0) THEN
          l_b = 0.0_4
          perc_b = 0.0_4
          pr_b = 0.0_4
          GOTO 100
        ELSE
          l_b = 0.0_4
          prd_b = 0.0_4
        END IF
      ELSE IF (branch .EQ. 2) THEN
        prd_b = qd_b
        l_b = qd_b
      ELSE
        IF (branch .EQ. 3) THEN
          l_b = 0.0_4
          prd_b = 0.0_4
        ELSE
          prd_b = qd_b
          l_b = qd_b
        END IF
        prl = 0.9_sp*(1._sp-parameters%alpha(row, col))*(pr+perc)
        CALL POPREAL4(states%hst(row, col))
        CALL GR_TRANSFER_B(5._sp, prcp, prl, prl_b, parameters%cst(row, &
&                    col), parameters_b%cst(row, col), states%hst(row, &
&                    col), states_b%hst(row, col), ql, ql_b)
        CALL POPREAL4(states%hft(row, col))
        CALL GR_TRANSFER_B(5._sp, prcp, prr, prr_b, parameters%cft(row, &
&                    col), parameters_b%cft(row, col), states%hft(row, &
&                    col), states_b%hft(row, col), qr, qr_b)
        parameters_b%alpha(row, col) = parameters_b%alpha(row, col) + (&
&         pr+perc)*0.9_sp*prr_b - (pr+perc)*0.9_sp*prl_b
        temp_b = (1._sp-parameters%alpha(row, col))*0.9_sp*prl_b
        pr_b = 0.1_sp*prd_b + temp_b
        perc_b = 0.1_sp*prd_b + temp_b
        CALL POPREAL4(prr)
        temp_b = parameters%alpha(row, col)*0.9_sp*prr_b
        l_b = l_b + prr_b
        pr_b = pr_b + temp_b
        perc_b = perc_b + temp_b
        GOTO 100
      END IF
      CALL POPREAL4(states%hft(row, col))
      CALL GR_TRANSFER_B(5._sp, prcp, prr, prr_b, parameters%cft(row, &
&                  col), parameters_b%cft(row, col), states%hft(row, col&
&                  ), states_b%hft(row, col), qr, qr_b)
      parameters_b%alpha(row, col) = parameters_b%alpha(row, col) + (pr+&
&       perc)*prr_b - (pr+perc)*prd_b
      temp_b = (1._sp-parameters%alpha(row, col))*prd_b
      pr_b = temp_b
      perc_b = temp_b
      CALL POPREAL4(prr)
      temp_b = parameters%alpha(row, col)*prr_b
      l_b = l_b + prr_b
      pr_b = pr_b + temp_b
      perc_b = perc_b + temp_b
 100  CALL POPCONTROL2B(branch)
      IF (branch .NE. 0) THEN
        IF (branch .EQ. 1) THEN
          CALL GR_EXCHANGE_B(parameters%exc(row, col), parameters_b%exc(&
&                      row, col), states%hft(row, col), states_b%hft(row&
&                      , col), l, l_b)
        ELSE
          GOTO 110
        END IF
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        en_b = 0.0_4
        pn_b = 0.0_4
      ELSE
        CALL POPREAL4(states%hp(row, col))
        CALL GR_PRODUCTION_B(pn, pn_b, en, en_b, parameters%cp(row, col)&
&                      , parameters_b%cp(row, col), parameters%beta(row&
&                      , col), parameters_b%beta(row, col), states%hp(&
&                      row, col), states_b%hp(row, col), pr, pr_b, perc&
&                      , perc_b)
      END IF
      CALL POPREAL4(en)
      ei_b = -en_b
      CALL POPCONTROL2B(branch)
      IF (branch .NE. 0) THEN
        IF (branch .EQ. 1) THEN
          CALL POPREAL4(states%hi(row, col))
          CALL GR_INTERCEPTION_B(prcp, pet, parameters%ci(row, col), &
&                          parameters_b%ci(row, col), states%hi(row, col&
&                          ), states_b%hi(row, col), pn, pn_b, ei, ei_b)
        END IF
      END IF
 110  CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL4(pet)
        CALL POPREAL4(prcp)
      ELSE
        CALL POPREAL4(pet)
        CALL POPREAL4(prcp)
      END IF
 120  CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) CALL POPINTEGER4(k)
      CALL POPINTEGER4(col)
      CALL POPINTEGER4(row)
 130  CALL POPREAL4(perc)
      CALL POPREAL4(pr)
      CALL POPREAL4(pn)
    END DO
  END DO
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    DEALLOCATE(q)
    DEALLOCATE(q_b)
  ELSE
    DEALLOCATE(sparse_q)
    DEALLOCATE(sparse_q_b)
  END IF
  CALL HYPER_STATES_TO_STATES_B(hyper_states, hyper_states_b, states, &
&                         states_b, setup, input_data)
  CALL HYPER_PARAMETERS_TO_PARAMETERS_B(hyper_parameters, &
&                                 hyper_parameters_b, parameters, &
&                                 parameters_b, setup, input_data)
  CALL STATESDT_INITIALISE_BWD(states, states_b, mesh)
  CALL PARAMETERSDT_INITIALISE_BWD(parameters, parameters_b, mesh)
END SUBROUTINE BASE_HYPER_FORWARD_B

!% Subroutine is a copy of forward
!% Find a way to avoid a full copy
!% WARNING: Differentiated module
SUBROUTINE BASE_HYPER_FORWARD_NODIFF(setup, mesh, input_data, &
& hyper_parameters, hyper_parameters_bgd, hyper_states, hyper_states_bgd&
& , output, cost)
!% only: sp
  USE MD_COMMON
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: Hyper_ParametersDT, ParametersDT_initialise, hyper_parameters_to_parameters
  USE MWD_PARAMETERS_DIFF
!% only: Hyper_StatesDT, StatesDT_initialise, hyper_states_to_states
  USE MWD_STATES_DIFF
!% only: OutputDT
  USE MWD_OUTPUT_DIFF
!% only: gr_interception, gr_production, gr_exchange, &
  USE MD_GR_OPERATOR_DIFF
!% & gr_transfer
!% only: upstream_discharge, sparse_upstream_discharge, linear_routing
  USE MD_ROUTING_OPERATOR_DIFF
!% only: compute_cost
  USE MWD_COST_DIFF
  IMPLICIT NONE
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
  TYPE(SETUPDT), INTENT(IN) :: setup
  TYPE(MESHDT), INTENT(IN) :: mesh
  TYPE(INPUT_DATADT), INTENT(INOUT) :: input_data
  TYPE(HYPER_PARAMETERSDT), INTENT(IN) :: hyper_parameters, &
& hyper_parameters_bgd
  TYPE(HYPER_STATESDT), INTENT(INOUT) :: hyper_states, hyper_states_bgd
  TYPE(OUTPUTDT), INTENT(INOUT) :: output
  REAL(sp), INTENT(INOUT) :: cost
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
  TYPE(PARAMETERSDT) :: parameters
  TYPE(STATESDT) :: states
  REAL(sp), DIMENSION(:, :), ALLOCATABLE :: q
  REAL(sp), DIMENSION(:), ALLOCATABLE :: sparse_q
  REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prl, prd, qd, qr&
& , ql, qt, qup, qrout
  INTEGER :: t, i, row, col, k, g
  INTRINSIC MIN
  INTRINSIC MAX
  INTRINSIC REAL
  CALL PARAMETERSDT_INITIALISE(parameters, mesh)
  CALL STATESDT_INITIALISE(states, mesh)
  cost = 0._sp
  CALL HYPER_PARAMETERS_TO_PARAMETERS(hyper_parameters, parameters, &
&                               setup, input_data)
  CALL HYPER_STATES_TO_STATES(hyper_states, states, setup, input_data)
  IF (setup%sparse_storage) THEN
    ALLOCATE(sparse_q(mesh%nac))
  ELSE
    ALLOCATE(q(mesh%nrow, mesh%ncol))
  END IF
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
  DO t=1,setup%ntime_step
!% [ DO SPACE ]
    DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialisation for time step (t) and cell (i)
!% =============================================================================================================== %!
      ei = 0._sp
      pn = 0._sp
      en = 0._sp
      pr = 0._sp
      perc = 0._sp
      l = 0._sp
      prr = 0._sp
      prl = 0._sp
      prd = 0._sp
      qd = 0._sp
      qr = 0._sp
      ql = 0._sp
      qup = 0._sp
      qrout = 0._sp
!% [ END IF PATH ]
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of drained area 
!% =========================================================================================================== %!
      IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
!% [ IF PATH ]
        row = mesh%path(1, i)
        col = mesh%path(2, i)
        IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, col&
&           )
!% [ END IF ACTIVE CELL ]
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
        IF (mesh%active_cell(row, col) .EQ. 1 .AND. mesh%&
&           local_active_cell(row, col) .EQ. 1) THEN
!% [ IF ACTIVE CELL ]
          IF (setup%sparse_storage) THEN
            prcp = input_data%sparse_prcp(k, t)
            pet = input_data%sparse_pet(k, t)
          ELSE
            prcp = input_data%prcp(row, col, t)
            pet = input_data%pet(row, col, t)
          END IF
!% [ END IF PRCP GAP ]
          IF (prcp .GE. 0 .AND. pet .GE. 0) THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module case [ 0 - 1 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%interception_module) 
            CASE (0) 
              IF (pet .GT. prcp) THEN
                ei = prcp
              ELSE
                ei = pet
              END IF
              IF (0._sp .LT. prcp - ei) THEN
                pn = prcp - ei
              ELSE
                pn = 0._sp
              END IF
            CASE (1) 
              CALL GR_INTERCEPTION(prcp, pet, parameters%ci(row, col), &
&                            states%hi(row, col), pn, ei)
            END SELECT
            en = pet - ei
!% =============================================================================================== %!
!%   Production module case [ 0 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%production_module) 
            CASE (0) 
              CALL GR_PRODUCTION(pn, en, parameters%cp(row, col), &
&                          parameters%beta(row, col), states%hp(row, col&
&                          ), pr, perc)
            END SELECT
!% =============================================================================================== %!
!%   Exchange module case [ 0 - 1 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%exchange_module) 
            CASE (0) 
              l = 0._sp
            CASE (1) 
              CALL GR_EXCHANGE(parameters%exc(row, col), states%hft(row&
&                        , col), l)
            END SELECT
          END IF
!% =================================================================================================== %!
!%   Transfer module case [ 0 ]
!% =================================================================================================== %!
          SELECT CASE  (setup%transfer_module) 
          CASE (0) 
            prr = parameters%alpha(row, col)*(pr+perc) + l
            prd = (1._sp-parameters%alpha(row, col))*(pr+perc)
            CALL GR_TRANSFER(5._sp, prcp, prr, parameters%cft(row, col)&
&                      , states%hft(row, col), qr)
            IF (0._sp .LT. prd + l) THEN
              qd = prd + l
            ELSE
              qd = 0._sp
            END IF
          CASE (1) 
            prr = 0.9_sp*parameters%alpha(row, col)*(pr+perc) + l
            prl = 0.9_sp*(1._sp-parameters%alpha(row, col))*(pr+perc)
            prd = 0.1_sp*(pr+perc)
            CALL GR_TRANSFER(5._sp, prcp, prr, parameters%cft(row, col)&
&                      , states%hft(row, col), qr)
            CALL GR_TRANSFER(5._sp, prcp, prl, parameters%cst(row, col)&
&                      , states%hst(row, col), ql)
            IF (0._sp .LT. prd + l) THEN
              qd = prd + l
            ELSE
              qd = 0._sp
            END IF
          END SELECT
          qt = qd + qr + ql
!% =================================================================================================== %!
!%   Routing module case [ 0 - 1 ]
!% =================================================================================================== %!
          SELECT CASE  (setup%routing_module) 
          CASE (0) 
            IF (setup%sparse_storage) THEN
              CALL SPARSE_UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%&
&                                      nrow, mesh%ncol, mesh%nac, mesh%&
&                                      flwdir, mesh%drained_area, mesh%&
&                                      rowcol_to_ind_sparse, row, col, &
&                                      sparse_q, qup)
              sparse_q(k) = (qt+qup*REAL(mesh%drained_area(row, col)-1))&
&               *mesh%dx*mesh%dx*0.001_sp/setup%dt
            ELSE
              CALL UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%nrow, mesh&
&                               %ncol, mesh%flwdir, mesh%drained_area, &
&                               row, col, q, qup)
              q(row, col) = (qt+qup*REAL(mesh%drained_area(row, col)-1))&
&               *mesh%dx*mesh%dx*0.001_sp/setup%dt
            END IF
          CASE (1) 
            IF (setup%sparse_storage) THEN
              CALL SPARSE_UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%&
&                                      nrow, mesh%ncol, mesh%nac, mesh%&
&                                      flwdir, mesh%drained_area, mesh%&
&                                      rowcol_to_ind_sparse, row, col, &
&                                      sparse_q, qup)
              CALL LINEAR_ROUTING(setup%dt, qup, parameters%lr(row, col)&
&                           , states%hlr(row, col), qrout)
              sparse_q(k) = (qt+qrout*REAL(mesh%drained_area(row, col)-1&
&               ))*mesh%dx*mesh%dx*0.001_sp/setup%dt
            ELSE
              CALL UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%nrow, mesh&
&                               %ncol, mesh%flwdir, mesh%drained_area, &
&                               row, col, q, qup)
              CALL LINEAR_ROUTING(setup%dt, qup, parameters%lr(row, col)&
&                           , states%hlr(row, col), qrout)
              q(row, col) = (qt+qrout*REAL(mesh%drained_area(row, col)-1&
&               ))*mesh%dx*mesh%dx*0.001_sp/setup%dt
            END IF
          END SELECT
        END IF
      END IF
    END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
    DO g=1,mesh%ng
      row = mesh%gauge_pos(g, 1)
      col = mesh%gauge_pos(g, 2)
      IF (setup%sparse_storage) THEN
        k = mesh%rowcol_to_ind_sparse(row, col)
        output%qsim(g, t) = sparse_q(k)
      ELSE
        output%qsim(g, t) = q(row, col)
      END IF
    END DO
!% =============================================================================================================== %!
!%   Store simulated discharge on domain (optional)
!% =============================================================================================================== %!
    IF (setup%save_qsim_domain) THEN
      IF (setup%sparse_storage) THEN
        output%sparse_qsim_domain(:, t) = sparse_q
      ELSE
        output%qsim_domain(:, :, t) = q
      END IF
    END IF
!% =============================================================================================================== %!
!%   Store simulated net rainfall on domain (optional)
!%   The net rainfall over a surface is a fictitious quantity that corresponds to 
!%   the part of the rainfall water depth that actually causes runoff. 
!% =============================================================================================================== %!
    IF (setup%save_net_prcp_domain) THEN
      IF (setup%sparse_storage) THEN
        output%sparse_net_prcp_domain(:, t) = qt
      ELSE
        output%net_prcp_domain(:, :, t) = qt
      END IF
    END IF
  END DO
!% [ END DO TIME ]
!% =============================================================================================================== %!
!%   Store states at final time step
!% =============================================================================================================== %!
  output%fstates = states
!% =================================================================================================================== %!
!%   Compute J
!% =================================================================================================================== %!
  CALL HYPER_COMPUTE_COST(setup, mesh, input_data, hyper_parameters, &
&                   hyper_parameters_bgd, hyper_states, hyper_states_bgd&
&                   , output, cost)
END SUBROUTINE BASE_HYPER_FORWARD_NODIFF

