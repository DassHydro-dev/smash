!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!%      (MWD) Module Wrapped and Differentiated.
!%
!%      Type
!%      ----
!%
!%      - OutputDT
!%
!%          ======================== =======================================
!%          `Variables`              Description
!%          ======================== =======================================
!%          ``sim_response``         ResponseDT
!%          ``opr_final_states``     Opr_StatesDT
!%          ======================== =======================================
!%
!%      Subroutine
!%      ----------
!%
!%      - OutputDT_initialise
!%      - OutputDT_copy
MODULE MWD_OUTPUT_DIFF
!% only: sp
  USE MD_CONSTANT
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: ResponseDT, ResponseDT_initialise
  USE MWD_RESPONSE
!% only: Opr_StatesDT, Opr_StatesDT_initialise
  USE MWD_OPR_STATES
  IMPLICIT NONE
  TYPE OUTPUTDT
      TYPE(RESPONSEDT) :: sim_response
      TYPE(OPR_STATESDT) :: opr_final_states
      REAL(sp) :: cost
  END TYPE OUTPUTDT
  TYPE OUTPUTDT_DIFF
      REAL(sp) :: cost
  END TYPE OUTPUTDT_DIFF

CONTAINS
  SUBROUTINE OUTPUTDT_INITIALISE(this, setup, mesh)
    IMPLICIT NONE
    TYPE(OUTPUTDT), INTENT(INOUT) :: this
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    CALL RESPONSEDT_INITIALISE(this%sim_response, setup, mesh)
    CALL OPR_STATESDT_INITIALISE(this%opr_final_states, setup, mesh)
  END SUBROUTINE OUTPUTDT_INITIALISE

  SUBROUTINE OUTPUTDT_COPY(this, this_copy)
    IMPLICIT NONE
    TYPE(OUTPUTDT), INTENT(IN) :: this
    TYPE(OUTPUTDT), INTENT(OUT) :: this_copy
    this_copy = this
  END SUBROUTINE OUTPUTDT_COPY

END MODULE MWD_OUTPUT_DIFF

!%      (MWD) Module Wrapped and Differentiated.
!%
!%      Type
!%      ----
!%
!%      - ControlDT
!%
!%          ========================== =====================================
!%          `Variables`                Description
!%          ========================== =====================================
!%          ``x``                      Control vector
!%          ``x_bkg``                  Control vector background
!%          ``l``                      Control vector lower bound
!%          ``u``                      Control vector upper bound
!%          ``nbd``                    Control vector kind of bound
!%
!ยง      Subroutine
!%      ----------
!%
!%      - ControlDT_initialise
!%      - ControlDT_copy
MODULE MWD_CONTROL_DIFF
!% only: sp
  USE MD_CONSTANT
  IMPLICIT NONE
  TYPE CONTROLDT
      REAL(sp), DIMENSION(:), ALLOCATABLE :: x
      REAL(sp), DIMENSION(:), ALLOCATABLE :: x_bkg
      REAL(sp), DIMENSION(:), ALLOCATABLE :: l
      REAL(sp), DIMENSION(:), ALLOCATABLE :: u
      INTEGER, DIMENSION(:), ALLOCATABLE :: nbd
  END TYPE CONTROLDT
  TYPE CONTROLDT_DIFF
      REAL(sp), DIMENSION(:), ALLOCATABLE :: x
  END TYPE CONTROLDT_DIFF

CONTAINS
  SUBROUTINE CONTROLDT_INITIALISE(this)
    IMPLICIT NONE
    TYPE(CONTROLDT), INTENT(INOUT) :: this
  END SUBROUTINE CONTROLDT_INITIALISE

  SUBROUTINE CONTROLDT_COPY(this, this_copy)
    IMPLICIT NONE
    TYPE(CONTROLDT), INTENT(IN) :: this
    TYPE(CONTROLDT), INTENT(OUT) :: this_copy
    this_copy = this
  END SUBROUTINE CONTROLDT_COPY

END MODULE MWD_CONTROL_DIFF

!%      (MWD) Module Wrapped and Differentiated.
!%
!%      Type
!%      ----
!%
!%      - ParametersDT
!%
!%          ========================== =====================================
!%          `Variables`                Description
!%          ========================== =====================================
!%          ``control``                ControlDT
!%          ``opr_parameters``         Opr_ParametersDT
!%          ``opr_initial_states``     Opr_StatesDT
!%
!ยง      Subroutine
!%      ----------
!%
!%      - ParametersDT_initialise
!%      - ParametersDT_copy
MODULE MWD_PARAMETERS_DIFF
!% only: sp
  USE MD_CONSTANT
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: ControlDT
  USE MWD_CONTROL_DIFF
!% only: Opr_ParametersDT, Opr_ParametersDT_initialise
  USE MWD_OPR_PARAMETERS
!% only: Opr_StatesDT, Opr_StatesDT_initialise
  USE MWD_OPR_STATES
  IMPLICIT NONE
  TYPE PARAMETERSDT
      TYPE(CONTROLDT) :: control
      TYPE(OPR_PARAMETERSDT) :: opr_parameters
      TYPE(OPR_STATESDT) :: opr_initial_states
  END TYPE PARAMETERSDT
  TYPE PARAMETERSDT_DIFF
      TYPE(CONTROLDT_DIFF) :: control
  END TYPE PARAMETERSDT_DIFF

CONTAINS
  SUBROUTINE PARAMETERSDT_INITIALISE(this, setup, mesh)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: this
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    CALL OPR_PARAMETERSDT_INITIALISE(this%opr_parameters, setup, mesh)
    CALL OPR_STATESDT_INITIALISE(this%opr_initial_states, setup, mesh)
  END SUBROUTINE PARAMETERSDT_INITIALISE

  SUBROUTINE PARAMETERSDT_COPY(this, this_copy)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(IN) :: this
    TYPE(PARAMETERSDT), INTENT(OUT) :: this_copy
    this_copy = this
  END SUBROUTINE PARAMETERSDT_COPY

END MODULE MWD_PARAMETERS_DIFF

!%      (MWD) Module Wrapped and Differentiated.
!%
!%      Subroutine
!%      ----------
!%
!%      - compute_cost
!%      - nse
MODULE MWD_COST_DIFF
!% only: sp
  USE MD_CONSTANT
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: ParametersDT
  USE MWD_PARAMETERS_DIFF
!% only: OutputDT
  USE MWD_OUTPUT_DIFF
!% only: OptionsDT
  USE MWD_OPTIONS
!% only: ReturnsDT
  USE MWD_RETURNS
  IMPLICIT NONE

CONTAINS
  SUBROUTINE COMPUTE_COST(setup, mesh, input_data, parameters, output, &
&   options, returns)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OPTIONSDT), INTENT(IN) :: options
    TYPE(RETURNSDT), INTENT(INOUT) :: returns
    CALL NSE(input_data%obs_response%q(1, :), output%sim_response%q(1, :&
&      ), output%cost)
  END SUBROUTINE COMPUTE_COST

  SUBROUTINE NSE(x, y, res)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), INTENT(INOUT) :: res
    REAL(sp) :: sum_x, sum_xx, sum_yy, sum_xy, mean_x, num, den
    INTEGER :: i, n
    INTRINSIC SIZE
!% Metric computation
    n = 0
    sum_x = 0._sp
    sum_xx = 0._sp
    sum_yy = 0._sp
    sum_xy = 0._sp
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0._sp) THEN
        n = n + 1
        sum_x = sum_x + x(i)
        sum_xx = sum_xx + x(i)*x(i)
        sum_yy = sum_yy + y(i)*y(i)
        sum_xy = sum_xy + x(i)*y(i)
      END IF
    END DO
    mean_x = sum_x/n
!% NSE numerator / denominator
    num = sum_xx - 2*sum_xy + sum_yy
    den = sum_xx - n*mean_x*mean_x
!% NSE criterion
    res = num/den
  END SUBROUTINE NSE

END MODULE MWD_COST_DIFF

!%      (MWD) Module Wrapped and Differentiated
!%
!%      Subroutine
!%      ----------
!%
!%      - map_control_to_parameters
MODULE MWD_PARAMETERS_MANIPULATION_DIFF
!% only: sp
  USE MD_CONSTANT
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: ParametersDT
  USE MWD_PARAMETERS_DIFF
!% only: OptionsDT
  USE MWD_OPTIONS
  IMPLICIT NONE

CONTAINS
  SUBROUTINE OPR_PARAMETERS_TO_MATRIX(setup, mesh, parameters, matrix)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, setup%nopr_p), INTENT(&
&   INOUT) :: matrix
    SELECT CASE  (setup%structure) 
    CASE ('gr_a') 
      matrix(:, :, 1) = parameters%opr_parameters%gr_a%cp
      matrix(:, :, 2) = parameters%opr_parameters%gr_a%cft
      matrix(:, :, 3) = parameters%opr_parameters%gr_a%exc
      matrix(:, :, 4) = parameters%opr_parameters%gr_a%lr
    CASE ('gr_b') 
      matrix(:, :, 1) = parameters%opr_parameters%gr_b%cp
      matrix(:, :, 2) = parameters%opr_parameters%gr_b%cft
      matrix(:, :, 3) = parameters%opr_parameters%gr_b%exc
      matrix(:, :, 4) = parameters%opr_parameters%gr_b%lr
    CASE ('gr_c') 
      matrix(:, :, 1) = parameters%opr_parameters%gr_c%cp
      matrix(:, :, 2) = parameters%opr_parameters%gr_c%cft
      matrix(:, :, 3) = parameters%opr_parameters%gr_c%cst
      matrix(:, :, 4) = parameters%opr_parameters%gr_c%exc
      matrix(:, :, 5) = parameters%opr_parameters%gr_c%lr
    CASE ('gr_d') 
      matrix(:, :, 1) = parameters%opr_parameters%gr_d%cp
      matrix(:, :, 2) = parameters%opr_parameters%gr_d%cft
      matrix(:, :, 3) = parameters%opr_parameters%gr_d%lr
    END SELECT
  END SUBROUTINE OPR_PARAMETERS_TO_MATRIX

  SUBROUTINE OPR_INITIAL_STATES_TO_MATRIX(setup, mesh, parameters, &
&   matrix)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, setup%nopr_s), INTENT(&
&   INOUT) :: matrix
    SELECT CASE  (setup%structure) 
    CASE ('gr_a') 
      matrix(:, :, 1) = parameters%opr_initial_states%gr_a%hp
      matrix(:, :, 2) = parameters%opr_initial_states%gr_a%hft
      matrix(:, :, 3) = parameters%opr_initial_states%gr_a%hlr
    CASE ('gr_b') 
      matrix(:, :, 1) = parameters%opr_initial_states%gr_b%hi
      matrix(:, :, 2) = parameters%opr_initial_states%gr_b%hp
      matrix(:, :, 3) = parameters%opr_initial_states%gr_b%hft
      matrix(:, :, 4) = parameters%opr_initial_states%gr_b%hlr
    CASE ('gr_c') 
      matrix(:, :, 1) = parameters%opr_initial_states%gr_c%hi
      matrix(:, :, 2) = parameters%opr_initial_states%gr_c%hp
      matrix(:, :, 3) = parameters%opr_initial_states%gr_c%hft
      matrix(:, :, 4) = parameters%opr_initial_states%gr_c%hst
      matrix(:, :, 5) = parameters%opr_initial_states%gr_c%hlr
    CASE ('gr_d') 
      matrix(:, :, 1) = parameters%opr_initial_states%gr_d%hp
      matrix(:, :, 2) = parameters%opr_initial_states%gr_d%hft
      matrix(:, :, 3) = parameters%opr_initial_states%gr_d%hlr
    END SELECT
  END SUBROUTINE OPR_INITIAL_STATES_TO_MATRIX

  SUBROUTINE MATRIX_TO_OPR_PARAMETERS(setup, mesh, matrix, parameters)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, setup%nopr_p), INTENT(IN) &
&   :: matrix
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    SELECT CASE  (setup%structure) 
    CASE ('gr_a') 
      parameters%opr_parameters%gr_a%cp = matrix(:, :, 1)
      parameters%opr_parameters%gr_a%cft = matrix(:, :, 2)
      parameters%opr_parameters%gr_a%exc = matrix(:, :, 3)
      parameters%opr_parameters%gr_a%lr = matrix(:, :, 4)
    CASE ('gr_b') 
      parameters%opr_parameters%gr_b%cp = matrix(:, :, 1)
      parameters%opr_parameters%gr_b%cft = matrix(:, :, 2)
      parameters%opr_parameters%gr_b%exc = matrix(:, :, 3)
      parameters%opr_parameters%gr_b%lr = matrix(:, :, 4)
    CASE ('gr_c') 
      parameters%opr_parameters%gr_c%cp = matrix(:, :, 1)
      parameters%opr_parameters%gr_c%cft = matrix(:, :, 2)
      parameters%opr_parameters%gr_c%cst = matrix(:, :, 3)
      parameters%opr_parameters%gr_c%exc = matrix(:, :, 4)
      parameters%opr_parameters%gr_c%lr = matrix(:, :, 5)
    CASE ('gr_d') 
      parameters%opr_parameters%gr_d%cp = matrix(:, :, 1)
      parameters%opr_parameters%gr_d%cft = matrix(:, :, 2)
      parameters%opr_parameters%gr_d%lr = matrix(:, :, 3)
    END SELECT
  END SUBROUTINE MATRIX_TO_OPR_PARAMETERS

  SUBROUTINE MATRIX_TO_OPR_INITIAL_STATES(setup, mesh, matrix, &
&   parameters)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, setup%nopr_s), INTENT(IN) &
&   :: matrix
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    SELECT CASE  (setup%structure) 
    CASE ('gr_a') 
      parameters%opr_initial_states%gr_a%hp = matrix(:, :, 1)
      parameters%opr_initial_states%gr_a%hft = matrix(:, :, 2)
      parameters%opr_initial_states%gr_a%hlr = matrix(:, :, 3)
    CASE ('gr_b') 
      parameters%opr_initial_states%gr_b%hi = matrix(:, :, 1)
      parameters%opr_initial_states%gr_b%hp = matrix(:, :, 2)
      parameters%opr_initial_states%gr_b%hft = matrix(:, :, 3)
      parameters%opr_initial_states%gr_b%hlr = matrix(:, :, 4)
    CASE ('gr_c') 
      parameters%opr_initial_states%gr_c%hi = matrix(:, :, 1)
      parameters%opr_initial_states%gr_c%hp = matrix(:, :, 2)
      parameters%opr_initial_states%gr_c%hft = matrix(:, :, 3)
      parameters%opr_initial_states%gr_c%hst = matrix(:, :, 4)
      parameters%opr_initial_states%gr_c%hlr = matrix(:, :, 5)
    CASE ('gr_d') 
      parameters%opr_initial_states%gr_d%hp = matrix(:, :, 1)
      parameters%opr_initial_states%gr_d%hft = matrix(:, :, 2)
      parameters%opr_initial_states%gr_d%hlr = matrix(:, :, 3)
    END SELECT
  END SUBROUTINE MATRIX_TO_OPR_INITIAL_STATES

  SUBROUTINE MAP_CONTROL_TO_PARAMETERS(setup, mesh, parameters, options)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(OPTIONSDT), INTENT(IN) :: options
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, setup%nopr_p) :: &
&   opr_parameters_matrix
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, setup%nopr_s) :: &
&   opr_initial_states_matrix
    CALL OPR_PARAMETERS_TO_MATRIX(setup, mesh, parameters, &
&                           opr_parameters_matrix)
    CALL OPR_INITIAL_STATES_TO_MATRIX(setup, mesh, parameters, &
&                               opr_initial_states_matrix)
!~         select case (options%optimize%mapping)
!~         case ("uniform")
!~         case ("distributed")
!~         end select
    CALL MATRIX_TO_OPR_PARAMETERS(setup, mesh, opr_parameters_matrix, &
&                           parameters)
    CALL MATRIX_TO_OPR_INITIAL_STATES(setup, mesh, &
&                               opr_initial_states_matrix, parameters)
  END SUBROUTINE MAP_CONTROL_TO_PARAMETERS

END MODULE MWD_PARAMETERS_MANIPULATION_DIFF

!%      (MD) Module Differentiated.
!%
!%      Subroutine
!%      ----------
!%
!%      gr_a_forward
MODULE MD_FORWARD_STRUCTURE_DIFF
!% only: sp
  USE MD_CONSTANT
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: GR_A_Opr_ParametersDT
  USE MWD_OPR_PARAMETERS
!% only: GR_A_Opr_StatesDT
  USE MWD_OPR_STATES
!% only: OutputDT
  USE MWD_OUTPUT_DIFF
!% only: OptionsDT
  USE MWD_OPTIONS
!% only: ReturnsDT
  USE MWD_RETURNS
!% only: gr_interception, gr_production, gr_exchange, &
  USE MD_GR_OPERATOR
!% & gr_transfer
!% only: upstream_discharge, linear_routing
  USE MD_ROUTING_OPERATOR
  IMPLICIT NONE

CONTAINS
  SUBROUTINE GR_A_FORWARD(setup, mesh, input_data, opr_parameters, &
&   opr_states, output, options, returns)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(GR_A_OPR_PARAMETERSDT), INTENT(IN) :: opr_parameters
    TYPE(GR_A_OPR_STATESDT), INTENT(INOUT) :: opr_states
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OPTIONSDT), INTENT(IN) :: options
    TYPE(RETURNSDT), INTENT(INOUT) :: returns
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q, qt
    REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prd, qr, qd, &
&   qup, qrout
    INTEGER :: t, i, row, col, k, g
    INTRINSIC MIN
    INTRINSIC MAX
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!$omp parallel do num_threads(options%comm%ncpu) shared(setup, mesh, input_data, &
!$omp& opr_parameters, opr_states, output, qt), &
!$omp& private(i, ei, pn, en, pr, perc, l, prr, prd, qr, qd, row, col, prcp, pet)
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialisation for time step (t) and cell (i)
!% =============================================================================================================== %!
        ei = 0._sp
        pn = 0._sp
        en = 0._sp
        pr = 0._sp
        perc = 0._sp
        l = 0._sp
        prr = 0._sp
        prd = 0._sp
        qr = 0._sp
        qd = 0._sp
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of flow accumulation
!% =========================================================================================================== %!
        row = mesh%path(1, i)
        col = mesh%path(2, i)
        IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, col&
&           )
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
!% [ CYCLE ACTIVE CELL ]
        IF (.NOT.(mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0)) THEN
          IF (setup%sparse_storage) THEN
            prcp = input_data%atmos_data%sparse_prcp(k, t)
            pet = input_data%atmos_data%sparse_pet(k, t)
          ELSE
            prcp = input_data%atmos_data%prcp(row, col, t)
            pet = input_data%atmos_data%pet(row, col, t)
          END IF
!% [ END IF PRCP GAP ]
          IF (prcp .GE. 0 .AND. pet .GE. 0) THEN
            IF (pet .GT. prcp) THEN
              ei = prcp
            ELSE
              ei = pet
            END IF
            IF (0._sp .LT. prcp - ei) THEN
              pn = prcp - ei
            ELSE
              pn = 0._sp
            END IF
            en = pet - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
            CALL GR_PRODUCTION(pn, en, opr_parameters%cp(row, col), &
&                        1000._sp, opr_states%hp(row, col), pr, perc)
!% =============================================================================================== %!
!%   Exchange module
!% =============================================================================================== %!
            CALL GR_EXCHANGE(opr_parameters%exc(row, col), opr_states%&
&                      hft(row, col), l)
          END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
          prr = 0.9_sp*(pr+perc) + l
          prd = 0.1_sp*(pr+perc)
          CALL GR_TRANSFER(5._sp, prcp, prr, opr_parameters%cft(row, col&
&                    ), opr_states%hft(row, col), qr)
          IF (0._sp .LT. prd + l) THEN
            qd = prd + l
          ELSE
            qd = 0._sp
          END IF
          qt(row, col) = qr + qd
        END IF
      END DO
!$omp end parallel do
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        qup = 0._sp
        qrout = 0._sp
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% [ CYCLE ACTIVE CELL ]
        IF (.NOT.(mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0)) THEN
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
          CALL UPSTREAM_DISCHARGE(mesh%nrow, mesh%ncol, setup%dt, mesh%&
&                           dx(row, col), mesh%dy(row, col), row, col, &
&                           mesh%flwdir, mesh%flwacc, q, qup)
          CALL LINEAR_ROUTING(setup%dt, qup, opr_parameters%lr(row, col)&
&                       , opr_states%hlr(row, col), qrout)
          q(row, col) = (qt(row, col)*mesh%dx(row, col)*mesh%dy(row, col&
&           )+qrout*(mesh%flwacc(row, col)-mesh%dx(row, col)*mesh%dy(row&
&           , col)))*1e-3_sp/setup%dt
        END IF
      END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
      DO g=1,mesh%ng
        output%sim_response%q(g, t) = q(mesh%gauge_pos(g, 1), mesh%&
&         gauge_pos(g, 2))
      END DO
    END DO
  END SUBROUTINE GR_A_FORWARD

  SUBROUTINE GR_B_FORWARD(setup, mesh, input_data, opr_parameters, &
&   opr_states, output, options, returns)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(GR_B_OPR_PARAMETERSDT), INTENT(IN) :: opr_parameters
    TYPE(GR_B_OPR_STATESDT), INTENT(INOUT) :: opr_states
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OPTIONSDT), INTENT(IN) :: options
    TYPE(RETURNSDT), INTENT(INOUT) :: returns
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q, qt
    REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prd, qr, qd, &
&   qup, qrout
    INTEGER :: t, i, row, col, k, g
    INTRINSIC MAX
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!$omp parallel do num_threads(options%comm%ncpu) shared(setup, mesh, input_data, &
!$omp& opr_parameters, opr_states, output, qt), &
!$omp& private(i, ei, pn, en, pr, perc, l, prr, prd, qr, qd, row, col, prcp, pet)
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialisation for time step (t) and cell (i)
!% =============================================================================================================== %!
        ei = 0._sp
        pn = 0._sp
        en = 0._sp
        pr = 0._sp
        perc = 0._sp
        l = 0._sp
        prr = 0._sp
        prd = 0._sp
        qr = 0._sp
        qd = 0._sp
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of flow accumulation
!% =========================================================================================================== %!
        row = mesh%path(1, i)
        col = mesh%path(2, i)
        IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, col&
&           )
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
!% [ CYCLE ACTIVE CELL ]
        IF (.NOT.(mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0)) THEN
          IF (setup%sparse_storage) THEN
            prcp = input_data%atmos_data%sparse_prcp(k, t)
            pet = input_data%atmos_data%sparse_pet(k, t)
          ELSE
            prcp = input_data%atmos_data%prcp(row, col, t)
            pet = input_data%atmos_data%pet(row, col, t)
          END IF
!% [ END IF PRCP GAP ]
          IF (prcp .GE. 0 .AND. pet .GE. 0) THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module
!% =============================================================================================== %!
            CALL GR_INTERCEPTION(prcp, pet, opr_parameters%ci(row, col)&
&                          , opr_states%hi(row, col), pn, ei)
            en = pet - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
            CALL GR_PRODUCTION(pn, en, opr_parameters%cp(row, col), &
&                        1000._sp, opr_states%hp(row, col), pr, perc)
!% =============================================================================================== %!
!%   Exchange module
!% =============================================================================================== %!
            CALL GR_EXCHANGE(opr_parameters%exc(row, col), opr_states%&
&                      hft(row, col), l)
          END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
          prr = 0.9_sp*(pr+perc) + l
          prd = 0.1_sp*(pr+perc)
          CALL GR_TRANSFER(5._sp, prcp, prr, opr_parameters%cft(row, col&
&                    ), opr_states%hft(row, col), qr)
          IF (0._sp .LT. prd + l) THEN
            qd = prd + l
          ELSE
            qd = 0._sp
          END IF
          qt(row, col) = qr + qd
        END IF
      END DO
!$omp end parallel do
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        qup = 0._sp
        qrout = 0._sp
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% [ CYCLE ACTIVE CELL ]
        IF (.NOT.(mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0)) THEN
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
          CALL UPSTREAM_DISCHARGE(mesh%nrow, mesh%ncol, setup%dt, mesh%&
&                           dx(row, col), mesh%dy(row, col), row, col, &
&                           mesh%flwdir, mesh%flwacc, q, qup)
          CALL LINEAR_ROUTING(setup%dt, qup, opr_parameters%lr(row, col)&
&                       , opr_states%hlr(row, col), qrout)
          q(row, col) = (qt(row, col)*mesh%dx(row, col)*mesh%dy(row, col&
&           )+qrout*(mesh%flwacc(row, col)-mesh%dx(row, col)*mesh%dy(row&
&           , col)))*1e-3_sp/setup%dt
        END IF
      END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
      DO g=1,mesh%ng
        output%sim_response%q(g, t) = q(mesh%gauge_pos(g, 1), mesh%&
&         gauge_pos(g, 2))
      END DO
    END DO
  END SUBROUTINE GR_B_FORWARD

  SUBROUTINE GR_C_FORWARD(setup, mesh, input_data, opr_parameters, &
&   opr_states, output, options, returns)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(GR_C_OPR_PARAMETERSDT), INTENT(IN) :: opr_parameters
    TYPE(GR_C_OPR_STATESDT), INTENT(INOUT) :: opr_states
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OPTIONSDT), INTENT(IN) :: options
    TYPE(RETURNSDT), INTENT(INOUT) :: returns
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q, qt
    REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prl, prd, qr, &
&   ql, qd, qup, qrout
    INTEGER :: t, i, row, col, k, g
    INTRINSIC MAX
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!$omp parallel do num_threads(options%comm%ncpu) shared(setup, mesh, input_data, &
!$omp& opr_parameters, opr_states, output, qt), &
!$omp& private(i, ei, pn, en, pr, perc, l, prr, prl, prd, qr, qd, row, col, prcp, pet)
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialisation for time step (t) and cell (i)
!% =============================================================================================================== %!
        ei = 0._sp
        pn = 0._sp
        en = 0._sp
        pr = 0._sp
        perc = 0._sp
        l = 0._sp
        prr = 0._sp
        prl = 0._sp
        prd = 0._sp
        qr = 0._sp
        ql = 0._sp
        qd = 0._sp
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of flow accumulation
!% =========================================================================================================== %!
        row = mesh%path(1, i)
        col = mesh%path(2, i)
        IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, col&
&           )
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
!% [ CYCLE ACTIVE CELL ]
        IF (.NOT.(mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0)) THEN
          IF (setup%sparse_storage) THEN
            prcp = input_data%atmos_data%sparse_prcp(k, t)
            pet = input_data%atmos_data%sparse_pet(k, t)
          ELSE
            prcp = input_data%atmos_data%prcp(row, col, t)
            pet = input_data%atmos_data%pet(row, col, t)
          END IF
!% [ END IF PRCP GAP ]
          IF (prcp .GE. 0 .AND. pet .GE. 0) THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module
!% =============================================================================================== %!
            CALL GR_INTERCEPTION(prcp, pet, opr_parameters%ci(row, col)&
&                          , opr_states%hi(row, col), pn, ei)
            en = pet - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
            CALL GR_PRODUCTION(pn, en, opr_parameters%cp(row, col), &
&                        1000._sp, opr_states%hp(row, col), pr, perc)
!% =============================================================================================== %!
!%   Exchange module
!% =============================================================================================== %!
            CALL GR_EXCHANGE(opr_parameters%exc(row, col), opr_states%&
&                      hft(row, col), l)
          END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
          prr = 0.9_sp*0.6_sp*(pr+perc) + l
          prl = 0.9_sp*0.4_sp*(pr+perc)
          prd = 0.1_sp*(pr+perc)
          CALL GR_TRANSFER(5._sp, prcp, prr, opr_parameters%cft(row, col&
&                    ), opr_states%hft(row, col), qr)
          CALL GR_TRANSFER(5._sp, prcp, prl, opr_parameters%cst(row, col&
&                    ), opr_states%hst(row, col), ql)
          IF (0._sp .LT. prd + l) THEN
            qd = prd + l
          ELSE
            qd = 0._sp
          END IF
          qt = qr + ql + qd
        END IF
      END DO
!$omp end parallel do
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        qup = 0._sp
        qrout = 0._sp
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% [ CYCLE ACTIVE CELL ]
        IF (.NOT.(mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0)) THEN
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
          CALL UPSTREAM_DISCHARGE(mesh%nrow, mesh%ncol, setup%dt, mesh%&
&                           dx(row, col), mesh%dy(row, col), row, col, &
&                           mesh%flwdir, mesh%flwacc, q, qup)
          CALL LINEAR_ROUTING(setup%dt, qup, opr_parameters%lr(row, col)&
&                       , opr_states%hlr(row, col), qrout)
          q(row, col) = (qt(row, col)*mesh%dx(row, col)*mesh%dy(row, col&
&           )+qrout*(mesh%flwacc(row, col)-mesh%dx(row, col)*mesh%dy(row&
&           , col)))*1e-3_sp/setup%dt
        END IF
      END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
      DO g=1,mesh%ng
        output%sim_response%q(g, t) = q(mesh%gauge_pos(g, 1), mesh%&
&         gauge_pos(g, 2))
      END DO
    END DO
  END SUBROUTINE GR_C_FORWARD

  SUBROUTINE GR_D_FORWARD(setup, mesh, input_data, opr_parameters, &
&   opr_states, output, options, returns)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(GR_D_OPR_PARAMETERSDT), INTENT(IN) :: opr_parameters
    TYPE(GR_D_OPR_STATESDT), INTENT(INOUT) :: opr_states
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OPTIONSDT), INTENT(IN) :: options
    TYPE(RETURNSDT), INTENT(INOUT) :: returns
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q, qt
    REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, prr, qr, qup, qrout
    INTEGER :: t, i, row, col, k, g
    INTRINSIC MIN
    INTRINSIC MAX
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!$omp parallel do num_threads(options%comm%ncpu) shared(setup, mesh, input_data, &
!$omp& opr_parameters, opr_states, output, qt), &
!$omp& private(i, ei, pn, en, pr, perc, prr, qr, row, col, prcp, pet)
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialisation for time step (t) and cell (i)
!% =============================================================================================================== %!
        ei = 0._sp
        pn = 0._sp
        en = 0._sp
        pr = 0._sp
        perc = 0._sp
        prr = 0._sp
        qr = 0._sp
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of flow accumulation
!% =========================================================================================================== %!
        row = mesh%path(1, i)
        col = mesh%path(2, i)
        IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, col&
&           )
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
!% [ CYCLE ACTIVE CELL ]
        IF (.NOT.(mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0)) THEN
          IF (setup%sparse_storage) THEN
            prcp = input_data%atmos_data%sparse_prcp(k, t)
            pet = input_data%atmos_data%sparse_pet(k, t)
          ELSE
            prcp = input_data%atmos_data%prcp(row, col, t)
            pet = input_data%atmos_data%pet(row, col, t)
          END IF
!% [ END IF PRCP GAP ]
          IF (prcp .GE. 0 .AND. pet .GE. 0) THEN
            IF (pet .GT. prcp) THEN
              ei = prcp
            ELSE
              ei = pet
            END IF
            IF (0._sp .LT. prcp - ei) THEN
              pn = prcp - ei
            ELSE
              pn = 0._sp
            END IF
            en = pet - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
            CALL GR_PRODUCTION(pn, en, opr_parameters%cp(row, col), &
&                        1000._sp, opr_states%hp(row, col), pr, perc)
          END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
          prr = pr + perc
          CALL GR_TRANSFER(5._sp, prcp, prr, opr_parameters%cft(row, col&
&                    ), opr_states%hft(row, col), qr)
          qt(row, col) = qr
        END IF
      END DO
!$omp end parallel do
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
        qup = 0._sp
        qrout = 0._sp
        row = mesh%path(1, i)
        col = mesh%path(2, i)
!% [ CYCLE ACTIVE CELL ]
        IF (.NOT.(mesh%active_cell(row, col) .EQ. 0 .OR. mesh%&
&           local_active_cell(row, col) .EQ. 0)) THEN
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
          CALL UPSTREAM_DISCHARGE(mesh%nrow, mesh%ncol, setup%dt, mesh%&
&                           dx(row, col), mesh%dy(row, col), row, col, &
&                           mesh%flwdir, mesh%flwacc, q, qup)
          CALL LINEAR_ROUTING(setup%dt, qup, opr_parameters%lr(row, col)&
&                       , opr_states%hlr(row, col), qrout)
          q(row, col) = (qt(row, col)*mesh%dx(row, col)*mesh%dy(row, col&
&           )+qrout*(mesh%flwacc(row, col)-mesh%dx(row, col)*mesh%dy(row&
&           , col)))*1e-3_sp/setup%dt
        END IF
      END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
      DO g=1,mesh%ng
        output%sim_response%q(g, t) = q(mesh%gauge_pos(g, 1), mesh%&
&         gauge_pos(g, 2))
      END DO
    END DO
  END SUBROUTINE GR_D_FORWARD

END MODULE MD_FORWARD_STRUCTURE_DIFF

!  Differentiation of base_forward_run in forward (tangent) mode (with options fixinterface noISIZE):
!   RW status of diff variables: parameters.control.x:(loc) *(parameters.control.x):(loc)
!                output.cost:(loc)
SUBROUTINE BASE_FORWARD_RUN_D(setup, mesh, input_data, parameters, &
& parameters_d, output, output_d, options, returns)
!% only: sp
  USE MD_CONSTANT
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: ParametersDT
  USE MWD_PARAMETERS_DIFF
!% only: Opr_StatesDT
  USE MWD_OPR_STATES
!% only: OutputDT
  USE MWD_OUTPUT_DIFF
!% only: OptionsDT
  USE MWD_OPTIONS
!% only: ReturnsDT
  USE MWD_RETURNS
!% only: map_control_to_parameters
  USE MWD_PARAMETERS_MANIPULATION_DIFF
!% only: gr_a_forward, gr_b_forward, gr_c_forward, gr_d_forward
  USE MD_FORWARD_STRUCTURE_DIFF
!% only: compute_cost
  USE MWD_COST_DIFF
  IMPLICIT NONE
  TYPE(SETUPDT), INTENT(IN) :: setup
  TYPE(MESHDT), INTENT(IN) :: mesh
  TYPE(INPUT_DATADT), INTENT(IN) :: input_data
  TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
  TYPE(PARAMETERSDT_DIFF), INTENT(INOUT) :: parameters_d
  TYPE(OUTPUTDT), INTENT(INOUT) :: output
  TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_d
  TYPE(OPTIONSDT), INTENT(IN) :: options
  TYPE(RETURNSDT), INTENT(INOUT) :: returns
!% Map control to parameters
  CALL MAP_CONTROL_TO_PARAMETERS(setup, mesh, parameters, options)
  CALL GR_A_FORWARD(setup, mesh, input_data, parameters%opr_parameters%&
&             gr_a, output%opr_final_states%gr_a, output, options, &
&             returns)
  CALL COMPUTE_COST(setup, mesh, input_data, parameters, output, options&
&             , returns)
  output_d%cost = 0.0_4
END SUBROUTINE BASE_FORWARD_RUN_D

!  Differentiation of base_forward_run in reverse (adjoint) mode (with options fixinterface noISIZE):
!   RW status of diff variables: parameters.control.x:(loc) *(parameters.control.x):(loc)
!                output.cost:(loc)
SUBROUTINE BASE_FORWARD_RUN_B(setup, mesh, input_data, parameters, &
& parameters_b, output, output_b, options, returns)
!% only: sp
  USE MD_CONSTANT
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: ParametersDT
  USE MWD_PARAMETERS_DIFF
!% only: Opr_StatesDT
  USE MWD_OPR_STATES
!% only: OutputDT
  USE MWD_OUTPUT_DIFF
!% only: OptionsDT
  USE MWD_OPTIONS
!% only: ReturnsDT
  USE MWD_RETURNS
!% only: map_control_to_parameters
  USE MWD_PARAMETERS_MANIPULATION_DIFF
!% only: gr_a_forward, gr_b_forward, gr_c_forward, gr_d_forward
  USE MD_FORWARD_STRUCTURE_DIFF
!% only: compute_cost
  USE MWD_COST_DIFF
  IMPLICIT NONE
  TYPE(SETUPDT), INTENT(IN) :: setup
  TYPE(MESHDT), INTENT(IN) :: mesh
  TYPE(INPUT_DATADT), INTENT(IN) :: input_data
  TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
  TYPE(PARAMETERSDT_DIFF), INTENT(INOUT) :: parameters_b
  TYPE(OUTPUTDT), INTENT(INOUT) :: output
  TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_b
  TYPE(OPTIONSDT), INTENT(IN) :: options
  TYPE(RETURNSDT), INTENT(INOUT) :: returns
!% Map control to parameters
  parameters_b%control%x = 0.0_4
END SUBROUTINE BASE_FORWARD_RUN_B

SUBROUTINE BASE_FORWARD_RUN_NODIFF(setup, mesh, input_data, parameters, &
& output, options, returns)
!% only: sp
  USE MD_CONSTANT
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: ParametersDT
  USE MWD_PARAMETERS_DIFF
!% only: Opr_StatesDT
  USE MWD_OPR_STATES
!% only: OutputDT
  USE MWD_OUTPUT_DIFF
!% only: OptionsDT
  USE MWD_OPTIONS
!% only: ReturnsDT
  USE MWD_RETURNS
!% only: map_control_to_parameters
  USE MWD_PARAMETERS_MANIPULATION_DIFF
!% only: gr_a_forward, gr_b_forward, gr_c_forward, gr_d_forward
  USE MD_FORWARD_STRUCTURE_DIFF
!% only: compute_cost
  USE MWD_COST_DIFF
  IMPLICIT NONE
  TYPE(SETUPDT), INTENT(IN) :: setup
  TYPE(MESHDT), INTENT(IN) :: mesh
  TYPE(INPUT_DATADT), INTENT(IN) :: input_data
  TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
  TYPE(OUTPUTDT), INTENT(INOUT) :: output
  TYPE(OPTIONSDT), INTENT(IN) :: options
  TYPE(RETURNSDT), INTENT(INOUT) :: returns
!% Map control to parameters
  CALL MAP_CONTROL_TO_PARAMETERS(setup, mesh, parameters, options)
  output%opr_final_states = parameters%opr_initial_states
  SELECT CASE  (setup%structure) 
  CASE ('gr_a') 
    CALL GR_A_FORWARD(setup, mesh, input_data, parameters%opr_parameters&
&               %gr_a, output%opr_final_states%gr_a, output, options, &
&               returns)
  CASE ('gr_b') 
    CALL GR_B_FORWARD(setup, mesh, input_data, parameters%opr_parameters&
&               %gr_b, output%opr_final_states%gr_b, output, options, &
&               returns)
  CASE ('gr_c') 
    CALL GR_C_FORWARD(setup, mesh, input_data, parameters%opr_parameters&
&               %gr_c, output%opr_final_states%gr_c, output, options, &
&               returns)
  CASE ('gr_d') 
    CALL GR_D_FORWARD(setup, mesh, input_data, parameters%opr_parameters&
&               %gr_d, output%opr_final_states%gr_d, output, options, &
&               returns)
  END SELECT
  CALL COMPUTE_COST(setup, mesh, input_data, parameters, output, options&
&             , returns)
END SUBROUTINE BASE_FORWARD_RUN_NODIFF

