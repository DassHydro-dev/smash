!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!%      This module `mwd_output` encapsulates all SMASH output.
!%      This module is wrapped and differentiated.
!%      OutputDT type:
!%      
!%      ======================== =======================================
!%      `Variables`              Description
!%      ======================== =======================================
!%      ``qsim``                 Simulated discharge at gauge            [m3/s]
!%      ``qsim_domain``          Simulated discharge whole domain        [m3/s]
!%      ``sparse_qsim_domain``   Sparse simulated discharge whole domain [m3/s]
!%      ``parameters_gradient``  Parameters gradients
!%      ======================== =======================================
MODULE MWD_OUTPUT_DIFF_B
!% only: sp, dp, lchar, np, ns
  USE MWD_COMMON
!% only: SetupDT
  USE MWD_SETUP
!%only: MeshDT
  USE MWD_MESH
  IMPLICIT NONE
  TYPE OUTPUTDT
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: qsim
      REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: qsim_domain
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: sparse_qsim_domain
      REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: parameters_gradient
  END TYPE OUTPUTDT
  TYPE OUTPUTDT_DIFF_B
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: qsim
      REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: qsim_domain
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: sparse_qsim_domain
  END TYPE OUTPUTDT_DIFF_B

CONTAINS
  SUBROUTINE OUTPUTDT_INITIALISE(output, setup, mesh)
    IMPLICIT NONE
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(SETUPDT), INTENT(INOUT) :: setup
    TYPE(MESHDT), INTENT(INOUT) :: mesh
    ALLOCATE(output%qsim(mesh%ng, setup%ntime_step))
    output%qsim = -99._sp
    IF (setup%sparse_storage) THEN
      ALLOCATE(output%sparse_qsim_domain(mesh%nac, setup%ntime_step))
      output%sparse_qsim_domain = -99._sp
    ELSE
      ALLOCATE(output%qsim_domain(mesh%nrow, mesh%ncol, setup%ntime_step&
&     ))
      output%qsim_domain = -99._sp
    END IF
  END SUBROUTINE OUTPUTDT_INITIALISE

!%      TODO comment 
  SUBROUTINE OUTPUT_COPY(output_in, output_out)
    IMPLICIT NONE
    TYPE(OUTPUTDT), INTENT(IN) :: output_in
    TYPE(OUTPUTDT), INTENT(OUT) :: output_out
    output_out = output_in
  END SUBROUTINE OUTPUT_COPY

END MODULE MWD_OUTPUT_DIFF_B

!%    This module `mw_cost` encapsulates all SMASH cost (type, subroutines, functions)
MODULE MWD_COST_DIFF_B
!% only: sp, dp, lchar, np, ns
  USE MWD_COMMON
!% only: SetupDT
  USE MWD_SETUP
!%only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: OutputDT
  USE MWD_OUTPUT_DIFF_B
  IMPLICIT NONE

CONTAINS
!  Differentiation of compute_jobs in reverse (adjoint) mode (with options OpenMP context fixinterface):
!   gradient     of useful results: jobs
!   with respect to varying inputs: *(output.qsim)
!   Plus diff mem management of: output.qsim:in
  SUBROUTINE COMPUTE_JOBS_B(setup, mesh, input_data, output, output_b, &
&   jobs, jobs_b)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT_DIFF_B), INTENT(INOUT) :: output_b
    REAL(sp) :: jobs
    REAL(sp) :: jobs_b
    REAL(sp), DIMENSION(setup%ntime_step-setup%optim_start_step+1) :: qo&
&   , qs
    REAL(sp), DIMENSION(setup%ntime_step-setup%optim_start_step+1) :: &
&   qs_b
    INTEGER :: g, row_g, col_g
    INTRINSIC REAL
    INTRINSIC ANY
    REAL(sp) :: result1
    REAL(sp) :: result1_b
    INTEGER :: branch
    DO g=1,mesh%ng
      qs = output%qsim(g, setup%optim_start_step:setup%ntime_step)*setup&
&       %dt*0.001_sp/mesh%area(g)
      row_g = mesh%gauge_pos(1, g)
      col_g = mesh%gauge_pos(2, g)
      CALL PUSHREAL4ARRAY(qo, setup%ntime_step - setup%optim_start_step &
&                   + 1)
      qo = input_data%qobs(g, setup%optim_start_step:setup%ntime_step)*&
&       setup%dt*0.001_sp/(REAL(mesh%drained_area(row_g, col_g))*(setup%&
&       dx/1000._sp)*(setup%dx/1000._sp))
      IF (ANY(qo .GE. 0._sp)) THEN
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    output_b%qsim = 0.0_4
    DO g=mesh%ng,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        qs_b = 0.0_4
      ELSE
        result1_b = jobs_b
        qs = output%qsim(g, setup%optim_start_step:setup%ntime_step)*&
&         setup%dt*0.001_sp/mesh%area(g)
        CALL NSE_B(qo, qs, qs_b, result1_b)
      END IF
      CALL POPREAL4ARRAY(qo, setup%ntime_step - setup%optim_start_step +&
&                  1)
      output_b%qsim(g, setup%optim_start_step:setup%ntime_step) = &
&       output_b%qsim(g, setup%optim_start_step:setup%ntime_step) + &
&       setup%dt*0.001_sp*qs_b/mesh%area(g)
    END DO
  END SUBROUTINE COMPUTE_JOBS_B

  SUBROUTINE COMPUTE_JOBS(setup, mesh, input_data, output, jobs)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    REAL(sp), INTENT(OUT) :: jobs
    REAL(sp), DIMENSION(setup%ntime_step-setup%optim_start_step+1) :: qo&
&   , qs
    INTEGER :: g, row_g, col_g
    INTRINSIC REAL
    INTRINSIC ANY
    REAL(sp) :: result1
    jobs = 0._sp
    DO g=1,mesh%ng
      qs = output%qsim(g, setup%optim_start_step:setup%ntime_step)*setup&
&       %dt*0.001_sp/mesh%area(g)
      row_g = mesh%gauge_pos(1, g)
      col_g = mesh%gauge_pos(2, g)
      qo = input_data%qobs(g, setup%optim_start_step:setup%ntime_step)*&
&       setup%dt*0.001_sp/(REAL(mesh%drained_area(row_g, col_g))*(setup%&
&       dx/1000._sp)*(setup%dx/1000._sp))
      IF (ANY(qo .GE. 0._sp)) THEN
        result1 = NSE(qo, qs)
        jobs = jobs + result1
      END IF
    END DO
  END SUBROUTINE COMPUTE_JOBS

!  Differentiation of nse in reverse (adjoint) mode (with options OpenMP context fixinterface):
!   gradient     of useful results: res
!   with respect to varying inputs: y
!~         subroutine compute_jreg
!~         end subroutine compute_jreg
  SUBROUTINE NSE_B(x, y, y_b, res_b)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:) :: y_b
    REAL(sp) :: res
    REAL(sp) :: res_b
    REAL(sp) :: sum_x, sum_xx, sum_yy, sum_xy, mean_x, num, den
    REAL(sp) :: sum_yy_b, sum_xy_b, num_b
    INTEGER :: i, n
    INTRINSIC SIZE
    INTEGER :: ad_to
    INTEGER :: branch
!% Metric computation
    n = 0
    sum_x = 0.
    sum_xx = 0.
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0.) THEN
        n = n + 1
        sum_x = sum_x + x(i)
        sum_xx = sum_xx + x(i)*x(i)
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    CALL PUSHINTEGER4(i - 1)
    mean_x = sum_x/n
!% NSE numerator / denominator
    den = sum_xx - n*mean_x*mean_x
!% NSE criterion
    num_b = res_b/den
    sum_yy_b = num_b
    sum_xy_b = -(2*num_b)
    y_b = 0.0_4
    CALL POPINTEGER4(ad_to)
    DO i=ad_to,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) y_b(i) = y_b(i) + x(i)*sum_xy_b + 2*y(i)*&
&         sum_yy_b
    END DO
  END SUBROUTINE NSE_B

!~         subroutine compute_jreg
!~         end subroutine compute_jreg
  FUNCTION NSE(x, y) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp) :: res
    REAL(sp) :: sum_x, sum_xx, sum_yy, sum_xy, mean_x, num, den
    INTEGER :: i, n
    INTRINSIC SIZE
!% Metric computation
    n = 0
    sum_x = 0.
    sum_xx = 0.
    sum_yy = 0.
    sum_xy = 0.
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0.) THEN
        n = n + 1
        sum_x = sum_x + x(i)
        sum_xx = sum_xx + x(i)*x(i)
        sum_yy = sum_yy + y(i)*y(i)
        sum_xy = sum_xy + x(i)*y(i)
      END IF
    END DO
    mean_x = sum_x/n
!% NSE numerator / denominator
    num = sum_xx - 2*sum_xy + sum_yy
    den = sum_xx - n*mean_x*mean_x
!% NSE criterion
    res = num/den
  END FUNCTION NSE

END MODULE MWD_COST_DIFF_B

!%    This module `m_operator` encapsulates all SMASH operator (type, subroutines, functions)
MODULE MD_OPERATOR_DIFF_B
!% only : sp
  USE MWD_COMMON
  IMPLICIT NONE

CONTAINS
!  Differentiation of gr_interception in reverse (adjoint) mode (with options OpenMP context fixinterface):
!   gradient     of useful results: hi ei ci pn
!   with respect to varying inputs: hi ci
!% TODO Renommer argument pour etre global
  SUBROUTINE GR_INTERCEPTION_B(prcp, pet, ci, ci_b, hi, hi_b, pn, pn_b, &
&   ei, ei_b)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: prcp, pet, ci
    REAL(sp) :: ci_b
    REAL(sp), INTENT(INOUT) :: hi
    REAL(sp), INTENT(INOUT) :: hi_b
    REAL(sp) :: pn, ei
    REAL(sp) :: pn_b, ei_b
    INTRINSIC MIN
    INTRINSIC MAX
    REAL(sp) :: temp_b
    INTEGER :: branch
    IF (pet .GT. prcp + hi*ci) THEN
      ei = prcp + hi*ci
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      ei = pet
    END IF
    IF (0._sp .LT. prcp - ci*(1._sp-hi) - ei) THEN
      pn = prcp - ci*(1._sp-hi) - ei
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      pn = 0._sp
    END IF
    temp_b = hi_b/ci
    ei_b = ei_b - temp_b
    pn_b = pn_b - temp_b
    ci_b = ci_b - (prcp-ei-pn)*temp_b/ci
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      ci_b = ci_b - (1._sp-hi)*pn_b
      hi_b = hi_b + ci*pn_b
      ei_b = ei_b - pn_b
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      hi_b = hi_b + ci*ei_b
      ci_b = ci_b + hi*ei_b
    END IF
  END SUBROUTINE GR_INTERCEPTION_B

!% TODO Renommer argument pour etre global
  SUBROUTINE GR_INTERCEPTION(prcp, pet, ci, hi, pn, ei)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: prcp, pet, ci
    REAL(sp), INTENT(INOUT) :: hi
    REAL(sp), INTENT(OUT) :: pn, ei
    INTRINSIC MIN
    INTRINSIC MAX
    IF (pet .GT. prcp + hi*ci) THEN
      ei = prcp + hi*ci
    ELSE
      ei = pet
    END IF
    IF (0._sp .LT. prcp - ci*(1._sp-hi) - ei) THEN
      pn = prcp - ci*(1._sp-hi) - ei
    ELSE
      pn = 0._sp
    END IF
    hi = hi + (prcp-ei-pn)/ci
  END SUBROUTINE GR_INTERCEPTION

!  Differentiation of gr_production in reverse (adjoint) mode (with options OpenMP context fixinterface):
!   gradient     of useful results: hp beta cp perc pr
!   with respect to varying inputs: hp en beta cp pn
  SUBROUTINE GR_PRODUCTION_B(pn, pn_b, en, en_b, cp, cp_b, beta, beta_b&
&   , hp, hp_b, pr, pr_b, perc, perc_b)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: pn, en, cp, beta
    REAL(sp) :: pn_b, en_b, cp_b, beta_b
    REAL(sp), INTENT(INOUT) :: hp
    REAL(sp), INTENT(INOUT) :: hp_b
    REAL(sp) :: pr, perc
    REAL(sp) :: pr_b, perc_b
    REAL(sp) :: inv_cp, ps, es, hp_imd
    REAL(sp) :: inv_cp_b, ps_b, es_b, hp_imd_b
    INTRINSIC TANH
    REAL(sp) :: temp
    REAL(sp) :: temp0
    REAL(sp) :: temp_b
    REAL(sp) :: temp1
    REAL(sp) :: temp2
    REAL(sp) :: temp3
    REAL(sp) :: temp_b0
    REAL(sp) :: temp_b1
    REAL(sp) :: temp4
    REAL(sp) :: temp_b2
    REAL(sp) :: temp_b3
    REAL(sp) :: temp_b4
    REAL(sp) :: temp5
    REAL(sp) :: temp_b5
    INTEGER :: branch
    inv_cp = 1._sp/cp
    ps = cp*(1._sp-hp*hp)*TANH(pn*inv_cp)/(1._sp+hp*TANH(pn*inv_cp))
    es = hp*cp*(2._sp-hp)*TANH(en*inv_cp)/(1._sp+(1._sp-hp)*TANH(en*&
&     inv_cp))
    hp_imd = hp + (ps-es)*inv_cp
    IF (pn .GT. 0) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    perc = hp_imd*cp*(1._sp-(1._sp+(hp_imd/beta)**4)**(-0.25_sp))
    perc_b = perc_b - inv_cp*hp_b
    temp5 = hp_imd/beta
    temp4 = temp5**4 + 1._sp
    temp_b0 = (1._sp-temp4**(-0.25_sp))*perc_b
    temp_b5 = 4*temp5**3*0.25_sp*temp4**(-1.25)*hp_imd*cp*perc_b/beta
    hp_imd_b = hp_b + temp_b5 + cp*temp_b0
    inv_cp_b = -(perc*hp_b)
    beta_b = beta_b - temp5*temp_b5
    cp_b = cp_b + hp_imd*temp_b0
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      pn_b = pr_b
      hp_imd_b = hp_imd_b - cp*pr_b
      hp_b = cp*pr_b
      cp_b = cp_b - (hp_imd-hp)*pr_b
    ELSE
      hp_b = 0.0_4
      pn_b = 0.0_4
    END IF
    es_b = -(inv_cp*hp_imd_b)
    temp4 = TANH(en*inv_cp)
    temp3 = (-hp+1._sp)*temp4 + 1._sp
    temp1 = TANH(en*inv_cp)
    temp0 = hp*cp*(-hp+2._sp)
    temp_b3 = es_b/temp3
    temp_b = (2._sp-hp)*temp1*temp_b3
    temp_b0 = -(temp0*temp1*temp_b3/temp3)
    hp_b = hp_b + hp_imd_b + cp*temp_b - hp*cp*temp1*temp_b3 - temp4*&
&     temp_b0
    ps_b = inv_cp*hp_imd_b
    temp_b4 = (1.0-TANH(en*inv_cp)**2)*temp0*temp_b3
    temp_b5 = (1.0-TANH(en*inv_cp)**2)*(1._sp-hp)*temp_b0
    en_b = inv_cp*temp_b5 + inv_cp*temp_b4
    cp_b = cp_b + hp*temp_b
    temp = TANH(pn*inv_cp)
    temp0 = hp*temp + 1._sp
    temp1 = TANH(pn*inv_cp)
    temp2 = cp*(-(hp*hp)+1._sp)
    temp_b = ps_b/temp0
    temp_b0 = (1.0-TANH(pn*inv_cp)**2)*temp2*temp_b
    temp_b1 = -(temp2*temp1*temp_b/temp0)
    hp_b = hp_b + temp*temp_b1 - 2*hp*cp*temp1*temp_b
    temp_b2 = (1.0-TANH(pn*inv_cp)**2)*hp*temp_b1
    inv_cp_b = inv_cp_b + (ps-es)*hp_imd_b + en*temp_b5 + en*temp_b4 + &
&     pn*temp_b2 + pn*temp_b0
    cp_b = cp_b + (1._sp-hp**2)*temp1*temp_b - inv_cp_b/cp**2
    pn_b = pn_b + inv_cp*temp_b2 + inv_cp*temp_b0
  END SUBROUTINE GR_PRODUCTION_B

  SUBROUTINE GR_PRODUCTION(pn, en, cp, beta, hp, pr, perc)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: pn, en, cp, beta
    REAL(sp), INTENT(INOUT) :: hp
    REAL(sp), INTENT(OUT) :: pr, perc
    REAL(sp) :: inv_cp, ps, es, hp_imd
    INTRINSIC TANH
    inv_cp = 1._sp/cp
    pr = 0._sp
    ps = cp*(1._sp-hp*hp)*TANH(pn*inv_cp)/(1._sp+hp*TANH(pn*inv_cp))
    es = hp*cp*(2._sp-hp)*TANH(en*inv_cp)/(1._sp+(1._sp-hp)*TANH(en*&
&     inv_cp))
    hp_imd = hp + (ps-es)*inv_cp
    IF (pn .GT. 0) pr = pn - (hp_imd-hp)*cp
    perc = hp_imd*cp*(1._sp-(1._sp+(hp_imd/beta)**4)**(-0.25_sp))
    hp = hp_imd - perc*inv_cp
  END SUBROUTINE GR_PRODUCTION

!  Differentiation of gr_exchange in reverse (adjoint) mode (with options OpenMP context fixinterface):
!   gradient     of useful results: l hft exc
!   with respect to varying inputs: hft exc
  SUBROUTINE GR_EXCHANGE_B(exc, exc_b, hft, hft_b, l, l_b)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: exc
    REAL(sp) :: exc_b
    REAL(sp), INTENT(INOUT) :: hft
    REAL(sp), INTENT(INOUT) :: hft_b
    REAL(sp) :: l
    REAL(sp) :: l_b
    exc_b = exc_b + hft**3.5_sp*l_b
    hft_b = hft_b + 3.5_sp*hft**2.5*exc*l_b
  END SUBROUTINE GR_EXCHANGE_B

  SUBROUTINE GR_EXCHANGE(exc, hft, l)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: exc
    REAL(sp), INTENT(INOUT) :: hft
    REAL(sp), INTENT(OUT) :: l
    l = exc*hft**3.5_sp
  END SUBROUTINE GR_EXCHANGE

!  Differentiation of gr_transfern in reverse (adjoint) mode (with options OpenMP context fixinterface):
!   gradient     of useful results: q ht ct
!   with respect to varying inputs: ht ct pr
  SUBROUTINE GR_TRANSFERN_B(n, prcp, pr, pr_b, ct, ct_b, ht, ht_b, q, &
&   q_b)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: n, prcp, pr, ct
    REAL(sp) :: pr_b, ct_b
    REAL(sp), INTENT(INOUT) :: ht
    REAL(sp), INTENT(INOUT) :: ht_b
    REAL(sp) :: q
    REAL(sp) :: q_b
    REAL(sp) :: pr_imd, ht_imd, nm1, d1pnm1
    REAL(sp) :: pr_imd_b, ht_imd_b
    INTRINSIC MAX
    REAL(sp) :: temp_b
    REAL(sp) :: temp
    REAL(sp) :: temp_b0
    INTEGER :: branch
    nm1 = n - 1._sp
    d1pnm1 = 1._sp/nm1
    IF (prcp .LT. 0._sp) THEN
      pr_imd = ((ht*ct)**(-nm1)-ct**(-nm1))**(-d1pnm1) - ht*ct
      CALL PUSHCONTROL1B(1)
    ELSE
      pr_imd = pr
      CALL PUSHCONTROL1B(0)
    END IF
    IF (1.e-6_sp .LT. ht + pr_imd/ct) THEN
      ht_imd = ht + pr_imd/ct
      CALL PUSHCONTROL1B(0)
    ELSE
      ht_imd = 1.e-6_sp
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL4(ht)
    ht = ((ht_imd*ct)**(-nm1)+ct**(-nm1))**(-d1pnm1)/ct
    ht_b = ht_b - ct*q_b
    temp = (ht_imd*ct)**(-nm1) + ct**(-nm1)
    IF (temp .LE. 0.0 .AND. (-d1pnm1 .EQ. 0.0 .OR. -d1pnm1 .NE. INT(-&
&       d1pnm1))) THEN
      temp_b0 = 0.0_4
    ELSE
      temp_b0 = -(d1pnm1*temp**((-1)-d1pnm1)*ht_b/ct)
    END IF
    IF (ht_imd*ct .LE. 0.0 .AND. (-nm1 .EQ. 0.0 .OR. -nm1 .NE. INT(-nm1)&
&       )) THEN
      temp_b = 0.0_4
    ELSE
      temp_b = -(nm1*(ht_imd*ct)**((-1)-nm1)*temp_b0)
    END IF
    ht_imd_b = ct*q_b + ct*temp_b
    IF (ct .LE. 0.0 .AND. (-nm1 .EQ. 0.0 .OR. -nm1 .NE. INT(-nm1))) THEN
      ct_b = ct_b + (ht_imd-ht)*q_b + ht_imd*temp_b - temp**(-d1pnm1)*&
&       ht_b/ct**2
    ELSE
      ct_b = ct_b + (ht_imd-ht)*q_b + ht_imd*temp_b - temp**(-d1pnm1)*&
&       ht_b/ct**2 - nm1*ct**((-1)-nm1)*temp_b0
    END IF
    CALL POPREAL4(ht)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      ht_b = ht_imd_b
      pr_imd_b = ht_imd_b/ct
      ct_b = ct_b - pr_imd*ht_imd_b/ct**2
    ELSE
      ht_b = 0.0_4
      pr_imd_b = 0.0_4
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      pr_b = pr_imd_b
    ELSE
      IF ((ht*ct)**(-nm1) - ct**(-nm1) .LE. 0.0 .AND. (-d1pnm1 .EQ. 0.0 &
&         .OR. -d1pnm1 .NE. INT(-d1pnm1))) THEN
        temp_b = 0.0_4
      ELSE
        temp_b = -(d1pnm1*((ht*ct)**(-nm1)-ct**(-nm1))**((-1)-d1pnm1)*&
&         pr_imd_b)
      END IF
      IF (ht*ct .LE. 0.0 .AND. (-nm1 .EQ. 0.0 .OR. -nm1 .NE. INT(-nm1))&
&     ) THEN
        temp_b0 = 0.0_4
      ELSE
        temp_b0 = -(nm1*(ht*ct)**((-1)-nm1)*temp_b)
      END IF
      ht_b = ht_b + ct*temp_b0 - ct*pr_imd_b
      IF (ct .LE. 0.0 .AND. (-nm1 .EQ. 0.0 .OR. -nm1 .NE. INT(-nm1))) &
&     THEN
        ct_b = ct_b + ht*temp_b0 - ht*pr_imd_b
      ELSE
        ct_b = ct_b + nm1*ct**((-1)-nm1)*temp_b - ht*pr_imd_b + ht*&
&         temp_b0
      END IF
      pr_b = 0.0_4
    END IF
  END SUBROUTINE GR_TRANSFERN_B

  SUBROUTINE GR_TRANSFERN(n, prcp, pr, ct, ht, q)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: n, prcp, pr, ct
    REAL(sp), INTENT(INOUT) :: ht
    REAL(sp), INTENT(OUT) :: q
    REAL(sp) :: pr_imd, ht_imd, nm1, d1pnm1
    INTRINSIC MAX
    nm1 = n - 1._sp
    d1pnm1 = 1._sp/nm1
    IF (prcp .LT. 0._sp) THEN
      pr_imd = ((ht*ct)**(-nm1)-ct**(-nm1))**(-d1pnm1) - ht*ct
    ELSE
      pr_imd = pr
    END IF
    IF (1.e-6_sp .LT. ht + pr_imd/ct) THEN
      ht_imd = ht + pr_imd/ct
    ELSE
      ht_imd = 1.e-6_sp
    END IF
    ht = ((ht_imd*ct)**(-nm1)+ct**(-nm1))**(-d1pnm1)/ct
    q = (ht_imd-ht)*ct
  END SUBROUTINE GR_TRANSFERN

!  Differentiation of upstream_discharge in reverse (adjoint) mode (with options OpenMP context fixinterface):
!   gradient     of useful results: q qup
!   with respect to varying inputs: q
  SUBROUTINE UPSTREAM_DISCHARGE_B(dt, dx, ntime_step, nrow, ncol, flow, &
&   drained_area, row, col, t, q, q_b, qup, qup_b)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt, dx
    INTEGER, INTENT(IN) :: ntime_step, nrow, ncol, row, col, t
    INTEGER, DIMENSION(nrow, ncol), INTENT(IN) :: flow, drained_area
    REAL(sp), DIMENSION(nrow, ncol, ntime_step), INTENT(IN) :: q
    REAL(sp), DIMENSION(nrow, ncol, ntime_step) :: q_b
    REAL(sp) :: qup
    REAL(sp) :: qup_b
    INTEGER :: i, row_imd, col_imd
    INTEGER, DIMENSION(8), SAVE :: dcol=(/0, -1, -1, -1, 0, 1, 1, 1/)
    INTEGER, DIMENSION(8), SAVE :: drow=(/1, 1, 0, -1, -1, -1, 0, 1/)
    INTEGER, DIMENSION(8), SAVE :: dkind=(/1, 2, 3, 4, 5, 6, 7, 8/)
    INTRINSIC REAL
    INTEGER :: branch
    IF (drained_area(row, col) .GT. 1) THEN
      DO i=1,8
        col_imd = col + dcol(i)
        row_imd = row + drow(i)
        IF (col_imd .GT. 0 .AND. col_imd .LE. ncol .AND. row_imd .GT. 0 &
&           .AND. row_imd .LE. nrow) THEN
          IF (flow(row_imd, col_imd) .EQ. dkind(i)) THEN
            CALL PUSHCONTROL2B(2)
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(0)
        END IF
      END DO
      qup_b = dt*qup_b/(0.001_sp*dx**2*REAL(drained_area(row, col)-1))
      DO i=8,1,-1
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .NE. 1) THEN
            row_imd = row + drow(i)
            col_imd = col + dcol(i)
            q_b(row_imd, col_imd, t) = q_b(row_imd, col_imd, t) + qup_b
          END IF
        END IF
      END DO
    END IF
  END SUBROUTINE UPSTREAM_DISCHARGE_B

  SUBROUTINE UPSTREAM_DISCHARGE(dt, dx, ntime_step, nrow, ncol, flow, &
&   drained_area, row, col, t, q, qup)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt, dx
    INTEGER, INTENT(IN) :: ntime_step, nrow, ncol, row, col, t
    INTEGER, DIMENSION(nrow, ncol), INTENT(IN) :: flow, drained_area
    REAL(sp), DIMENSION(nrow, ncol, ntime_step), INTENT(IN) :: q
    REAL(sp), INTENT(OUT) :: qup
    INTEGER :: i, row_imd, col_imd
    INTEGER, DIMENSION(8), SAVE :: dcol=(/0, -1, -1, -1, 0, 1, 1, 1/)
    INTEGER, DIMENSION(8), SAVE :: drow=(/1, 1, 0, -1, -1, -1, 0, 1/)
    INTEGER, DIMENSION(8), SAVE :: dkind=(/1, 2, 3, 4, 5, 6, 7, 8/)
    INTRINSIC REAL
    qup = 0._sp
    IF (drained_area(row, col) .GT. 1) THEN
      DO i=1,8
        col_imd = col + dcol(i)
        row_imd = row + drow(i)
        IF (col_imd .GT. 0 .AND. col_imd .LE. ncol .AND. row_imd .GT. 0 &
&           .AND. row_imd .LE. nrow) THEN
          IF (flow(row_imd, col_imd) .EQ. dkind(i)) qup = qup + q(&
&             row_imd, col_imd, t)
        END IF
      END DO
      qup = qup*dt/(0.001_sp*dx*dx*REAL(drained_area(row, col)-1))
    END IF
  END SUBROUTINE UPSTREAM_DISCHARGE

!  Differentiation of sparse_upstream_discharge in reverse (adjoint) mode (with options OpenMP context fixinterface):
!   gradient     of useful results: q qup
!   with respect to varying inputs: q
  SUBROUTINE SPARSE_UPSTREAM_DISCHARGE_B(dt, dx, ntime_step, nrow, ncol&
&   , nac, flow, drained_area, ind_sparse, row, col, t, q, q_b, qup, &
&   qup_b)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt, dx
    INTEGER, INTENT(IN) :: ntime_step, nrow, ncol, nac, row, col, t
    INTEGER, DIMENSION(nrow, ncol), INTENT(IN) :: flow, drained_area, &
&   ind_sparse
    REAL(sp), DIMENSION(nac, ntime_step), INTENT(IN) :: q
    REAL(sp), DIMENSION(nac, ntime_step) :: q_b
    REAL(sp) :: qup
    REAL(sp) :: qup_b
    INTEGER :: i, row_imd, col_imd, k
    INTEGER, DIMENSION(8), SAVE :: dcol=(/0, -1, -1, -1, 0, 1, 1, 1/)
    INTEGER, DIMENSION(8), SAVE :: drow=(/1, 1, 0, -1, -1, -1, 0, 1/)
    INTEGER, DIMENSION(8), SAVE :: dkind=(/1, 2, 3, 4, 5, 6, 7, 8/)
    INTRINSIC REAL
    INTEGER :: branch
    IF (drained_area(row, col) .GT. 1) THEN
      DO i=1,8
        col_imd = col + dcol(i)
        row_imd = row + drow(i)
        IF (col_imd .GT. 0 .AND. col_imd .LE. ncol .AND. row_imd .GT. 0 &
&           .AND. row_imd .LE. nrow) THEN
          IF (flow(row_imd, col_imd) .EQ. dkind(i)) THEN
            CALL PUSHCONTROL2B(2)
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(0)
        END IF
      END DO
      qup_b = dt*qup_b/(0.001_sp*dx**2*REAL(drained_area(row, col)-1))
      DO i=8,1,-1
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .NE. 1) THEN
            row_imd = row + drow(i)
            col_imd = col + dcol(i)
            k = ind_sparse(row_imd, col_imd)
            q_b(k, t) = q_b(k, t) + qup_b
          END IF
        END IF
      END DO
    END IF
  END SUBROUTINE SPARSE_UPSTREAM_DISCHARGE_B

  SUBROUTINE SPARSE_UPSTREAM_DISCHARGE(dt, dx, ntime_step, nrow, ncol, &
&   nac, flow, drained_area, ind_sparse, row, col, t, q, qup)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt, dx
    INTEGER, INTENT(IN) :: ntime_step, nrow, ncol, nac, row, col, t
    INTEGER, DIMENSION(nrow, ncol), INTENT(IN) :: flow, drained_area, &
&   ind_sparse
    REAL(sp), DIMENSION(nac, ntime_step), INTENT(IN) :: q
    REAL(sp), INTENT(OUT) :: qup
    INTEGER :: i, row_imd, col_imd, k
    INTEGER, DIMENSION(8), SAVE :: dcol=(/0, -1, -1, -1, 0, 1, 1, 1/)
    INTEGER, DIMENSION(8), SAVE :: drow=(/1, 1, 0, -1, -1, -1, 0, 1/)
    INTEGER, DIMENSION(8), SAVE :: dkind=(/1, 2, 3, 4, 5, 6, 7, 8/)
    INTRINSIC REAL
    qup = 0._sp
    IF (drained_area(row, col) .GT. 1) THEN
      DO i=1,8
        col_imd = col + dcol(i)
        row_imd = row + drow(i)
        IF (col_imd .GT. 0 .AND. col_imd .LE. ncol .AND. row_imd .GT. 0 &
&           .AND. row_imd .LE. nrow) THEN
          IF (flow(row_imd, col_imd) .EQ. dkind(i)) THEN
            k = ind_sparse(row_imd, col_imd)
            qup = qup + q(k, t)
          END IF
        END IF
      END DO
      qup = qup*dt/(0.001_sp*dx*dx*REAL(drained_area(row, col)-1))
    END IF
  END SUBROUTINE SPARSE_UPSTREAM_DISCHARGE

!  Differentiation of gr_transfer1 in reverse (adjoint) mode (with options OpenMP context fixinterface):
!   gradient     of useful results: hr qrout lr
!   with respect to varying inputs: qup hr lr
  SUBROUTINE GR_TRANSFER1_B(dt, qup, qup_b, lr, lr_b, hr, hr_b, qrout, &
&   qrout_b)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt
    REAL(sp), INTENT(IN) :: qup, lr
    REAL(sp) :: qup_b, lr_b
    REAL(sp), INTENT(INOUT) :: hr
    REAL(sp), INTENT(INOUT) :: hr_b
    REAL(sp) :: qrout
    REAL(sp) :: qrout_b
    REAL(sp) :: hr_imd
    REAL(sp) :: hr_imd_b
    INTRINSIC EXP
    REAL(sp) :: temp
    hr_imd = hr + qup
    temp = dt/(60._sp*lr)
    hr_b = hr_b - qrout_b
    hr_imd_b = qrout_b + EXP(-temp)*hr_b
    lr_b = lr_b + temp*EXP(-temp)*hr_imd*hr_b/lr
    hr_b = hr_imd_b
    qup_b = hr_imd_b
  END SUBROUTINE GR_TRANSFER1_B

  SUBROUTINE GR_TRANSFER1(dt, qup, lr, hr, qrout)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt
    REAL(sp), INTENT(IN) :: qup, lr
    REAL(sp), INTENT(INOUT) :: hr
    REAL(sp), INTENT(OUT) :: qrout
    REAL(sp) :: hr_imd
    INTRINSIC EXP
    hr_imd = hr + qup
    hr = hr_imd*EXP(-(dt/(lr*60._sp)))
    qrout = hr_imd - hr
  END SUBROUTINE GR_TRANSFER1

END MODULE MD_OPERATOR_DIFF_B

!%      This module `mwd_states` encapsulates all SMASH states.
!%      This module is wrapped and differentiated.
!%      StatesDT type:
!%      
!%      ======================== =======================================
!%      `Variables`              Description
!%      ======================== =======================================
!%      ``hi``                   Interception state    [-]   (default: 0.01)   ]0, 1[
!%      ``hp``                   Production state      [-]   (default: 0.01)   ]0, 1[
!%      ``hft``                  Fast transfer state   [-]   (default: 0.01)   ]0, 1[
!%      ``hst``                  Slow transfer state   [-]   (default: 0.01)   ]0, 1[
!%      ``hlr``                  Linear routing state  [mm]  (default: 0.01)   ]0, +Inf[
!%      ======================== =======================================
MODULE MWD_STATES_DIFF_B
!% only: sp, dp, lchar, np, ns
  USE MWD_COMMON
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
  IMPLICIT NONE
  TYPE STATESDT
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hi
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hp
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hft
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hst
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hlr
  END TYPE STATESDT

CONTAINS
  SUBROUTINE STATESDT_INITIALISE(states, setup, mesh)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(STATESDT), INTENT(INOUT) :: states
    INTEGER :: nrow, ncol
    nrow = mesh%nrow
    ncol = mesh%ncol
    ALLOCATE(states%hi(nrow, ncol))
    ALLOCATE(states%hp(nrow, ncol))
    ALLOCATE(states%hft(nrow, ncol))
    ALLOCATE(states%hst(nrow, ncol))
    ALLOCATE(states%hlr(nrow, ncol))
    CALL VECTOR_TO_STATES(setup%default_states, states)
  END SUBROUTINE STATESDT_INITIALISE

!%      TODO comment       
  SUBROUTINE STATES_COPY(states_in, states_out)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(IN) :: states_in
    TYPE(STATESDT), INTENT(OUT) :: states_out
    states_out = states_in
  END SUBROUTINE STATES_COPY

!%      TODO comment 
  SUBROUTINE STATES_TO_MATRIX(states, matrix)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(IN) :: states
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(states%hp, 1), SIZE(states%hp, 2), ns), &
&   INTENT(INOUT) :: matrix
    matrix(:, :, 1) = states%hi(:, :)
    matrix(:, :, 2) = states%hp(:, :)
    matrix(:, :, 3) = states%hft(:, :)
    matrix(:, :, 4) = states%hst(:, :)
    matrix(:, :, 5) = states%hlr(:, :)
  END SUBROUTINE STATES_TO_MATRIX

!%      TODO comment
  SUBROUTINE MATRIX_TO_STATES(matrix, states)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(INOUT) :: states
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(states%hp, 1), SIZE(states%hp, 2), ns), &
&   INTENT(IN) :: matrix
    states%hi(:, :) = matrix(:, :, 1)
    states%hp(:, :) = matrix(:, :, 2)
    states%hft(:, :) = matrix(:, :, 3)
    states%hst(:, :) = matrix(:, :, 4)
    states%hlr(:, :) = matrix(:, :, 5)
  END SUBROUTINE MATRIX_TO_STATES

!%      TODO comment
  SUBROUTINE VECTOR_TO_STATES(vector, states)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(INOUT) :: states
    REAL(sp), DIMENSION(ns), INTENT(IN) :: vector
    states%hi = vector(1)
    states%hp = vector(2)
    states%hft = vector(3)
    states%hst = vector(4)
    states%hlr = vector(5)
  END SUBROUTINE VECTOR_TO_STATES

END MODULE MWD_STATES_DIFF_B

!%      This module `mwd_parameters` encapsulates all SMASH parameters.
!%      This module is wrapped and differentiated.
!%      ParametersDT type:
!%      
!%      ======================== =======================================
!%      `Variables`              Description
!%      ======================== =======================================
!%      ``ci``                   Interception parameter          [mm]    (default: 1)     ]0, +Inf[
!%      ``cp``                   Production parameter            [mm]    (default: 200)   ]0, +Inf[
!%      ``beta``                 Percolation parameter           [-]     (default: 1000)  ]0, +Inf[
!%      ``cft``                  Fast transfer parameter         [mm]    (default: 500)   ]0, +Inf[
!%      ``cst``                  Slow transfer parameter         [mm]    (default: 500)   ]0, +Inf[
!%      ``alpha``                Transfer partitioning parameter [-]     (default: 0.9)   ]0, 1[
!%      ``exc``                  Exchange parameter              [mm/dt] (default: 0)     ]-Inf, +Inf[
!%      ``lr``                   Linear routing parameter        [min]   (default: 5)     ]0, +Inf[
!%      ======================== =======================================
MODULE MWD_PARAMETERS_DIFF_B
!% only: sp, dp, lchar, np, ns
  USE MWD_COMMON
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
  IMPLICIT NONE
  TYPE PARAMETERSDT
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: ci
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cp
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: beta
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cft
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cst
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: alpha
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: exc
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: lr
  END TYPE PARAMETERSDT

CONTAINS
  SUBROUTINE PARAMETERSDT_INITIALISE(parameters, setup, mesh)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    INTEGER :: nrow, ncol
    nrow = mesh%nrow
    ncol = mesh%ncol
    ALLOCATE(parameters%ci(nrow, ncol))
    ALLOCATE(parameters%cp(nrow, ncol))
    ALLOCATE(parameters%beta(nrow, ncol))
    ALLOCATE(parameters%cft(nrow, ncol))
    ALLOCATE(parameters%cst(nrow, ncol))
    ALLOCATE(parameters%alpha(nrow, ncol))
    ALLOCATE(parameters%exc(nrow, ncol))
    ALLOCATE(parameters%lr(nrow, ncol))
    CALL VECTOR_TO_PARAMETERS(setup%default_parameters, parameters)
  END SUBROUTINE PARAMETERSDT_INITIALISE

!%      TODO comment  
  SUBROUTINE PARAMETERS_COPY(parameters_in, parameters_out)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters_in
    TYPE(PARAMETERSDT), INTENT(OUT) :: parameters_out
    parameters_out = parameters_in
  END SUBROUTINE PARAMETERS_COPY

!%      TODO comment  
  SUBROUTINE PARAMETERS_TO_MATRIX(parameters, matrix)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(parameters%cp, 1), SIZE(parameters%cp, 2), &
&   np), INTENT(INOUT) :: matrix
    matrix(:, :, 1) = parameters%ci(:, :)
    matrix(:, :, 2) = parameters%cp(:, :)
    matrix(:, :, 3) = parameters%beta(:, :)
    matrix(:, :, 4) = parameters%cft(:, :)
    matrix(:, :, 5) = parameters%cst(:, :)
    matrix(:, :, 6) = parameters%alpha(:, :)
    matrix(:, :, 7) = parameters%exc(:, :)
    matrix(:, :, 8) = parameters%lr(:, :)
  END SUBROUTINE PARAMETERS_TO_MATRIX

!%      TODO comment  
  SUBROUTINE MATRIX_TO_PARAMETERS(matrix, parameters)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(parameters%cp, 1), SIZE(parameters%cp, 2), &
&   np), INTENT(IN) :: matrix
    parameters%ci(:, :) = matrix(:, :, 1)
    parameters%cp(:, :) = matrix(:, :, 2)
    parameters%beta(:, :) = matrix(:, :, 3)
    parameters%cft(:, :) = matrix(:, :, 4)
    parameters%cst(:, :) = matrix(:, :, 5)
    parameters%alpha(:, :) = matrix(:, :, 6)
    parameters%exc(:, :) = matrix(:, :, 7)
    parameters%lr(:, :) = matrix(:, :, 8)
  END SUBROUTINE MATRIX_TO_PARAMETERS

!%      TODO comment  
  SUBROUTINE VECTOR_TO_PARAMETERS(vector, parameters)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    REAL(sp), DIMENSION(np), INTENT(IN) :: vector
    parameters%ci = vector(1)
    parameters%cp = vector(2)
    parameters%beta = vector(3)
    parameters%cft = vector(4)
    parameters%cst = vector(5)
    parameters%alpha = vector(6)
    parameters%exc = vector(7)
    parameters%lr = vector(8)
  END SUBROUTINE VECTOR_TO_PARAMETERS

END MODULE MWD_PARAMETERS_DIFF_B

SUBROUTINE FORWARD_NODIFF_B(setup, mesh, input_data, parameters, states, &
& output, cost)
!% =================================================================================================================== %!
!%   Module import ('only' commented because of issues in adjoint model)
!% =================================================================================================================== %!
!% only: sp
  USE MWD_COMMON
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: ParametersDT
  USE MWD_PARAMETERS_DIFF_B
!% only: StatesDT
  USE MWD_STATES_DIFF_B
!% only: OutputDT
  USE MWD_OUTPUT_DIFF_B
!% only: GR_interception, GR_production, GR_exchange, &
  USE MD_OPERATOR_DIFF_B
!% & GR_transferN, upstream_discharge, sparse_upstream_discharge, GR_transfer1
!% only: compute_jobs
  USE MWD_COST_DIFF_B
  IMPLICIT NONE
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
  TYPE(SETUPDT), INTENT(IN) :: setup
  TYPE(MESHDT), INTENT(IN) :: mesh
  TYPE(INPUT_DATADT), INTENT(IN) :: input_data
  TYPE(PARAMETERSDT), INTENT(IN) :: parameters
  TYPE(STATESDT), INTENT(INOUT) :: states
  TYPE(OUTPUTDT), INTENT(INOUT) :: output
  REAL(sp), INTENT(INOUT) :: cost
!% =================================================================================================================== %!
!%   Local Variables (private)
!===================================================================================================================== %!
  INTEGER :: t, i, row, col, k, g
  REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prd, qd, qr, ql, &
& qt, qup, qrout
  INTRINSIC MIN
  INTRINSIC MAX
  INTRINSIC REAL
  cost = 0._sp
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
  DO t=1,setup%ntime_step
!% [ DO SPACE ]
    DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialization for time step (t) and cell (i)
!% =============================================================================================================== %!
      ei = 0._sp
      pn = 0._sp
      en = 0._sp
      pr = 0._sp
      perc = 0._sp
      l = 0._sp
      prr = 0._sp
      prd = 0._sp
      qd = 0._sp
      qr = 0._sp
      ql = 0._sp
      qup = 0._sp
      qrout = 0._sp
!% [ END IF PATH ]
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of drained area 
!% =========================================================================================================== %!
      IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
!% [ IF PATH ]
        row = mesh%path(1, i)
        col = mesh%path(2, i)
        IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, col&
&           )
!% [ END IF ACTIVE CELL ]
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
        IF (mesh%global_active_cell(row, col) .EQ. 1 .AND. mesh%&
&           local_active_cell(row, col) .EQ. 1) THEN
!% [ IF ACTIVE CELL ]
          IF (setup%sparse_storage) THEN
            prcp = input_data%sparse_prcp(k, t)
            pet = input_data%sparse_pet(k, t)
          ELSE
            prcp = input_data%prcp(row, col, t)
            pet = input_data%pet(row, col, t)
          END IF
!% [ END IF PRCP GAP ]
          IF (prcp .GE. 0) THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module case [ 0 - 1 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%interception_module) 
            CASE (0) 
              IF (pet .GT. prcp) THEN
                ei = prcp
              ELSE
                ei = pet
              END IF
              IF (0._sp .LT. prcp - ei) THEN
                pn = prcp - ei
              ELSE
                pn = 0._sp
              END IF
            CASE (1) 
              CALL GR_INTERCEPTION(prcp, pet, parameters%ci(row, col), &
&                            states%hi(row, col), pn, ei)
            END SELECT
            en = pet - ei
!% =============================================================================================== %!
!%   Production module case [ 0 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%production_module) 
            CASE (0) 
              CALL GR_PRODUCTION(pn, en, parameters%cp(row, col), &
&                          parameters%beta(row, col), states%hp(row, col&
&                          ), pr, perc)
            END SELECT
!% =============================================================================================== %!
!%   Exchange module case [ 0 - 1 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%exchange_module) 
            CASE (0) 
              l = 0._sp
            CASE (1) 
              CALL GR_EXCHANGE(parameters%exc(row, col), states%hft(row&
&                        , col), l)
            END SELECT
          END IF
!% =================================================================================================== %!
!%   Transfer module case [ 0 ]
!% =================================================================================================== %!
          SELECT CASE  (setup%transfer_module) 
          CASE (0) 
            prr = parameters%alpha(row, col)*(pr+perc) + l
            prd = pr + perc - prr
            CALL GR_TRANSFERN(5._sp, prcp, prr, parameters%cft(row, col)&
&                       , states%hft(row, col), qr)
            IF (0._sp .LT. prd + l) THEN
              qd = prd + l
            ELSE
              qd = 0._sp
            END IF
          END SELECT
          qt = qd + qr + ql
!% =================================================================================================== %!
!%   Routing module case [ 0 - 1 ]
!% =================================================================================================== %!
          SELECT CASE  (setup%routing_module) 
          CASE (0) 
            IF (setup%sparse_storage) THEN
              CALL SPARSE_UPSTREAM_DISCHARGE(setup%dt, setup%dx, setup%&
&                                      ntime_step, mesh%nrow, mesh%ncol&
&                                      , mesh%nac, mesh%flow, mesh%&
&                                      drained_area, mesh%&
&                                      rowcol_to_ind_sparse, row, col, t&
&                                      , output%sparse_qsim_domain, qup)
              output%sparse_qsim_domain(k, t) = (qt+qup*REAL(mesh%&
&               drained_area(row, col)-1))*setup%dx*setup%dx*0.001_sp/&
&               setup%dt
            ELSE
              CALL UPSTREAM_DISCHARGE(setup%dt, setup%dx, setup%&
&                               ntime_step, mesh%nrow, mesh%ncol, mesh%&
&                               flow, mesh%drained_area, row, col, t, &
&                               output%qsim_domain, qup)
              output%qsim_domain(row, col, t) = (qt+qup*REAL(mesh%&
&               drained_area(row, col)-1))*setup%dx*setup%dx*0.001_sp/&
&               setup%dt
            END IF
          CASE (1) 
            IF (setup%sparse_storage) THEN
              CALL SPARSE_UPSTREAM_DISCHARGE(setup%dt, setup%dx, setup%&
&                                      ntime_step, mesh%nrow, mesh%ncol&
&                                      , mesh%nac, mesh%flow, mesh%&
&                                      drained_area, mesh%&
&                                      rowcol_to_ind_sparse, row, col, t&
&                                      , output%sparse_qsim_domain, qup)
              CALL GR_TRANSFER1(setup%dt, qup, parameters%lr(row, col), &
&                         states%hlr(row, col), qrout)
              output%sparse_qsim_domain(k, t) = (qt+qrout*REAL(mesh%&
&               drained_area(row, col)-1))*setup%dx*setup%dx*0.001_sp/&
&               setup%dt
            ELSE
              CALL UPSTREAM_DISCHARGE(setup%dt, setup%dx, setup%&
&                               ntime_step, mesh%nrow, mesh%ncol, mesh%&
&                               flow, mesh%drained_area, row, col, t, &
&                               output%qsim_domain, qup)
              CALL GR_TRANSFER1(setup%dt, qup, parameters%lr(row, col), &
&                         states%hlr(row, col), qrout)
              output%qsim_domain(row, col, t) = (qt+qrout*REAL(mesh%&
&               drained_area(row, col)-1))*setup%dx*setup%dx*0.001_sp/&
&               setup%dt
            END IF
          END SELECT
        END IF
      END IF
    END DO
  END DO
!% [ END DO SPACE ]
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Store discharge at gauge
!% =================================================================================================================== %!
  DO g=1,mesh%ng
    row = mesh%gauge_pos(1, g)
    col = mesh%gauge_pos(2, g)
    IF (setup%sparse_storage) THEN
      k = mesh%rowcol_to_ind_sparse(row, col)
      output%qsim(g, :) = output%sparse_qsim_domain(k, :)
    ELSE
      output%qsim(g, :) = output%qsim_domain(row, col, :)
    END IF
  END DO
!% =================================================================================================================== %!
!%   Compute J
!% =================================================================================================================== %!
  CALL COMPUTE_JOBS(setup, mesh, input_data, output, cost)
END SUBROUTINE FORWARD_NODIFF_B

!  Differentiation of forward in reverse (adjoint) mode (with options OpenMP context fixinterface):
!   gradient     of useful results: cost
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.alpha)
!                *(parameters.exc) *(parameters.lr) *(states.hi)
!                *(states.hp) *(states.hft) *(states.hlr) cost
!   RW status of diff variables: parameters.ci:(loc) *(parameters.ci):out
!                parameters.cp:(loc) *(parameters.cp):out parameters.beta:(loc)
!                *(parameters.beta):out parameters.cft:(loc) *(parameters.cft):out
!                parameters.cst:(loc) *(parameters.cst):(loc) parameters.alpha:(loc)
!                *(parameters.alpha):out parameters.exc:(loc) *(parameters.exc):out
!                parameters.lr:(loc) *(parameters.lr):out *(output.qsim):(loc)
!                *(output.qsim_domain):(loc) *(output.sparse_qsim_domain):(loc)
!                states.hi:(loc) *(states.hi):out states.hp:(loc)
!                *(states.hp):out states.hft:(loc) *(states.hft):out
!                states.hst:(loc) *(states.hst):(loc) states.hlr:(loc)
!                *(states.hlr):out cost:in-zero
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.alpha:in
!                parameters.exc:in parameters.lr:in output.qsim:in
!                output.qsim_domain:in output.sparse_qsim_domain:in
!                states.hi:in states.hp:in states.hft:in states.hlr:in
SUBROUTINE FORWARD_B(setup, mesh, input_data, parameters, parameters_b, &
& states, states_b, output, output_b, cost, cost_b)
!% =================================================================================================================== %!
!%   Module import ('only' commented because of issues in adjoint model)
!% =================================================================================================================== %!
!% only: sp
  USE MWD_COMMON
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: ParametersDT
  USE MWD_PARAMETERS_DIFF_B
!% only: StatesDT
  USE MWD_STATES_DIFF_B
!% only: OutputDT
  USE MWD_OUTPUT_DIFF_B
!% only: GR_interception, GR_production, GR_exchange, &
  USE MD_OPERATOR_DIFF_B
!% & GR_transferN, upstream_discharge, sparse_upstream_discharge, GR_transfer1
!% only: compute_jobs
  USE MWD_COST_DIFF_B
  IMPLICIT NONE
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
  TYPE(SETUPDT), INTENT(IN) :: setup
  TYPE(MESHDT), INTENT(IN) :: mesh
  TYPE(INPUT_DATADT), INTENT(IN) :: input_data
  TYPE(PARAMETERSDT), INTENT(IN) :: parameters
  TYPE(PARAMETERSDT) :: parameters_b
  TYPE(STATESDT), INTENT(INOUT) :: states
  TYPE(STATESDT), INTENT(INOUT) :: states_b
  TYPE(OUTPUTDT), INTENT(INOUT) :: output
  TYPE(OUTPUTDT_DIFF_B), INTENT(INOUT) :: output_b
  REAL(sp), INTENT(INOUT) :: cost
  REAL(sp), INTENT(INOUT) :: cost_b
!% =================================================================================================================== %!
!%   Local Variables (private)
!===================================================================================================================== %!
  INTEGER :: t, i, row, col, k, g
  REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prd, qd, qr, ql, &
& qt, qup, qrout
  REAL(sp) :: ei_b, pn_b, en_b, pr_b, perc_b, l_b, prr_b, prd_b, qd_b, &
& qr_b, qt_b, qup_b, qrout_b
  INTRINSIC MIN
  INTRINSIC MAX
  INTRINSIC REAL
  REAL(sp) :: temp_b
  REAL*4 :: temp_b0
  INTEGER :: branch
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
  DO t=1,setup%ntime_step
!% [ DO SPACE ]
    DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialization for time step (t) and cell (i)
!% =============================================================================================================== %!
      ei = 0._sp
      CALL PUSHREAL4(pn)
      pn = 0._sp
      CALL PUSHREAL4(pr)
      pr = 0._sp
      CALL PUSHREAL4(perc)
      perc = 0._sp
      l = 0._sp
      qd = 0._sp
      qr = 0._sp
      ql = 0._sp
!% [ END IF PATH ]
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of drained area 
!% =========================================================================================================== %!
      IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
!% [ IF PATH ]
        CALL PUSHINTEGER4(row)
        row = mesh%path(1, i)
        CALL PUSHINTEGER4(col)
        col = mesh%path(2, i)
        IF (setup%sparse_storage) THEN
          CALL PUSHINTEGER4(k)
          k = mesh%rowcol_to_ind_sparse(row, col)
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!% [ END IF ACTIVE CELL ]
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
        IF (mesh%global_active_cell(row, col) .EQ. 1 .AND. mesh%&
&           local_active_cell(row, col) .EQ. 1) THEN
!% [ IF ACTIVE CELL ]
          IF (setup%sparse_storage) THEN
            CALL PUSHREAL4(prcp)
            prcp = input_data%sparse_prcp(k, t)
            CALL PUSHREAL4(pet)
            pet = input_data%sparse_pet(k, t)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHREAL4(prcp)
            prcp = input_data%prcp(row, col, t)
            CALL PUSHREAL4(pet)
            pet = input_data%pet(row, col, t)
            CALL PUSHCONTROL1B(1)
          END IF
!% [ END IF PRCP GAP ]
          IF (prcp .GE. 0) THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module case [ 0 - 1 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%interception_module) 
            CASE (0) 
              IF (pet .GT. prcp) THEN
                ei = prcp
              ELSE
                ei = pet
              END IF
              IF (0._sp .LT. prcp - ei) THEN
                CALL PUSHCONTROL2B(2)
                pn = prcp - ei
              ELSE
                CALL PUSHCONTROL2B(2)
                pn = 0._sp
              END IF
            CASE (1) 
              CALL PUSHREAL4(states%hi(row, col))
              CALL GR_INTERCEPTION(prcp, pet, parameters%ci(row, col), &
&                            states%hi(row, col), pn, ei)
              CALL PUSHCONTROL2B(1)
            CASE DEFAULT
              CALL PUSHCONTROL2B(0)
            END SELECT
            CALL PUSHREAL4(en)
            en = pet - ei
!% =============================================================================================== %!
!%   Production module case [ 0 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%production_module) 
            CASE (0) 
              CALL PUSHREAL4(states%hp(row, col))
              CALL GR_PRODUCTION(pn, en, parameters%cp(row, col), &
&                          parameters%beta(row, col), states%hp(row, col&
&                          ), pr, perc)
              CALL PUSHCONTROL1B(1)
            CASE DEFAULT
              CALL PUSHCONTROL1B(0)
            END SELECT
!% =============================================================================================== %!
!%   Exchange module case [ 0 - 1 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%exchange_module) 
            CASE (0) 
              CALL PUSHCONTROL2B(0)
              l = 0._sp
            CASE (1) 
              CALL GR_EXCHANGE(parameters%exc(row, col), states%hft(row&
&                        , col), l)
              CALL PUSHCONTROL2B(1)
            CASE DEFAULT
              CALL PUSHCONTROL2B(0)
            END SELECT
          ELSE
            CALL PUSHCONTROL2B(2)
          END IF
!% =================================================================================================== %!
!%   Transfer module case [ 0 ]
!% =================================================================================================== %!
          SELECT CASE  (setup%transfer_module) 
          CASE (0) 
            CALL PUSHREAL4(prr)
            prr = parameters%alpha(row, col)*(pr+perc) + l
            prd = pr + perc - prr
            CALL PUSHREAL4(states%hft(row, col))
            CALL GR_TRANSFERN(5._sp, prcp, prr, parameters%cft(row, col)&
&                       , states%hft(row, col), qr)
            IF (0._sp .LT. prd + l) THEN
              qd = prd + l
              CALL PUSHCONTROL2B(2)
            ELSE
              qd = 0._sp
              CALL PUSHCONTROL2B(1)
            END IF
          CASE DEFAULT
            CALL PUSHCONTROL2B(0)
          END SELECT
          qt = qd + qr + ql
!% =================================================================================================== %!
!%   Routing module case [ 0 - 1 ]
!% =================================================================================================== %!
          SELECT CASE  (setup%routing_module) 
          CASE (0) 
            IF (setup%sparse_storage) THEN
              CALL PUSHREAL4(qup)
              CALL SPARSE_UPSTREAM_DISCHARGE(setup%dt, setup%dx, setup%&
&                                      ntime_step, mesh%nrow, mesh%ncol&
&                                      , mesh%nac, mesh%flow, mesh%&
&                                      drained_area, mesh%&
&                                      rowcol_to_ind_sparse, row, col, t&
&                                      , output%sparse_qsim_domain, qup)
              output%sparse_qsim_domain(k, t) = (qt+qup*REAL(mesh%&
&               drained_area(row, col)-1))*setup%dx*setup%dx*0.001_sp/&
&               setup%dt
              CALL PUSHCONTROL3B(5)
            ELSE
              CALL PUSHREAL4(qup)
              CALL UPSTREAM_DISCHARGE(setup%dt, setup%dx, setup%&
&                               ntime_step, mesh%nrow, mesh%ncol, mesh%&
&                               flow, mesh%drained_area, row, col, t, &
&                               output%qsim_domain, qup)
              output%qsim_domain(row, col, t) = (qt+qup*REAL(mesh%&
&               drained_area(row, col)-1))*setup%dx*setup%dx*0.001_sp/&
&               setup%dt
              CALL PUSHCONTROL3B(4)
            END IF
          CASE (1) 
            IF (setup%sparse_storage) THEN
              CALL PUSHREAL4(qup)
              CALL SPARSE_UPSTREAM_DISCHARGE(setup%dt, setup%dx, setup%&
&                                      ntime_step, mesh%nrow, mesh%ncol&
&                                      , mesh%nac, mesh%flow, mesh%&
&                                      drained_area, mesh%&
&                                      rowcol_to_ind_sparse, row, col, t&
&                                      , output%sparse_qsim_domain, qup)
              CALL PUSHREAL4(states%hlr(row, col))
              CALL GR_TRANSFER1(setup%dt, qup, parameters%lr(row, col), &
&                         states%hlr(row, col), qrout)
              output%sparse_qsim_domain(k, t) = (qt+qrout*REAL(mesh%&
&               drained_area(row, col)-1))*setup%dx*setup%dx*0.001_sp/&
&               setup%dt
              CALL PUSHCONTROL3B(3)
            ELSE
              CALL PUSHREAL4(qup)
              CALL UPSTREAM_DISCHARGE(setup%dt, setup%dx, setup%&
&                               ntime_step, mesh%nrow, mesh%ncol, mesh%&
&                               flow, mesh%drained_area, row, col, t, &
&                               output%qsim_domain, qup)
              CALL PUSHREAL4(states%hlr(row, col))
              CALL GR_TRANSFER1(setup%dt, qup, parameters%lr(row, col), &
&                         states%hlr(row, col), qrout)
              output%qsim_domain(row, col, t) = (qt+qrout*REAL(mesh%&
&               drained_area(row, col)-1))*setup%dx*setup%dx*0.001_sp/&
&               setup%dt
              CALL PUSHCONTROL3B(2)
            END IF
          CASE DEFAULT
            CALL PUSHCONTROL3B(6)
          END SELECT
        ELSE
          CALL PUSHCONTROL3B(1)
        END IF
      ELSE
        CALL PUSHCONTROL3B(0)
      END IF
    END DO
  END DO
!% [ END DO SPACE ]
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Store discharge at gauge
!% =================================================================================================================== %!
  DO g=1,mesh%ng
    CALL PUSHINTEGER4(row)
    row = mesh%gauge_pos(1, g)
    CALL PUSHINTEGER4(col)
    col = mesh%gauge_pos(2, g)
    IF (setup%sparse_storage) THEN
      CALL PUSHINTEGER4(k)
      k = mesh%rowcol_to_ind_sparse(row, col)
      output%qsim(g, :) = output%sparse_qsim_domain(k, :)
      CALL PUSHCONTROL1B(1)
    ELSE
      output%qsim(g, :) = output%qsim_domain(row, col, :)
      CALL PUSHCONTROL1B(0)
    END IF
  END DO
  CALL COMPUTE_JOBS(setup, mesh, input_data, output, cost)
  CALL COMPUTE_JOBS_B(setup, mesh, input_data, output, output_b, cost, &
&               cost_b)
  IF (.not. setup%sparse_storage)  output_b%qsim_domain = 0.0_4
  IF (setup%sparse_storage)  output_b%sparse_qsim_domain = 0.0_4
  DO g=mesh%ng,1,-1
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      row = mesh%gauge_pos(1, g)
      col = mesh%gauge_pos(2, g)
      output_b%qsim_domain(row, col, :) = output_b%qsim_domain(row, col&
&       , :) + output_b%qsim(g, :)
      output_b%qsim(g, :) = 0.0_4
    ELSE
      row = mesh%gauge_pos(1, g)
      col = mesh%gauge_pos(2, g)
      k = mesh%rowcol_to_ind_sparse(row, col)
      output_b%sparse_qsim_domain(k, :) = output_b%sparse_qsim_domain(k&
&       , :) + output_b%qsim(g, :)
      output_b%qsim(g, :) = 0.0_4
      CALL POPINTEGER4(k)
    END IF
    CALL POPINTEGER4(col)
    CALL POPINTEGER4(row)
  END DO
  parameters_b%ci = 0.0_4
  parameters_b%cp = 0.0_4
  parameters_b%beta = 0.0_4
  parameters_b%cft = 0.0_4
  parameters_b%alpha = 0.0_4
  parameters_b%exc = 0.0_4
  parameters_b%lr = 0.0_4
  states_b%hi = 0.0_4
  states_b%hp = 0.0_4
  states_b%hft = 0.0_4
  states_b%hlr = 0.0_4
  DO t=setup%ntime_step,1,-1
    DO i=mesh%nrow*mesh%ncol,1,-1
      CALL POPCONTROL3B(branch)
      IF (branch .LT. 3) THEN
        IF (branch .EQ. 0) THEN
          GOTO 120
        ELSE IF (branch .EQ. 1) THEN
          GOTO 110
        ELSE
          row = mesh%path(1, i)
          col = mesh%path(2, i)
          temp_b0 = setup%dx**2*0.001_sp*output_b%qsim_domain(row, col, &
&           t)/setup%dt
          output_b%qsim_domain(row, col, t) = 0.0_4
          qt_b = temp_b0
          qrout_b = REAL(mesh%drained_area(row, col)-1)*temp_b0
          CALL POPREAL4(states%hlr(row, col))
          CALL GR_TRANSFER1_B(setup%dt, qup, qup_b, parameters%lr(row, &
&                       col), parameters_b%lr(row, col), states%hlr(row&
&                       , col), states_b%hlr(row, col), qrout, qrout_b)
          CALL POPREAL4(qup)
          CALL UPSTREAM_DISCHARGE_B(setup%dt, setup%dx, setup%ntime_step&
&                             , mesh%nrow, mesh%ncol, mesh%flow, mesh%&
&                             drained_area, row, col, t, output%&
&                             qsim_domain, output_b%qsim_domain, qup, &
&                             qup_b)
        END IF
      ELSE IF (branch .LT. 5) THEN
        IF (branch .EQ. 3) THEN
          row = mesh%path(1, i)
          col = mesh%path(2, i)
          temp_b0 = setup%dx**2*0.001_sp*output_b%sparse_qsim_domain(k, &
&           t)/setup%dt
          output_b%sparse_qsim_domain(k, t) = 0.0_4
          qt_b = temp_b0
          qrout_b = REAL(mesh%drained_area(row, col)-1)*temp_b0
          CALL POPREAL4(states%hlr(row, col))
          CALL GR_TRANSFER1_B(setup%dt, qup, qup_b, parameters%lr(row, &
&                       col), parameters_b%lr(row, col), states%hlr(row&
&                       , col), states_b%hlr(row, col), qrout, qrout_b)
          CALL POPREAL4(qup)
          CALL SPARSE_UPSTREAM_DISCHARGE_B(setup%dt, setup%dx, setup%&
&                                    ntime_step, mesh%nrow, mesh%ncol, &
&                                    mesh%nac, mesh%flow, mesh%&
&                                    drained_area, mesh%&
&                                    rowcol_to_ind_sparse, row, col, t, &
&                                    output%sparse_qsim_domain, output_b&
&                                    %sparse_qsim_domain, qup, qup_b)
        ELSE
          row = mesh%path(1, i)
          col = mesh%path(2, i)
          temp_b0 = setup%dx**2*0.001_sp*output_b%qsim_domain(row, col, &
&           t)/setup%dt
          output_b%qsim_domain(row, col, t) = 0.0_4
          qt_b = temp_b0
          qup_b = REAL(mesh%drained_area(row, col)-1)*temp_b0
          CALL POPREAL4(qup)
          CALL UPSTREAM_DISCHARGE_B(setup%dt, setup%dx, setup%ntime_step&
&                             , mesh%nrow, mesh%ncol, mesh%flow, mesh%&
&                             drained_area, row, col, t, output%&
&                             qsim_domain, output_b%qsim_domain, qup, &
&                             qup_b)
        END IF
      ELSE IF (branch .EQ. 5) THEN
        row = mesh%path(1, i)
        col = mesh%path(2, i)
        temp_b0 = setup%dx**2*0.001_sp*output_b%sparse_qsim_domain(k, t)&
&         /setup%dt
        output_b%sparse_qsim_domain(k, t) = 0.0_4
        qt_b = temp_b0
        qup_b = REAL(mesh%drained_area(row, col)-1)*temp_b0
        CALL POPREAL4(qup)
        CALL SPARSE_UPSTREAM_DISCHARGE_B(setup%dt, setup%dx, setup%&
&                                  ntime_step, mesh%nrow, mesh%ncol, &
&                                  mesh%nac, mesh%flow, mesh%&
&                                  drained_area, mesh%&
&                                  rowcol_to_ind_sparse, row, col, t, &
&                                  output%sparse_qsim_domain, output_b%&
&                                  sparse_qsim_domain, qup, qup_b)
      ELSE
        qt_b = 0.0_4
      END IF
      qd_b = qt_b
      qr_b = qt_b
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        l_b = 0.0_4
        perc_b = 0.0_4
        pr_b = 0.0_4
      ELSE
        IF (branch .EQ. 1) THEN
          l_b = 0.0_4
          prd_b = 0.0_4
        ELSE
          prd_b = qd_b
          l_b = qd_b
        END IF
        CALL POPREAL4(states%hft(row, col))
        CALL GR_TRANSFERN_B(5._sp, prcp, prr, prr_b, parameters%cft(row&
&                     , col), parameters_b%cft(row, col), states%hft(row&
&                     , col), states_b%hft(row, col), qr, qr_b)
        prr_b = prr_b - prd_b
        CALL POPREAL4(prr)
        parameters_b%alpha(row, col) = parameters_b%alpha(row, col) + (&
&         pr+perc)*prr_b
        temp_b = parameters%alpha(row, col)*prr_b
        pr_b = prd_b + temp_b
        perc_b = prd_b + temp_b
        l_b = l_b + prr_b
      END IF
      CALL POPCONTROL2B(branch)
      IF (branch .NE. 0) THEN
        IF (branch .EQ. 1) THEN
          CALL GR_EXCHANGE_B(parameters%exc(row, col), parameters_b%exc(&
&                      row, col), states%hft(row, col), states_b%hft(row&
&                      , col), l, l_b)
        ELSE
          GOTO 100
        END IF
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        en_b = 0.0_4
        pn_b = 0.0_4
      ELSE
        CALL POPREAL4(states%hp(row, col))
        CALL GR_PRODUCTION_B(pn, pn_b, en, en_b, parameters%cp(row, col)&
&                      , parameters_b%cp(row, col), parameters%beta(row&
&                      , col), parameters_b%beta(row, col), states%hp(&
&                      row, col), states_b%hp(row, col), pr, pr_b, perc&
&                      , perc_b)
      END IF
      CALL POPREAL4(en)
      ei_b = -en_b
      CALL POPCONTROL2B(branch)
      IF (branch .NE. 0) THEN
        IF (branch .EQ. 1) THEN
          CALL POPREAL4(states%hi(row, col))
          CALL GR_INTERCEPTION_B(prcp, pet, parameters%ci(row, col), &
&                          parameters_b%ci(row, col), states%hi(row, col&
&                          ), states_b%hi(row, col), pn, pn_b, ei, ei_b)
        END IF
      END IF
 100  CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL4(pet)
        CALL POPREAL4(prcp)
      ELSE
        CALL POPREAL4(pet)
        CALL POPREAL4(prcp)
      END IF
 110  CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) CALL POPINTEGER4(k)
      CALL POPINTEGER4(col)
      CALL POPINTEGER4(row)
 120  CALL POPREAL4(perc)
      CALL POPREAL4(pr)
      CALL POPREAL4(pn)
    END DO
  END DO
  parameters_b%cst = 0.0_4
  states_b%hst = 0.0_4
  cost_b = 0.0_4
END SUBROUTINE FORWARD_B

