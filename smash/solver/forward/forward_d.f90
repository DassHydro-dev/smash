!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!%    This module (wrap) `mw_output` encapsulates all SMASH output
MODULE MWD_OUTPUT_DIFF_D
!% only: sp, dp, lchar, np, ns
  USE MD_COMMON
!% only: SetupDT
  USE MWD_SETUP
!%only: MeshDT
  USE MWD_MESH
  IMPLICIT NONE
!%      OutputDT type:
!%
!%      ====================    ==========================================================
!%      `args`                  Description
!%      ====================    ==========================================================
!%      ====================    ==========================================================
  TYPE OUTPUTDT
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: qsim
      REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: qsim_grid
      REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: parameters_gradient
      REAL(sp) :: cost
  END TYPE OUTPUTDT
  TYPE OUTPUTDT_DIFF_D
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: qsim
  END TYPE OUTPUTDT_DIFF_D

CONTAINS
  SUBROUTINE OUTPUTDT_INITIALISE(output, setup, mesh)
    IMPLICIT NONE
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(SETUPDT), INTENT(INOUT) :: setup
    TYPE(MESHDT), INTENT(INOUT) :: mesh
    ALLOCATE(output%qsim(mesh%ng, setup%ntime_step))
    output%qsim = -99._sp
    IF (.NOT.setup%active_cell_only) THEN
      ALLOCATE(output%qsim_grid(mesh%nrow, mesh%ncol, setup%ntime_step))
      output%qsim_grid = -99._sp
    END IF
    IF (.NOT.setup%simulation_only) THEN
      ALLOCATE(output%parameters_gradient(mesh%nrow, mesh%ncol, np))
      output%parameters_gradient = 0._sp
    END IF
  END SUBROUTINE OUTPUTDT_INITIALISE

END MODULE MWD_OUTPUT_DIFF_D

!%    This module `mw_cost` encapsulates all SMASH cost (type, subroutines, functions)
MODULE MWD_COST_DIFF_D
!% only: sp, dp, lchar, np, ns
  USE MD_COMMON
!% only: SetupDT
  USE MWD_SETUP
!%only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: OutputDT
  USE MWD_OUTPUT_DIFF_D
  IMPLICIT NONE

CONTAINS
!  Differentiation of compute_jobs in forward (tangent) mode (with options OpenMP context fixinterface):
!   variations   of useful results: jobs
!   with respect to varying inputs: *(output.qsim)
!   Plus diff mem management of: output.qsim:in
  SUBROUTINE COMPUTE_JOBS_D(setup, mesh, input_data, output, output_d, &
&   jobs, jobs_d)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT_DIFF_D), INTENT(INOUT) :: output_d
    REAL(sp), INTENT(OUT) :: jobs
    REAL(sp), INTENT(OUT) :: jobs_d
    REAL(sp), DIMENSION(setup%ntime_step-setup%optim_start_step+1) :: qo&
&   , qs
    REAL(sp), DIMENSION(setup%ntime_step-setup%optim_start_step+1) :: &
&   qs_d
    INTEGER :: g, row_g, col_g
    INTRINSIC REAL
    INTRINSIC ANY
    REAL(sp) :: result1
    REAL(sp) :: result1_d
    jobs = 0._sp
    jobs_d = 0.0_4
    DO g=1,mesh%ng
      qs_d = setup%dt*0.001_sp*output_d%qsim(g, setup%optim_start_step:&
&       setup%ntime_step)/mesh%area(g)
      qs = output%qsim(g, setup%optim_start_step:setup%ntime_step)*setup&
&       %dt*0.001_sp/mesh%area(g)
      row_g = mesh%gauge_pos(1, g)
      col_g = mesh%gauge_pos(2, g)
      qo = input_data%qobs(g, setup%optim_start_step:setup%ntime_step)*&
&       setup%dt*0.001_sp/(REAL(mesh%drained_area(row_g, col_g))*(setup%&
&       dx/1000._sp)*(setup%dx/1000._sp))
      IF (ANY(qo .GE. 0._sp)) THEN
        result1_d = NSE_D(qo, qs, qs_d, result1)
        jobs_d = jobs_d + result1_d
        jobs = jobs + result1
      END IF
    END DO
  END SUBROUTINE COMPUTE_JOBS_D

  SUBROUTINE COMPUTE_JOBS(setup, mesh, input_data, output, jobs)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    REAL(sp), INTENT(OUT) :: jobs
    REAL(sp), DIMENSION(setup%ntime_step-setup%optim_start_step+1) :: qo&
&   , qs
    INTEGER :: g, row_g, col_g
    INTRINSIC REAL
    INTRINSIC ANY
    REAL(sp) :: result1
    jobs = 0._sp
    DO g=1,mesh%ng
      qs = output%qsim(g, setup%optim_start_step:setup%ntime_step)*setup&
&       %dt*0.001_sp/mesh%area(g)
      row_g = mesh%gauge_pos(1, g)
      col_g = mesh%gauge_pos(2, g)
      qo = input_data%qobs(g, setup%optim_start_step:setup%ntime_step)*&
&       setup%dt*0.001_sp/(REAL(mesh%drained_area(row_g, col_g))*(setup%&
&       dx/1000._sp)*(setup%dx/1000._sp))
      IF (ANY(qo .GE. 0._sp)) THEN
        result1 = NSE(qo, qs)
        jobs = jobs + result1
      END IF
    END DO
  END SUBROUTINE COMPUTE_JOBS

!  Differentiation of nse in forward (tangent) mode (with options OpenMP context fixinterface):
!   variations   of useful results: res
!   with respect to varying inputs: y
!~         subroutine compute_jreg
!~         end subroutine compute_jreg
  FUNCTION NSE_D(x, y, y_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:), INTENT(IN) :: y_d
    REAL(sp) :: res
    REAL(sp) :: res_d
    REAL(sp) :: sum_x, sum_xx, sum_yy, sum_xy, mean_x, num, den
    REAL(sp) :: sum_yy_d, sum_xy_d, num_d
    INTEGER :: i, n
    INTRINSIC SIZE
!% Metric computation
    n = 0
    sum_x = 0.
    sum_xx = 0.
    sum_yy = 0.
    sum_xy = 0.
    sum_yy_d = 0.0_4
    sum_xy_d = 0.0_4
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0.) THEN
        n = n + 1
        sum_x = sum_x + x(i)
        sum_xx = sum_xx + x(i)*x(i)
        sum_yy_d = sum_yy_d + 2*y(i)*y_d(i)
        sum_yy = sum_yy + y(i)*y(i)
        sum_xy_d = sum_xy_d + x(i)*y_d(i)
        sum_xy = sum_xy + x(i)*y(i)
      END IF
    END DO
    mean_x = sum_x/n
!% NSE numerator / denominator
    num_d = sum_yy_d - 2*sum_xy_d
    num = sum_xx - 2*sum_xy + sum_yy
    den = sum_xx - n*mean_x*mean_x
!% NSE criterion
    res_d = num_d/den
    res = num/den
  END FUNCTION NSE_D

!~         subroutine compute_jreg
!~         end subroutine compute_jreg
  FUNCTION NSE(x, y) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp) :: res
    REAL(sp) :: sum_x, sum_xx, sum_yy, sum_xy, mean_x, num, den
    INTEGER :: i, n
    INTRINSIC SIZE
!% Metric computation
    n = 0
    sum_x = 0.
    sum_xx = 0.
    sum_yy = 0.
    sum_xy = 0.
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0.) THEN
        n = n + 1
        sum_x = sum_x + x(i)
        sum_xx = sum_xx + x(i)*x(i)
        sum_yy = sum_yy + y(i)*y(i)
        sum_xy = sum_xy + x(i)*y(i)
      END IF
    END DO
    mean_x = sum_x/n
!% NSE numerator / denominator
    num = sum_xx - 2*sum_xy + sum_yy
    den = sum_xx - n*mean_x*mean_x
!% NSE criterion
    res = num/den
  END FUNCTION NSE

END MODULE MWD_COST_DIFF_D

!%    This module `m_operator` encapsulates all SMASH operator (type, subroutines, functions)
MODULE MD_OPERATOR_DIFF_D
!% only : sp
  USE MD_COMMON
  IMPLICIT NONE

CONTAINS
!  Differentiation of gr_interception in forward (tangent) mode (with options OpenMP context fixinterface):
!   variations   of useful results: hi ei pn
!   with respect to varying inputs: hi ci
!% TODO Renommer argument pour etre global
  SUBROUTINE GR_INTERCEPTION_D(prcp, pet, ci, ci_d, hi, hi_d, pn, pn_d, &
&   ei, ei_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: prcp, pet, ci
    REAL(sp), INTENT(IN) :: ci_d
    REAL(sp), INTENT(INOUT) :: hi
    REAL(sp), INTENT(INOUT) :: hi_d
    REAL(sp), INTENT(OUT) :: pn, ei
    REAL(sp), INTENT(OUT) :: pn_d, ei_d
    INTRINSIC MIN
    INTRINSIC MAX
    REAL(sp) :: temp
    IF (pet .GT. prcp + hi*ci) THEN
      ei_d = ci*hi_d + hi*ci_d
      ei = prcp + hi*ci
    ELSE
      ei = pet
      ei_d = 0.0_4
    END IF
    IF (0._sp .LT. prcp - ci*(1._sp-hi) - ei) THEN
      pn_d = ci*hi_d - (1._sp-hi)*ci_d - ei_d
      pn = prcp - ci*(1._sp-hi) - ei
    ELSE
      pn = 0._sp
      pn_d = 0.0_4
    END IF
    temp = (prcp-ei-pn)/ci
    hi_d = hi_d + (-ei_d-pn_d-temp*ci_d)/ci
    hi = hi + temp
  END SUBROUTINE GR_INTERCEPTION_D

!% TODO Renommer argument pour etre global
  SUBROUTINE GR_INTERCEPTION(prcp, pet, ci, hi, pn, ei)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: prcp, pet, ci
    REAL(sp), INTENT(INOUT) :: hi
    REAL(sp), INTENT(OUT) :: pn, ei
    INTRINSIC MIN
    INTRINSIC MAX
    IF (pet .GT. prcp + hi*ci) THEN
      ei = prcp + hi*ci
    ELSE
      ei = pet
    END IF
    IF (0._sp .LT. prcp - ci*(1._sp-hi) - ei) THEN
      pn = prcp - ci*(1._sp-hi) - ei
    ELSE
      pn = 0._sp
    END IF
    hi = hi + (prcp-ei-pn)/ci
  END SUBROUTINE GR_INTERCEPTION

!  Differentiation of gr_production in forward (tangent) mode (with options OpenMP context fixinterface):
!   variations   of useful results: hp perc pr
!   with respect to varying inputs: hp en beta cp pn
  SUBROUTINE GR_PRODUCTION_D(pn, pn_d, en, en_d, cp, cp_d, beta, beta_d&
&   , hp, hp_d, pr, pr_d, perc, perc_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: pn, en, cp, beta
    REAL(sp), INTENT(IN) :: pn_d, en_d, cp_d, beta_d
    REAL(sp), INTENT(INOUT) :: hp
    REAL(sp), INTENT(INOUT) :: hp_d
    REAL(sp), INTENT(OUT) :: pr, perc
    REAL(sp), INTENT(OUT) :: pr_d, perc_d
    REAL(sp) :: inv_cp, ps, es, hp_imd
    REAL(sp) :: inv_cp_d, ps_d, es_d, hp_imd_d
    INTRINSIC TANH
    REAL(sp) :: pwx1
    REAL(sp) :: pwx1_d
    REAL(sp) :: pwr1
    REAL(sp) :: pwr1_d
    REAL(sp) :: temp
    REAL(sp) :: temp0
    REAL(sp) :: temp1
    REAL(sp) :: temp2
    inv_cp_d = -(cp_d/cp**2)
    inv_cp = 1._sp/cp
    pr = 0._sp
    temp = TANH(pn*inv_cp)
    temp0 = TANH(pn*inv_cp)
    temp1 = cp*(-(hp*hp)+1._sp)
    temp2 = temp1*temp0/(hp*temp+1._sp)
    ps_d = (temp0*((1._sp-hp**2)*cp_d-cp*2*hp*hp_d)+temp1*(1.0-TANH(pn*&
&     inv_cp)**2)*(inv_cp*pn_d+pn*inv_cp_d)-temp2*(temp*hp_d+hp*(1.0-&
&     TANH(pn*inv_cp)**2)*(inv_cp*pn_d+pn*inv_cp_d)))/(hp*temp+1._sp)
    ps = temp2
    temp2 = TANH(en*inv_cp)
    temp1 = TANH(en*inv_cp)
    temp0 = hp*cp*(-hp+2._sp)
    temp = temp0*temp1/((-hp+1._sp)*temp2+1._sp)
    es_d = (temp1*((2._sp-hp)*(cp*hp_d+hp*cp_d)-hp*cp*hp_d)+temp0*(1.0-&
&     TANH(en*inv_cp)**2)*(inv_cp*en_d+en*inv_cp_d)-temp*((1._sp-hp)*(&
&     1.0-TANH(en*inv_cp)**2)*(inv_cp*en_d+en*inv_cp_d)-temp2*hp_d))/((&
&     1._sp-hp)*temp2+1._sp)
    es = temp
    hp_imd_d = hp_d + inv_cp*(ps_d-es_d) + (ps-es)*inv_cp_d
    hp_imd = hp + (ps-es)*inv_cp
    IF (pn .GT. 0) THEN
      pr_d = pn_d - cp*(hp_imd_d-hp_d) - (hp_imd-hp)*cp_d
      pr = pn - (hp_imd-hp)*cp
    ELSE
      pr_d = 0.0_4
    END IF
    pwx1_d = 4*hp_imd**3*(hp_imd_d-hp_imd*beta_d/beta)/beta**4
    pwx1 = 1._sp + (hp_imd/beta)**4
    pwr1_d = -(0.25_sp*pwx1**(-1.25)*pwx1_d)
    pwr1 = pwx1**(-0.25_sp)
    perc_d = (1._sp-pwr1)*(cp*hp_imd_d+hp_imd*cp_d) - hp_imd*cp*pwr1_d
    perc = hp_imd*cp*(1._sp-pwr1)
    hp_d = hp_imd_d - inv_cp*perc_d - perc*inv_cp_d
    hp = hp_imd - perc*inv_cp
  END SUBROUTINE GR_PRODUCTION_D

  SUBROUTINE GR_PRODUCTION(pn, en, cp, beta, hp, pr, perc)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: pn, en, cp, beta
    REAL(sp), INTENT(INOUT) :: hp
    REAL(sp), INTENT(OUT) :: pr, perc
    REAL(sp) :: inv_cp, ps, es, hp_imd
    INTRINSIC TANH
    REAL(sp) :: pwx1
    REAL(sp) :: pwr1
    inv_cp = 1._sp/cp
    pr = 0._sp
    ps = cp*(1._sp-hp*hp)*TANH(pn*inv_cp)/(1._sp+hp*TANH(pn*inv_cp))
    es = hp*cp*(2._sp-hp)*TANH(en*inv_cp)/(1._sp+(1._sp-hp)*TANH(en*&
&     inv_cp))
    hp_imd = hp + (ps-es)*inv_cp
    IF (pn .GT. 0) pr = pn - (hp_imd-hp)*cp
    pwx1 = 1._sp + (hp_imd/beta)**4
    pwr1 = pwx1**(-0.25_sp)
    perc = hp_imd*cp*(1._sp-pwr1)
    hp = hp_imd - perc*inv_cp
  END SUBROUTINE GR_PRODUCTION

!  Differentiation of gr_exchange in forward (tangent) mode (with options OpenMP context fixinterface):
!   variations   of useful results: l
!   with respect to varying inputs: hft exc
  SUBROUTINE GR_EXCHANGE_D(exc, exc_d, hft, hft_d, l, l_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: exc
    REAL(sp), INTENT(IN) :: exc_d
    REAL(sp), INTENT(INOUT) :: hft
    REAL(sp), INTENT(INOUT) :: hft_d
    REAL(sp), INTENT(OUT) :: l
    REAL(sp), INTENT(OUT) :: l_d
    REAL(sp) :: temp
    temp = hft**3.5_sp
    l_d = temp*exc_d + exc*3.5_sp*hft**2.5*hft_d
    l = exc*temp
  END SUBROUTINE GR_EXCHANGE_D

  SUBROUTINE GR_EXCHANGE(exc, hft, l)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: exc
    REAL(sp), INTENT(INOUT) :: hft
    REAL(sp), INTENT(OUT) :: l
    l = exc*hft**3.5_sp
  END SUBROUTINE GR_EXCHANGE

!  Differentiation of gr_transfern in forward (tangent) mode (with options OpenMP context fixinterface):
!   variations   of useful results: q ht
!   with respect to varying inputs: ht ct pr
  SUBROUTINE GR_TRANSFERN_D(n, prcp, pr, pr_d, ct, ct_d, ht, ht_d, q, &
&   q_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: n, prcp, pr, ct
    REAL(sp), INTENT(IN) :: pr_d, ct_d
    REAL(sp), INTENT(INOUT) :: ht
    REAL(sp), INTENT(INOUT) :: ht_d
    REAL(sp), INTENT(OUT) :: q
    REAL(sp), INTENT(OUT) :: q_d
    REAL(sp) :: pr_imd, ht_imd, nm1, d1pnm1
    REAL(sp) :: pr_imd_d, ht_imd_d
    INTRINSIC MAX
    REAL(sp) :: pwx1
    REAL(sp) :: pwx1_d
    REAL(sp) :: pwy1
    REAL(sp) :: pwr1
    REAL(sp) :: pwr1_d
    REAL(sp) :: pwy2
    REAL(sp) :: pwr2
    REAL(sp) :: pwr2_d
    REAL(sp) :: pwx3
    REAL(sp) :: pwx3_d
    REAL(sp) :: pwy3
    REAL(sp) :: pwr3
    REAL(sp) :: pwr3_d
    nm1 = n - 1._sp
    d1pnm1 = 1._sp/nm1
    IF (prcp .LT. 0._sp) THEN
      pwx1_d = ct*ht_d + ht*ct_d
      pwx1 = ht*ct
      pwy1 = -nm1
      IF (pwx1 .LE. 0.0 .AND. (pwy1 .EQ. 0.0 .OR. pwy1 .NE. INT(pwy1))) &
&     THEN
        pwr1_d = 0.0_4
      ELSE
        pwr1_d = pwy1*pwx1**(pwy1-1)*pwx1_d
      END IF
      pwr1 = pwx1**pwy1
      pwy2 = -nm1
      IF (ct .LE. 0.0 .AND. (pwy2 .EQ. 0.0 .OR. pwy2 .NE. INT(pwy2))) &
&     THEN
        pwr2_d = 0.0_4
      ELSE
        pwr2_d = pwy2*ct**(pwy2-1)*ct_d
      END IF
      pwr2 = ct**pwy2
      pwx3_d = pwr1_d - pwr2_d
      pwx3 = pwr1 - pwr2
      pwy3 = -d1pnm1
      IF (pwx3 .LE. 0.0 .AND. (pwy3 .EQ. 0.0 .OR. pwy3 .NE. INT(pwy3))) &
&     THEN
        pwr3_d = 0.0_4
      ELSE
        pwr3_d = pwy3*pwx3**(pwy3-1)*pwx3_d
      END IF
      pwr3 = pwx3**pwy3
      pr_imd_d = pwr3_d - ct*ht_d - ht*ct_d
      pr_imd = pwr3 - ht*ct
    ELSE
      pr_imd_d = pr_d
      pr_imd = pr
    END IF
    IF (1.e-6_sp .LT. ht + pr_imd/ct) THEN
      ht_imd_d = ht_d + (pr_imd_d-pr_imd*ct_d/ct)/ct
      ht_imd = ht + pr_imd/ct
    ELSE
      ht_imd = 1.e-6_sp
      ht_imd_d = 0.0_4
    END IF
    pwx1_d = ct*ht_imd_d + ht_imd*ct_d
    pwx1 = ht_imd*ct
    pwy1 = -nm1
    IF (pwx1 .LE. 0.0 .AND. (pwy1 .EQ. 0.0 .OR. pwy1 .NE. INT(pwy1))) &
&   THEN
      pwr1_d = 0.0_4
    ELSE
      pwr1_d = pwy1*pwx1**(pwy1-1)*pwx1_d
    END IF
    pwr1 = pwx1**pwy1
    pwy2 = -nm1
    IF (ct .LE. 0.0 .AND. (pwy2 .EQ. 0.0 .OR. pwy2 .NE. INT(pwy2))) THEN
      pwr2_d = 0.0_4
    ELSE
      pwr2_d = pwy2*ct**(pwy2-1)*ct_d
    END IF
    pwr2 = ct**pwy2
    pwx3_d = pwr1_d + pwr2_d
    pwx3 = pwr1 + pwr2
    pwy3 = -d1pnm1
    IF (pwx3 .LE. 0.0 .AND. (pwy3 .EQ. 0.0 .OR. pwy3 .NE. INT(pwy3))) &
&   THEN
      pwr3_d = 0.0_4
    ELSE
      pwr3_d = pwy3*pwx3**(pwy3-1)*pwx3_d
    END IF
    pwr3 = pwx3**pwy3
    ht_d = (pwr3_d-pwr3*ct_d/ct)/ct
    ht = pwr3/ct
    q_d = ct*(ht_imd_d-ht_d) + (ht_imd-ht)*ct_d
    q = (ht_imd-ht)*ct
  END SUBROUTINE GR_TRANSFERN_D

  SUBROUTINE GR_TRANSFERN(n, prcp, pr, ct, ht, q)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: n, prcp, pr, ct
    REAL(sp), INTENT(INOUT) :: ht
    REAL(sp), INTENT(OUT) :: q
    REAL(sp) :: pr_imd, ht_imd, nm1, d1pnm1
    INTRINSIC MAX
    REAL(sp) :: pwx1
    REAL(sp) :: pwy1
    REAL(sp) :: pwr1
    REAL(sp) :: pwy2
    REAL(sp) :: pwr2
    REAL(sp) :: pwx3
    REAL(sp) :: pwy3
    REAL(sp) :: pwr3
    nm1 = n - 1._sp
    d1pnm1 = 1._sp/nm1
    IF (prcp .LT. 0._sp) THEN
      pwx1 = ht*ct
      pwy1 = -nm1
      pwr1 = pwx1**pwy1
      pwy2 = -nm1
      pwr2 = ct**pwy2
      pwx3 = pwr1 - pwr2
      pwy3 = -d1pnm1
      pwr3 = pwx3**pwy3
      pr_imd = pwr3 - ht*ct
    ELSE
      pr_imd = pr
    END IF
    IF (1.e-6_sp .LT. ht + pr_imd/ct) THEN
      ht_imd = ht + pr_imd/ct
    ELSE
      ht_imd = 1.e-6_sp
    END IF
    pwx1 = ht_imd*ct
    pwy1 = -nm1
    pwr1 = pwx1**pwy1
    pwy2 = -nm1
    pwr2 = ct**pwy2
    pwx3 = pwr1 + pwr2
    pwy3 = -d1pnm1
    pwr3 = pwx3**pwy3
    ht = pwr3/ct
    q = (ht_imd-ht)*ct
  END SUBROUTINE GR_TRANSFERN

!  Differentiation of upstream_discharge in forward (tangent) mode (with options OpenMP context fixinterface):
!   variations   of useful results: qup
!   with respect to varying inputs: q
  SUBROUTINE UPSTREAM_DISCHARGE_D(dt, dx, ntime_step, nrow, ncol, flow, &
&   drained_area, row, col, t, q, q_d, qup, qup_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt, dx
    INTEGER, INTENT(IN) :: ntime_step, nrow, ncol, row, col, t
    INTEGER, DIMENSION(nrow, ncol), INTENT(IN) :: flow, drained_area
    REAL(sp), DIMENSION(nrow, ncol, ntime_step), INTENT(IN) :: q
    REAL(sp), DIMENSION(nrow, ncol, ntime_step), INTENT(IN) :: q_d
    REAL(sp), INTENT(OUT) :: qup
    REAL(sp), INTENT(OUT) :: qup_d
    INTEGER :: i, row_imd, col_imd
    INTEGER, DIMENSION(8), SAVE :: dcol=(/0, -1, -1, -1, 0, 1, 1, 1/)
    INTEGER, DIMENSION(8), SAVE :: drow=(/1, 1, 0, -1, -1, -1, 0, 1/)
    INTEGER, DIMENSION(8), SAVE :: dkind=(/1, 2, 3, 4, 5, 6, 7, 8/)
    INTRINSIC REAL
    REAL*4 :: temp
    qup = 0._sp
    IF (drained_area(row, col) .GT. 1) THEN
      qup_d = 0.0_4
      DO i=1,8
        col_imd = col + dcol(i)
        row_imd = row + drow(i)
        IF (col_imd .GT. 0 .AND. col_imd .LE. ncol .AND. row_imd .GT. 0 &
&           .AND. row_imd .LE. nrow) THEN
          IF (flow(row_imd, col_imd) .EQ. dkind(i)) THEN
            qup_d = qup_d + q_d(row_imd, col_imd, t)
            qup = qup + q(row_imd, col_imd, t)
          END IF
        END IF
      END DO
      temp = 0.001_sp*(dx*dx)*REAL(drained_area(row, col)-1)
      qup_d = dt*qup_d/temp
      qup = dt*(qup/temp)
    ELSE
      qup_d = 0.0_4
    END IF
  END SUBROUTINE UPSTREAM_DISCHARGE_D

  SUBROUTINE UPSTREAM_DISCHARGE(dt, dx, ntime_step, nrow, ncol, flow, &
&   drained_area, row, col, t, q, qup)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt, dx
    INTEGER, INTENT(IN) :: ntime_step, nrow, ncol, row, col, t
    INTEGER, DIMENSION(nrow, ncol), INTENT(IN) :: flow, drained_area
    REAL(sp), DIMENSION(nrow, ncol, ntime_step), INTENT(IN) :: q
    REAL(sp), INTENT(OUT) :: qup
    INTEGER :: i, row_imd, col_imd
    INTEGER, DIMENSION(8), SAVE :: dcol=(/0, -1, -1, -1, 0, 1, 1, 1/)
    INTEGER, DIMENSION(8), SAVE :: drow=(/1, 1, 0, -1, -1, -1, 0, 1/)
    INTEGER, DIMENSION(8), SAVE :: dkind=(/1, 2, 3, 4, 5, 6, 7, 8/)
    INTRINSIC REAL
    qup = 0._sp
    IF (drained_area(row, col) .GT. 1) THEN
      DO i=1,8
        col_imd = col + dcol(i)
        row_imd = row + drow(i)
        IF (col_imd .GT. 0 .AND. col_imd .LE. ncol .AND. row_imd .GT. 0 &
&           .AND. row_imd .LE. nrow) THEN
          IF (flow(row_imd, col_imd) .EQ. dkind(i)) qup = qup + q(&
&             row_imd, col_imd, t)
        END IF
      END DO
      qup = qup*dt/(0.001_sp*dx*dx*REAL(drained_area(row, col)-1))
    END IF
  END SUBROUTINE UPSTREAM_DISCHARGE

!  Differentiation of sparse_upstream_discharge in forward (tangent) mode (with options OpenMP context fixinterface):
!   variations   of useful results: qup
!   with respect to varying inputs: q
  SUBROUTINE SPARSE_UPSTREAM_DISCHARGE_D(dt, dx, ntime_step, nrow, ncol&
&   , nac, flow, drained_area, ind_sparse, row, col, t, q, q_d, qup, &
&   qup_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt, dx
    INTEGER, INTENT(IN) :: ntime_step, nrow, ncol, nac, row, col, t
    INTEGER, DIMENSION(nrow, ncol), INTENT(IN) :: flow, drained_area, &
&   ind_sparse
    REAL(sp), DIMENSION(nac, ntime_step), INTENT(IN) :: q
    REAL(sp), DIMENSION(nac, ntime_step), INTENT(IN) :: q_d
    REAL(sp), INTENT(OUT) :: qup
    REAL(sp), INTENT(OUT) :: qup_d
    INTEGER :: i, row_imd, col_imd, k
    INTEGER, DIMENSION(8), SAVE :: dcol=(/0, -1, -1, -1, 0, 1, 1, 1/)
    INTEGER, DIMENSION(8), SAVE :: drow=(/1, 1, 0, -1, -1, -1, 0, 1/)
    INTEGER, DIMENSION(8), SAVE :: dkind=(/1, 2, 3, 4, 5, 6, 7, 8/)
    INTRINSIC REAL
    REAL*4 :: temp
    qup = 0._sp
    IF (drained_area(row, col) .GT. 1) THEN
      qup_d = 0.0_4
      DO i=1,8
        col_imd = col + dcol(i)
        row_imd = row + drow(i)
        IF (col_imd .GT. 0 .AND. col_imd .LE. ncol .AND. row_imd .GT. 0 &
&           .AND. row_imd .LE. nrow) THEN
          IF (flow(row_imd, col_imd) .EQ. dkind(i)) THEN
            k = ind_sparse(row_imd, col_imd)
            qup_d = qup_d + q_d(k, t)
            qup = qup + q(k, t)
          END IF
        END IF
      END DO
      temp = 0.001_sp*(dx*dx)*REAL(drained_area(row, col)-1)
      qup_d = dt*qup_d/temp
      qup = dt*(qup/temp)
    ELSE
      qup_d = 0.0_4
    END IF
  END SUBROUTINE SPARSE_UPSTREAM_DISCHARGE_D

  SUBROUTINE SPARSE_UPSTREAM_DISCHARGE(dt, dx, ntime_step, nrow, ncol, &
&   nac, flow, drained_area, ind_sparse, row, col, t, q, qup)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt, dx
    INTEGER, INTENT(IN) :: ntime_step, nrow, ncol, nac, row, col, t
    INTEGER, DIMENSION(nrow, ncol), INTENT(IN) :: flow, drained_area, &
&   ind_sparse
    REAL(sp), DIMENSION(nac, ntime_step), INTENT(IN) :: q
    REAL(sp), INTENT(OUT) :: qup
    INTEGER :: i, row_imd, col_imd, k
    INTEGER, DIMENSION(8), SAVE :: dcol=(/0, -1, -1, -1, 0, 1, 1, 1/)
    INTEGER, DIMENSION(8), SAVE :: drow=(/1, 1, 0, -1, -1, -1, 0, 1/)
    INTEGER, DIMENSION(8), SAVE :: dkind=(/1, 2, 3, 4, 5, 6, 7, 8/)
    INTRINSIC REAL
    qup = 0._sp
    IF (drained_area(row, col) .GT. 1) THEN
      DO i=1,8
        col_imd = col + dcol(i)
        row_imd = row + drow(i)
        IF (col_imd .GT. 0 .AND. col_imd .LE. ncol .AND. row_imd .GT. 0 &
&           .AND. row_imd .LE. nrow) THEN
          IF (flow(row_imd, col_imd) .EQ. dkind(i)) THEN
            k = ind_sparse(row_imd, col_imd)
            qup = qup + q(k, t)
          END IF
        END IF
      END DO
      qup = qup*dt/(0.001_sp*dx*dx*REAL(drained_area(row, col)-1))
    END IF
  END SUBROUTINE SPARSE_UPSTREAM_DISCHARGE

!  Differentiation of gr_transfer1 in forward (tangent) mode (with options OpenMP context fixinterface):
!   variations   of useful results: hr qrout
!   with respect to varying inputs: qup hr lr
  SUBROUTINE GR_TRANSFER1_D(dt, qup, qup_d, lr, lr_d, hr, hr_d, qrout, &
&   qrout_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt
    REAL(sp), INTENT(IN) :: qup, lr
    REAL(sp), INTENT(IN) :: qup_d, lr_d
    REAL(sp), INTENT(INOUT) :: hr
    REAL(sp), INTENT(INOUT) :: hr_d
    REAL(sp), INTENT(OUT) :: qrout
    REAL(sp), INTENT(OUT) :: qrout_d
    REAL(sp) :: hr_imd
    REAL(sp) :: hr_imd_d
    INTRINSIC EXP
    REAL(sp) :: arg1
    REAL(sp) :: arg1_d
    REAL(sp) :: temp
    hr_imd_d = hr_d + qup_d
    hr_imd = hr + qup
    temp = dt/(60._sp*lr)
    arg1_d = temp*lr_d/lr
    arg1 = -temp
    temp = EXP(arg1)
    hr_d = temp*hr_imd_d + hr_imd*EXP(arg1)*arg1_d
    hr = hr_imd*temp
    qrout_d = hr_imd_d - hr_d
    qrout = hr_imd - hr
  END SUBROUTINE GR_TRANSFER1_D

  SUBROUTINE GR_TRANSFER1(dt, qup, lr, hr, qrout)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt
    REAL(sp), INTENT(IN) :: qup, lr
    REAL(sp), INTENT(INOUT) :: hr
    REAL(sp), INTENT(OUT) :: qrout
    REAL(sp) :: hr_imd
    INTRINSIC EXP
    REAL(sp) :: arg1
    hr_imd = hr + qup
    arg1 = -(dt/(lr*60._sp))
    hr = hr_imd*EXP(arg1)
    qrout = hr_imd - hr
  END SUBROUTINE GR_TRANSFER1

END MODULE MD_OPERATOR_DIFF_D

!%    This module `mw_states` encapsulates all SMASH states
MODULE MWD_STATES_DIFF_D
!% only: sp, dp, lchar, np, ns
  USE MD_COMMON
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
  IMPLICIT NONE
  TYPE STATESDT
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hi
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hp
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hft
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hst
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hr
  END TYPE STATESDT

CONTAINS
  SUBROUTINE STATESDT_INITIALISE(states, setup, mesh)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(STATESDT), INTENT(INOUT) :: states
    INTEGER :: nrow, ncol
    nrow = mesh%nrow
    ncol = mesh%ncol
    ALLOCATE(states%hi(nrow, ncol))
    ALLOCATE(states%hp(nrow, ncol))
    ALLOCATE(states%hft(nrow, ncol))
    ALLOCATE(states%hst(nrow, ncol))
    ALLOCATE(states%hr(nrow, ncol))
    CALL VECTOR_TO_STATES_DERIVED_TYPE(setup%default_states, states)
  END SUBROUTINE STATESDT_INITIALISE

  SUBROUTINE STATES_DERIVED_TYPE_TO_MATRIX(states, matrix)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(IN) :: states
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(states%hp, 1), SIZE(states%hp, 2), ns), &
&   INTENT(INOUT) :: matrix
    matrix(:, :, 1) = states%hi(:, :)
    matrix(:, :, 2) = states%hp(:, :)
    matrix(:, :, 3) = states%hft(:, :)
    matrix(:, :, 4) = states%hst(:, :)
    matrix(:, :, 5) = states%hr(:, :)
  END SUBROUTINE STATES_DERIVED_TYPE_TO_MATRIX

  SUBROUTINE MATRIX_TO_STATES_DERIVED_TYPE(matrix, states)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(INOUT) :: states
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(states%hp, 1), SIZE(states%hp, 2), ns), &
&   INTENT(IN) :: matrix
    states%hi(:, :) = matrix(:, :, 1)
    states%hp(:, :) = matrix(:, :, 2)
    states%hft(:, :) = matrix(:, :, 3)
    states%hst(:, :) = matrix(:, :, 4)
    states%hr(:, :) = matrix(:, :, 5)
  END SUBROUTINE MATRIX_TO_STATES_DERIVED_TYPE

  SUBROUTINE VECTOR_TO_STATES_DERIVED_TYPE(vector, states)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(INOUT) :: states
    REAL(sp), DIMENSION(ns), INTENT(IN) :: vector
    states%hi = vector(1)
    states%hp = vector(2)
    states%hft = vector(3)
    states%hst = vector(4)
    states%hr = vector(5)
  END SUBROUTINE VECTOR_TO_STATES_DERIVED_TYPE

END MODULE MWD_STATES_DIFF_D

!%    This module (wrap) `mw_parameters` encapsulates all SMASH parameters
MODULE MWD_PARAMETERS_DIFF_D
!% only: sp, dp, lchar, np, ns
  USE MD_COMMON
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
  IMPLICIT NONE
  TYPE PARAMETERSDT
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: ci
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cp
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: beta
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cft
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cst
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: alpha
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: exc
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: lr
  END TYPE PARAMETERSDT

CONTAINS
  SUBROUTINE PARAMETERSDT_INITIALISE(parameters, setup, mesh)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    INTEGER :: nrow, ncol
    nrow = mesh%nrow
    ncol = mesh%ncol
    ALLOCATE(parameters%ci(nrow, ncol))
    ALLOCATE(parameters%cp(nrow, ncol))
    ALLOCATE(parameters%beta(nrow, ncol))
    ALLOCATE(parameters%cft(nrow, ncol))
    ALLOCATE(parameters%cst(nrow, ncol))
    ALLOCATE(parameters%alpha(nrow, ncol))
    ALLOCATE(parameters%exc(nrow, ncol))
    ALLOCATE(parameters%lr(nrow, ncol))
    CALL VECTOR_TO_PARAMETERS_DERIVED_TYPE(setup%default_parameters, &
&                                    parameters)
  END SUBROUTINE PARAMETERSDT_INITIALISE

  SUBROUTINE PARAMETERS_DERIVED_TYPE_TO_MATRIX(parameters, matrix)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(parameters%cp, 1), SIZE(parameters%cp, 2), &
&   np), INTENT(INOUT) :: matrix
    matrix(:, :, 1) = parameters%ci(:, :)
    matrix(:, :, 2) = parameters%cp(:, :)
    matrix(:, :, 3) = parameters%beta(:, :)
    matrix(:, :, 4) = parameters%cft(:, :)
    matrix(:, :, 5) = parameters%cst(:, :)
    matrix(:, :, 6) = parameters%alpha(:, :)
    matrix(:, :, 7) = parameters%exc(:, :)
    matrix(:, :, 8) = parameters%lr(:, :)
  END SUBROUTINE PARAMETERS_DERIVED_TYPE_TO_MATRIX

  SUBROUTINE MATRIX_TO_PARAMETERS_DERIVED_TYPE(matrix, parameters)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(parameters%cp, 1), SIZE(parameters%cp, 2), &
&   np), INTENT(IN) :: matrix
    parameters%ci(:, :) = matrix(:, :, 1)
    parameters%cp(:, :) = matrix(:, :, 2)
    parameters%beta(:, :) = matrix(:, :, 3)
    parameters%cft(:, :) = matrix(:, :, 4)
    parameters%cst(:, :) = matrix(:, :, 5)
    parameters%alpha(:, :) = matrix(:, :, 6)
    parameters%exc(:, :) = matrix(:, :, 7)
    parameters%lr(:, :) = matrix(:, :, 8)
  END SUBROUTINE MATRIX_TO_PARAMETERS_DERIVED_TYPE

  SUBROUTINE VECTOR_TO_PARAMETERS_DERIVED_TYPE(vector, parameters)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    REAL(sp), DIMENSION(np), INTENT(IN) :: vector
    parameters%ci = vector(1)
    parameters%cp = vector(2)
    parameters%beta = vector(3)
    parameters%cft = vector(4)
    parameters%cst = vector(5)
    parameters%alpha = vector(6)
    parameters%exc = vector(7)
    parameters%lr = vector(8)
  END SUBROUTINE VECTOR_TO_PARAMETERS_DERIVED_TYPE

END MODULE MWD_PARAMETERS_DIFF_D

!  Differentiation of forward in forward (tangent) mode (with options OpenMP context fixinterface):
!   variations   of useful results: cost
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.alpha)
!                *(parameters.exc) *(parameters.lr) *(states.hi)
!                *(states.hp) *(states.hft) *(states.hr)
!   RW status of diff variables: parameters.ci:(loc) *(parameters.ci):in
!                parameters.cp:(loc) *(parameters.cp):in parameters.beta:(loc)
!                *(parameters.beta):in parameters.cft:(loc) *(parameters.cft):in
!                parameters.cst:(loc) *(parameters.cst):(loc) parameters.alpha:(loc)
!                *(parameters.alpha):in parameters.exc:(loc) *(parameters.exc):in
!                parameters.lr:(loc) *(parameters.lr):in *(output.qsim):(loc)
!                states.hi:(loc) *(states.hi):in-killed states.hp:(loc)
!                *(states.hp):in-killed states.hft:(loc) *(states.hft):in-killed
!                states.hst:(loc) *(states.hst):(loc) states.hr:(loc)
!                *(states.hr):in-killed cost:out
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.alpha:in
!                parameters.exc:in parameters.lr:in output.qsim:in
!                states.hi:in states.hp:in states.hft:in states.hr:in
SUBROUTINE FORWARD_D(setup, mesh, input_data, parameters, parameters_d, &
& states, states_d, output, output_d, cost, cost_d)
!% only: sp
  USE MD_COMMON
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: ParametersDT, parameters_derived_type_to_matrix
  USE MWD_PARAMETERS_DIFF_D
!% only: StatesDT
  USE MWD_STATES_DIFF_D
!% only: OutputDT
  USE MWD_OUTPUT_DIFF_D
!% only: GR_interception, GR_production, GR_exchange, &
  USE MD_OPERATOR_DIFF_D
!% & GR_transferN, upstream_discharge, sparse_upstream_discharge, GR_transfer1
!% only: compute_jobs
  USE MWD_COST_DIFF_D
  IMPLICIT NONE
  TYPE(SETUPDT), INTENT(IN) :: setup
  TYPE(MESHDT), INTENT(IN) :: mesh
  TYPE(INPUT_DATADT), INTENT(IN) :: input_data
  TYPE(PARAMETERSDT), INTENT(IN) :: parameters
  TYPE(PARAMETERSDT), INTENT(IN) :: parameters_d
  TYPE(STATESDT), INTENT(INOUT) :: states
  TYPE(STATESDT), INTENT(INOUT) :: states_d
  TYPE(OUTPUTDT), INTENT(INOUT) :: output
  TYPE(OUTPUTDT_DIFF_D), INTENT(INOUT) :: output_d
  REAL(sp), INTENT(INOUT) :: cost
  REAL(sp), INTENT(INOUT) :: cost_d
  INTEGER :: t, i, row, col, k, g, row_g, col_g, k_g
  REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prd, qd, qr, ql, &
& qt, qup, qrout
  REAL(sp) :: ei_d, pn_d, en_d, pr_d, perc_d, l_d, prr_d, prd_d, qd_d, &
& qr_d, qt_d, qup_d, qrout_d
  REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: q
  REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: q_d
  REAL(sp), DIMENSION(:, :), ALLOCATABLE :: sparse_q
  REAL(sp), DIMENSION(:, :), ALLOCATABLE :: sparse_q_d
  INTRINSIC MIN
  INTRINSIC MAX
  INTRINSIC REAL
  REAL(sp) :: temp
  REAL :: temp0
  IF (setup%sparse_storage) THEN
    ALLOCATE(sparse_q_d(mesh%nac, setup%ntime_step))
    ALLOCATE(sparse_q(mesh%nac, setup%ntime_step))
  ELSE
    ALLOCATE(q_d(mesh%nrow, mesh%ncol, setup%ntime_step))
    ALLOCATE(q(mesh%nrow, mesh%ncol, setup%ntime_step))
  END IF
  cost = 0._sp
  DO t=1,setup%ntime_step
    DO i=1,mesh%nrow*mesh%ncol
      ei = 0._sp
      pn = 0._sp
      en = 0._sp
      pr = 0._sp
      perc = 0._sp
      l = 0._sp
      prr = 0._sp
      prd = 0._sp
      qd = 0._sp
      qr = 0._sp
      ql = 0._sp
      qup = 0._sp
      qrout = 0._sp
!% {end if: path}
      IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
        row = mesh%path(1, i)
        col = mesh%path(2, i)
        IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, col&
&           )
!% {end if: global active cell}
        IF (mesh%global_active_cell(row, col) .EQ. 1 .AND. mesh%&
&           local_active_cell(row, col) .EQ. 1) THEN
          IF (setup%sparse_storage) THEN
            prcp = input_data%sparse_prcp(k, t)
            pet = input_data%sparse_pet(k, t)
          ELSE
            prcp = input_data%prcp(row, col, t)
            pet = input_data%pet(row, col, t)
          END IF
!% {end if: prcp ge 0}
          IF (prcp .GE. 0) THEN
!% -------------------------------- Interception module case
            SELECT CASE  (setup%interception_module) 
            CASE (0) 
              IF (pet .GT. prcp) THEN
                ei = prcp
              ELSE
                ei = pet
              END IF
              IF (0._sp .LT. prcp - ei) THEN
                pn = prcp - ei
                ei_d = 0.0_4
                pn_d = 0.0_4
              ELSE
                pn = 0._sp
                ei_d = 0.0_4
                pn_d = 0.0_4
              END IF
            CASE (1) 
              CALL GR_INTERCEPTION_D(prcp, pet, parameters%ci(row, col)&
&                              , parameters_d%ci(row, col), states%hi(&
&                              row, col), states_d%hi(row, col), pn, &
&                              pn_d, ei, ei_d)
            CASE DEFAULT
              ei_d = 0.0_4
              pn_d = 0.0_4
            END SELECT
            en_d = -ei_d
            en = pet - ei
            SELECT CASE  (setup%production_module) 
            CASE (0) 
!% -------------------------------- Production module case
              CALL GR_PRODUCTION_D(pn, pn_d, en, en_d, parameters%cp(row&
&                            , col), parameters_d%cp(row, col), &
&                            parameters%beta(row, col), parameters_d%&
&                            beta(row, col), states%hp(row, col), &
&                            states_d%hp(row, col), pr, pr_d, perc, &
&                            perc_d)
            CASE DEFAULT
              perc_d = 0.0_4
              pr_d = 0.0_4
            END SELECT
!% -------------------------------- Exchange module case
            SELECT CASE  (setup%exchange_module) 
            CASE (0) 
              l = 0._sp
              l_d = 0.0_4
            CASE (1) 
              CALL GR_EXCHANGE_D(parameters%exc(row, col), parameters_d%&
&                          exc(row, col), states%hft(row, col), states_d&
&                          %hft(row, col), l, l_d)
            CASE DEFAULT
              l_d = 0.0_4
            END SELECT
          ELSE
            l_d = 0.0_4
            perc_d = 0.0_4
            pr_d = 0.0_4
          END IF
!% ---------------------------- Transfer module case
          SELECT CASE  (setup%transfer_module) 
          CASE (0) 
            prr_d = (pr+perc)*parameters_d%alpha(row, col) + parameters%&
&             alpha(row, col)*(pr_d+perc_d) + l_d
            prr = parameters%alpha(row, col)*(pr+perc) + l
            prd_d = pr_d + perc_d - prr_d
            prd = pr + perc - prr
            CALL GR_TRANSFERN_D(5._sp, prcp, prr, prr_d, parameters%cft(&
&                         row, col), parameters_d%cft(row, col), states%&
&                         hft(row, col), states_d%hft(row, col), qr, &
&                         qr_d)
            IF (0._sp .LT. prd + l) THEN
              qd_d = prd_d + l_d
              qd = prd + l
            ELSE
              qd = 0._sp
              qd_d = 0.0_4
            END IF
          CASE DEFAULT
            qd_d = 0.0_4
            qr_d = 0.0_4
          END SELECT
          qt_d = qd_d + qr_d
          qt = qd + qr + ql
!% ------------------------ Routing module case
          SELECT CASE  (setup%routing_module) 
          CASE (0) 
            IF (setup%sparse_storage) THEN
              CALL SPARSE_UPSTREAM_DISCHARGE_D(setup%dt, setup%dx, setup&
&                                        %ntime_step, mesh%nrow, mesh%&
&                                        ncol, mesh%nac, mesh%flow, mesh&
&                                        %drained_area, mesh%&
&                                        rowcol_to_ind_sparse, row, col&
&                                        , t, sparse_q, sparse_q_d, qup&
&                                        , qup_d)
              temp = 0.001_sp*(setup%dx*setup%dx)
              temp0 = REAL(mesh%drained_area(row, col) - 1)
              sparse_q_d(k, t) = temp*(qt_d+temp0*qup_d)/setup%dt
              sparse_q(k, t) = temp*((qt+temp0*qup)/setup%dt)
            ELSE
              CALL UPSTREAM_DISCHARGE_D(setup%dt, setup%dx, setup%&
&                                 ntime_step, mesh%nrow, mesh%ncol, mesh&
&                                 %flow, mesh%drained_area, row, col, t&
&                                 , q, q_d, qup, qup_d)
              temp = 0.001_sp*(setup%dx*setup%dx)
              temp0 = REAL(mesh%drained_area(row, col) - 1)
              q_d(row, col, t) = temp*(qt_d+temp0*qup_d)/setup%dt
              q(row, col, t) = temp*((qt+temp0*qup)/setup%dt)
            END IF
          CASE (1) 
            IF (setup%sparse_storage) THEN
              CALL SPARSE_UPSTREAM_DISCHARGE_D(setup%dt, setup%dx, setup&
&                                        %ntime_step, mesh%nrow, mesh%&
&                                        ncol, mesh%nac, mesh%flow, mesh&
&                                        %drained_area, mesh%&
&                                        rowcol_to_ind_sparse, row, col&
&                                        , t, sparse_q, sparse_q_d, qup&
&                                        , qup_d)
              CALL GR_TRANSFER1_D(setup%dt, qup, qup_d, parameters%lr(&
&                           row, col), parameters_d%lr(row, col), states&
&                           %hr(row, col), states_d%hr(row, col), qrout&
&                           , qrout_d)
              temp = 0.001_sp*(setup%dx*setup%dx)
              temp0 = REAL(mesh%drained_area(row, col) - 1)
              sparse_q_d(k, t) = temp*(qt_d+temp0*qrout_d)/setup%dt
              sparse_q(k, t) = temp*((qt+temp0*qrout)/setup%dt)
            ELSE
              CALL UPSTREAM_DISCHARGE_D(setup%dt, setup%dx, setup%&
&                                 ntime_step, mesh%nrow, mesh%ncol, mesh&
&                                 %flow, mesh%drained_area, row, col, t&
&                                 , q, q_d, qup, qup_d)
              CALL GR_TRANSFER1_D(setup%dt, qup, qup_d, parameters%lr(&
&                           row, col), parameters_d%lr(row, col), states&
&                           %hr(row, col), states_d%hr(row, col), qrout&
&                           , qrout_d)
              temp = 0.001_sp*(setup%dx*setup%dx)
              temp0 = REAL(mesh%drained_area(row, col) - 1)
              q_d(row, col, t) = temp*(qt_d+temp0*qrout_d)/setup%dt
              q(row, col, t) = temp*((qt+temp0*qrout)/setup%dt)
            END IF
          END SELECT
        END IF
      END IF
    END DO
  END DO
  output_d%qsim = 0.0_4
!% {end do: space}
!% {end do: time}
  DO g=1,mesh%ng
    row_g = mesh%gauge_pos(1, g)
    col_g = mesh%gauge_pos(2, g)
    IF (setup%sparse_storage) THEN
      k_g = mesh%rowcol_to_ind_sparse(row_g, col_g)
      output_d%qsim(g, :) = sparse_q_d(k_g, :)
      output%qsim(g, :) = sparse_q(k_g, :)
    ELSE
      output_d%qsim(g, :) = q_d(row_g, col_g, :)
      output%qsim(g, :) = q(row_g, col_g, :)
    END IF
  END DO
  CALL COMPUTE_JOBS_D(setup, mesh, input_data, output, output_d, cost, &
&               cost_d)
END SUBROUTINE FORWARD_D

SUBROUTINE FORWARD_NODIFF_D(setup, mesh, input_data, parameters, states, &
& output, cost)
!% only: sp
  USE MD_COMMON
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: ParametersDT, parameters_derived_type_to_matrix
  USE MWD_PARAMETERS_DIFF_D
!% only: StatesDT
  USE MWD_STATES_DIFF_D
!% only: OutputDT
  USE MWD_OUTPUT_DIFF_D
!% only: GR_interception, GR_production, GR_exchange, &
  USE MD_OPERATOR_DIFF_D
!% & GR_transferN, upstream_discharge, sparse_upstream_discharge, GR_transfer1
!% only: compute_jobs
  USE MWD_COST_DIFF_D
  IMPLICIT NONE
  TYPE(SETUPDT), INTENT(IN) :: setup
  TYPE(MESHDT), INTENT(IN) :: mesh
  TYPE(INPUT_DATADT), INTENT(IN) :: input_data
  TYPE(PARAMETERSDT), INTENT(IN) :: parameters
  TYPE(STATESDT), INTENT(INOUT) :: states
  TYPE(OUTPUTDT), INTENT(INOUT) :: output
  REAL(sp), INTENT(INOUT) :: cost
  INTEGER :: t, i, row, col, k, g, row_g, col_g, k_g
  REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prd, qd, qr, ql, &
& qt, qup, qrout
  REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: q
  REAL(sp), DIMENSION(:, :), ALLOCATABLE :: sparse_q
  INTRINSIC MIN
  INTRINSIC MAX
  INTRINSIC REAL
  IF (setup%sparse_storage) THEN
    ALLOCATE(sparse_q(mesh%nac, setup%ntime_step))
  ELSE
    ALLOCATE(q(mesh%nrow, mesh%ncol, setup%ntime_step))
  END IF
  cost = 0._sp
  DO t=1,setup%ntime_step
    DO i=1,mesh%nrow*mesh%ncol
      ei = 0._sp
      pn = 0._sp
      en = 0._sp
      pr = 0._sp
      perc = 0._sp
      l = 0._sp
      prr = 0._sp
      prd = 0._sp
      qd = 0._sp
      qr = 0._sp
      ql = 0._sp
      qup = 0._sp
      qrout = 0._sp
!% {end if: path}
      IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
        row = mesh%path(1, i)
        col = mesh%path(2, i)
        IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, col&
&           )
!% {end if: global active cell}
        IF (mesh%global_active_cell(row, col) .EQ. 1 .AND. mesh%&
&           local_active_cell(row, col) .EQ. 1) THEN
          IF (setup%sparse_storage) THEN
            prcp = input_data%sparse_prcp(k, t)
            pet = input_data%sparse_pet(k, t)
          ELSE
            prcp = input_data%prcp(row, col, t)
            pet = input_data%pet(row, col, t)
          END IF
!% {end if: prcp ge 0}
          IF (prcp .GE. 0) THEN
!% -------------------------------- Interception module case
            SELECT CASE  (setup%interception_module) 
            CASE (0) 
              IF (pet .GT. prcp) THEN
                ei = prcp
              ELSE
                ei = pet
              END IF
              IF (0._sp .LT. prcp - ei) THEN
                pn = prcp - ei
              ELSE
                pn = 0._sp
              END IF
            CASE (1) 
              CALL GR_INTERCEPTION(prcp, pet, parameters%ci(row, col), &
&                            states%hi(row, col), pn, ei)
            END SELECT
            en = pet - ei
            SELECT CASE  (setup%production_module) 
            CASE (0) 
!% -------------------------------- Production module case
              CALL GR_PRODUCTION(pn, en, parameters%cp(row, col), &
&                          parameters%beta(row, col), states%hp(row, col&
&                          ), pr, perc)
            END SELECT
!% -------------------------------- Exchange module case
            SELECT CASE  (setup%exchange_module) 
            CASE (0) 
              l = 0._sp
            CASE (1) 
              CALL GR_EXCHANGE(parameters%exc(row, col), states%hft(row&
&                        , col), l)
            END SELECT
          END IF
!% ---------------------------- Transfer module case
          SELECT CASE  (setup%transfer_module) 
          CASE (0) 
            prr = parameters%alpha(row, col)*(pr+perc) + l
            prd = pr + perc - prr
            CALL GR_TRANSFERN(5._sp, prcp, prr, parameters%cft(row, col)&
&                       , states%hft(row, col), qr)
            IF (0._sp .LT. prd + l) THEN
              qd = prd + l
            ELSE
              qd = 0._sp
            END IF
          END SELECT
          qt = qd + qr + ql
!% ------------------------ Routing module case
          SELECT CASE  (setup%routing_module) 
          CASE (0) 
            IF (setup%sparse_storage) THEN
              CALL SPARSE_UPSTREAM_DISCHARGE(setup%dt, setup%dx, setup%&
&                                      ntime_step, mesh%nrow, mesh%ncol&
&                                      , mesh%nac, mesh%flow, mesh%&
&                                      drained_area, mesh%&
&                                      rowcol_to_ind_sparse, row, col, t&
&                                      , sparse_q, qup)
              sparse_q(k, t) = (qt+qup*REAL(mesh%drained_area(row, col)-&
&               1))*setup%dx*setup%dx*0.001_sp/setup%dt
            ELSE
              CALL UPSTREAM_DISCHARGE(setup%dt, setup%dx, setup%&
&                               ntime_step, mesh%nrow, mesh%ncol, mesh%&
&                               flow, mesh%drained_area, row, col, t, q&
&                               , qup)
              q(row, col, t) = (qt+qup*REAL(mesh%drained_area(row, col)-&
&               1))*setup%dx*setup%dx*0.001_sp/setup%dt
            END IF
          CASE (1) 
            IF (setup%sparse_storage) THEN
              CALL SPARSE_UPSTREAM_DISCHARGE(setup%dt, setup%dx, setup%&
&                                      ntime_step, mesh%nrow, mesh%ncol&
&                                      , mesh%nac, mesh%flow, mesh%&
&                                      drained_area, mesh%&
&                                      rowcol_to_ind_sparse, row, col, t&
&                                      , sparse_q, qup)
              CALL GR_TRANSFER1(setup%dt, qup, parameters%lr(row, col), &
&                         states%hr(row, col), qrout)
              sparse_q(k, t) = (qt+qrout*REAL(mesh%drained_area(row, col&
&               )-1))*setup%dx*setup%dx*0.001_sp/setup%dt
            ELSE
              CALL UPSTREAM_DISCHARGE(setup%dt, setup%dx, setup%&
&                               ntime_step, mesh%nrow, mesh%ncol, mesh%&
&                               flow, mesh%drained_area, row, col, t, q&
&                               , qup)
              CALL GR_TRANSFER1(setup%dt, qup, parameters%lr(row, col), &
&                         states%hr(row, col), qrout)
              q(row, col, t) = (qt+qrout*REAL(mesh%drained_area(row, col&
&               )-1))*setup%dx*setup%dx*0.001_sp/setup%dt
            END IF
          END SELECT
        END IF
      END IF
    END DO
  END DO
!% {end do: space}
!% {end do: time}
  DO g=1,mesh%ng
    row_g = mesh%gauge_pos(1, g)
    col_g = mesh%gauge_pos(2, g)
    IF (setup%sparse_storage) THEN
      k_g = mesh%rowcol_to_ind_sparse(row_g, col_g)
      output%qsim(g, :) = sparse_q(k_g, :)
    ELSE
      output%qsim(g, :) = q(row_g, col_g, :)
    END IF
  END DO
  CALL COMPUTE_JOBS(setup, mesh, input_data, output, cost)
END SUBROUTINE FORWARD_NODIFF_D

