!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!%      This module `mwd_output` encapsulates all SMASH output.
!%      This module is wrapped and differentiated.
!%
!%      OutputDT type:
!%      
!%      ======================== =======================================
!%      `Variables`              Description
!%      ======================== =======================================
!%      ``qsim``                 Simulated discharge at gauge            [m3/s]
!%      ``qsim_domain``          Simulated discharge whole domain        [m3/s]
!%      ``sparse_qsim_domain``   Sparse simulated discharge whole domain [m3/s]
!%      ``parameters_gradient``  Parameters gradients
!%      ``sp1``                  Scalar product <dY*, dY>
!%      ``sp2``                  Scalar product <dk*, dk>
!%      ``an``                   Alpha gradient test 
!%      ``Ian``                  Ialpha gradient test
!%      ======================== =======================================
!%
!%      contains
!%
!%      [1] OutputDT_initialise
MODULE MWD_OUTPUT_DIFF_D
!% only: sp, dp, lchar, np, ns
  USE MWD_COMMON
!% only: SetupDT
  USE MWD_SETUP
!%only: MeshDT
  USE MWD_MESH
  IMPLICIT NONE
  TYPE OUTPUTDT
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: qsim
      REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: qsim_domain
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: sparse_qsim_domain
      REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: parameters_gradient
      REAL(sp) :: sp1
      REAL(sp) :: sp2
      REAL(sp), DIMENSION(:), ALLOCATABLE :: an
      REAL(sp), DIMENSION(:), ALLOCATABLE :: ian
  END TYPE OUTPUTDT
  TYPE OUTPUTDT_DIFF_D
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: qsim
  END TYPE OUTPUTDT_DIFF_D

CONTAINS
  SUBROUTINE OUTPUTDT_INITIALISE(output, setup, mesh)
    IMPLICIT NONE
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(SETUPDT), INTENT(INOUT) :: setup
    TYPE(MESHDT), INTENT(INOUT) :: mesh
    ALLOCATE(output%qsim(mesh%ng, setup%ntime_step))
    output%qsim = -99._sp
    IF (setup%save_qsim_domain) THEN
      IF (setup%sparse_storage) THEN
        ALLOCATE(output%sparse_qsim_domain(mesh%nac, setup%ntime_step))
        output%sparse_qsim_domain = -99._sp
      ELSE
        ALLOCATE(output%qsim_domain(mesh%nrow, mesh%ncol, setup%&
&       ntime_step))
        output%qsim_domain = -99._sp
      END IF
    END IF
  END SUBROUTINE OUTPUTDT_INITIALISE

!%      TODO comment 
  SUBROUTINE OUTPUT_COPY(output_in, output_out)
    IMPLICIT NONE
    TYPE(OUTPUTDT), INTENT(IN) :: output_in
    TYPE(OUTPUTDT), INTENT(OUT) :: output_out
    output_out = output_in
  END SUBROUTINE OUTPUT_COPY

END MODULE MWD_OUTPUT_DIFF_D

!%    This module `mw_cost` encapsulates all SMASH cost (type, subroutines, functions)
MODULE MWD_COST_DIFF_D
!% only: sp, dp, lchar, np, ns
  USE MWD_COMMON
!% only: SetupDT
  USE MWD_SETUP
!%only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: OutputDT
  USE MWD_OUTPUT_DIFF_D
  IMPLICIT NONE

CONTAINS
!  Differentiation of compute_jobs in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: jobs
!   with respect to varying inputs: *(output.qsim)
!   Plus diff mem management of: output.qsim:in
  SUBROUTINE COMPUTE_JOBS_D(setup, mesh, input_data, output, output_d, &
&   jobs, jobs_d)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT_DIFF_D), INTENT(INOUT) :: output_d
    REAL(sp), INTENT(OUT) :: jobs
    REAL(sp), INTENT(OUT) :: jobs_d
    REAL(sp), DIMENSION(setup%ntime_step-setup%optim_start_step+1) :: qo&
&   , qs
    REAL(sp), DIMENSION(setup%ntime_step-setup%optim_start_step+1) :: &
&   qs_d
    INTEGER :: g, row, col
    INTRINSIC REAL
    INTRINSIC ANY
    REAL(sp) :: result1
    REAL(sp) :: result1_d
    jobs = 0._sp
    jobs_d = 0.0_4
    DO g=1,mesh%ng
      IF (mesh%optim_gauge(g) .EQ. 1) THEN
        qs_d = setup%dt*1e3_sp*output_d%qsim(g, setup%optim_start_step:&
&         setup%ntime_step)/mesh%area(g)
        qs = output%qsim(g, setup%optim_start_step:setup%ntime_step)*&
&         setup%dt/mesh%area(g)*1e3_sp
        row = mesh%gauge_pos(1, g)
        col = mesh%gauge_pos(2, g)
        qo = input_data%qobs(g, setup%optim_start_step:setup%ntime_step)&
&         *setup%dt/(REAL(mesh%drained_area(row, col))*mesh%dx*mesh%dx)*&
&         1e3_sp
        IF (ANY(qo .GE. 0._sp)) THEN
          result1_d = NSE_D(qo, qs, qs_d, result1)
          jobs_d = jobs_d + result1_d
          jobs = jobs + result1
        END IF
      END IF
    END DO
  END SUBROUTINE COMPUTE_JOBS_D

  SUBROUTINE COMPUTE_JOBS(setup, mesh, input_data, output, jobs)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    REAL(sp), INTENT(OUT) :: jobs
    REAL(sp), DIMENSION(setup%ntime_step-setup%optim_start_step+1) :: qo&
&   , qs
    INTEGER :: g, row, col
    INTRINSIC REAL
    INTRINSIC ANY
    REAL(sp) :: result1
    jobs = 0._sp
    DO g=1,mesh%ng
      IF (mesh%optim_gauge(g) .EQ. 1) THEN
        qs = output%qsim(g, setup%optim_start_step:setup%ntime_step)*&
&         setup%dt/mesh%area(g)*1e3_sp
        row = mesh%gauge_pos(1, g)
        col = mesh%gauge_pos(2, g)
        qo = input_data%qobs(g, setup%optim_start_step:setup%ntime_step)&
&         *setup%dt/(REAL(mesh%drained_area(row, col))*mesh%dx*mesh%dx)*&
&         1e3_sp
        IF (ANY(qo .GE. 0._sp)) THEN
          result1 = NSE(qo, qs)
          jobs = jobs + result1
        END IF
      END IF
    END DO
  END SUBROUTINE COMPUTE_JOBS

!  Differentiation of nse in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: res
!   with respect to varying inputs: y
!~         subroutine compute_jreg
!~         end subroutine compute_jreg
  FUNCTION NSE_D(x, y, y_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:), INTENT(IN) :: y_d
    REAL(sp) :: res
    REAL(sp) :: res_d
    REAL(sp) :: sum_x, sum_xx, sum_yy, sum_xy, mean_x, num, den
    REAL(sp) :: sum_yy_d, sum_xy_d, num_d
    INTEGER :: i, n
    INTRINSIC SIZE
!% Metric computation
    n = 0
    sum_x = 0.
    sum_xx = 0.
    sum_yy = 0.
    sum_xy = 0.
    sum_yy_d = 0.0_4
    sum_xy_d = 0.0_4
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0.) THEN
        n = n + 1
        sum_x = sum_x + x(i)
        sum_xx = sum_xx + x(i)*x(i)
        sum_yy_d = sum_yy_d + 2*y(i)*y_d(i)
        sum_yy = sum_yy + y(i)*y(i)
        sum_xy_d = sum_xy_d + x(i)*y_d(i)
        sum_xy = sum_xy + x(i)*y(i)
      END IF
    END DO
    mean_x = sum_x/n
!% NSE numerator / denominator
    num_d = sum_yy_d - 2*sum_xy_d
    num = sum_xx - 2*sum_xy + sum_yy
    den = sum_xx - n*mean_x*mean_x
!% NSE criterion
    res_d = num_d/den
    res = num/den
  END FUNCTION NSE_D

!~         subroutine compute_jreg
!~         end subroutine compute_jreg
  FUNCTION NSE(x, y) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp) :: res
    REAL(sp) :: sum_x, sum_xx, sum_yy, sum_xy, mean_x, num, den
    INTEGER :: i, n
    INTRINSIC SIZE
!% Metric computation
    n = 0
    sum_x = 0.
    sum_xx = 0.
    sum_yy = 0.
    sum_xy = 0.
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0.) THEN
        n = n + 1
        sum_x = sum_x + x(i)
        sum_xx = sum_xx + x(i)*x(i)
        sum_yy = sum_yy + y(i)*y(i)
        sum_xy = sum_xy + x(i)*y(i)
      END IF
    END DO
    mean_x = sum_x/n
!% NSE numerator / denominator
    num = sum_xx - 2*sum_xy + sum_yy
    den = sum_xx - n*mean_x*mean_x
!% NSE criterion
    res = num/den
  END FUNCTION NSE

END MODULE MWD_COST_DIFF_D

!%      This module `md_operator` encapsulates all SMASH operator.
!%      This module is differentiated.
!%
!%      contains
!%
!%      [1] GR_interception
!%      [2] GR_production
!%      [3] GR_exchange
!%      [4] GR_transferN
!%      [5] upstream_discharge
!%      [6] sparse_upstream_discharge
!%      [7] GR_transfer1
MODULE MD_OPERATOR_DIFF_D
!% only : sp
  USE MWD_COMMON
  IMPLICIT NONE

CONTAINS
!  Differentiation of gr_interception in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: hi ei pn
!   with respect to varying inputs: hi ci
!% TODO Renommer argument pour etre global
  SUBROUTINE GR_INTERCEPTION_D(prcp, pet, ci, ci_d, hi, hi_d, pn, pn_d, &
&   ei, ei_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: prcp, pet, ci
    REAL(sp), INTENT(IN) :: ci_d
    REAL(sp), INTENT(INOUT) :: hi
    REAL(sp), INTENT(INOUT) :: hi_d
    REAL(sp), INTENT(OUT) :: pn, ei
    REAL(sp), INTENT(OUT) :: pn_d, ei_d
    INTRINSIC MIN
    INTRINSIC MAX
    REAL(sp) :: temp
    IF (pet .GT. prcp + hi*ci) THEN
      ei_d = ci*hi_d + hi*ci_d
      ei = prcp + hi*ci
    ELSE
      ei = pet
      ei_d = 0.0_4
    END IF
    IF (0._sp .LT. prcp - ci*(1._sp-hi) - ei) THEN
      pn_d = ci*hi_d - (1._sp-hi)*ci_d - ei_d
      pn = prcp - ci*(1._sp-hi) - ei
    ELSE
      pn = 0._sp
      pn_d = 0.0_4
    END IF
    temp = (prcp-ei-pn)/ci
    hi_d = hi_d + (-ei_d-pn_d-temp*ci_d)/ci
    hi = hi + temp
  END SUBROUTINE GR_INTERCEPTION_D

!% TODO Renommer argument pour etre global
  SUBROUTINE GR_INTERCEPTION(prcp, pet, ci, hi, pn, ei)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: prcp, pet, ci
    REAL(sp), INTENT(INOUT) :: hi
    REAL(sp), INTENT(OUT) :: pn, ei
    INTRINSIC MIN
    INTRINSIC MAX
    IF (pet .GT. prcp + hi*ci) THEN
      ei = prcp + hi*ci
    ELSE
      ei = pet
    END IF
    IF (0._sp .LT. prcp - ci*(1._sp-hi) - ei) THEN
      pn = prcp - ci*(1._sp-hi) - ei
    ELSE
      pn = 0._sp
    END IF
    hi = hi + (prcp-ei-pn)/ci
  END SUBROUTINE GR_INTERCEPTION

!  Differentiation of gr_production in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: hp perc pr
!   with respect to varying inputs: hp en beta cp pn
  SUBROUTINE GR_PRODUCTION_D(pn, pn_d, en, en_d, cp, cp_d, beta, beta_d&
&   , hp, hp_d, pr, pr_d, perc, perc_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: pn, en, cp, beta
    REAL(sp), INTENT(IN) :: pn_d, en_d, cp_d, beta_d
    REAL(sp), INTENT(INOUT) :: hp
    REAL(sp), INTENT(INOUT) :: hp_d
    REAL(sp), INTENT(OUT) :: pr, perc
    REAL(sp), INTENT(OUT) :: pr_d, perc_d
    REAL(sp) :: inv_cp, ps, es, hp_imd
    REAL(sp) :: inv_cp_d, ps_d, es_d, hp_imd_d
    INTRINSIC TANH
    REAL(sp) :: pwx1
    REAL(sp) :: pwx1_d
    REAL(sp) :: pwr1
    REAL(sp) :: pwr1_d
    REAL(sp) :: temp
    REAL(sp) :: temp0
    REAL(sp) :: temp1
    REAL(sp) :: temp2
    inv_cp_d = -(cp_d/cp**2)
    inv_cp = 1._sp/cp
    pr = 0._sp
    temp = TANH(pn*inv_cp)
    temp0 = TANH(pn*inv_cp)
    temp1 = cp*(-(hp*hp)+1._sp)
    temp2 = temp1*temp0/(hp*temp+1._sp)
    ps_d = (temp0*((1._sp-hp**2)*cp_d-cp*2*hp*hp_d)+temp1*(1.0-TANH(pn*&
&     inv_cp)**2)*(inv_cp*pn_d+pn*inv_cp_d)-temp2*(temp*hp_d+hp*(1.0-&
&     TANH(pn*inv_cp)**2)*(inv_cp*pn_d+pn*inv_cp_d)))/(hp*temp+1._sp)
    ps = temp2
    temp2 = TANH(en*inv_cp)
    temp1 = TANH(en*inv_cp)
    temp0 = hp*cp*(-hp+2._sp)
    temp = temp0*temp1/((-hp+1._sp)*temp2+1._sp)
    es_d = (temp1*((2._sp-hp)*(cp*hp_d+hp*cp_d)-hp*cp*hp_d)+temp0*(1.0-&
&     TANH(en*inv_cp)**2)*(inv_cp*en_d+en*inv_cp_d)-temp*((1._sp-hp)*(&
&     1.0-TANH(en*inv_cp)**2)*(inv_cp*en_d+en*inv_cp_d)-temp2*hp_d))/((&
&     1._sp-hp)*temp2+1._sp)
    es = temp
    hp_imd_d = hp_d + inv_cp*(ps_d-es_d) + (ps-es)*inv_cp_d
    hp_imd = hp + (ps-es)*inv_cp
    IF (pn .GT. 0) THEN
      pr_d = pn_d - cp*(hp_imd_d-hp_d) - (hp_imd-hp)*cp_d
      pr = pn - (hp_imd-hp)*cp
    ELSE
      pr_d = 0.0_4
    END IF
    pwx1_d = 4*hp_imd**3*(hp_imd_d-hp_imd*beta_d/beta)/beta**4
    pwx1 = 1._sp + (hp_imd/beta)**4
    pwr1_d = -(0.25_sp*pwx1**(-1.25)*pwx1_d)
    pwr1 = pwx1**(-0.25_sp)
    perc_d = (1._sp-pwr1)*(cp*hp_imd_d+hp_imd*cp_d) - hp_imd*cp*pwr1_d
    perc = hp_imd*cp*(1._sp-pwr1)
    hp_d = hp_imd_d - inv_cp*perc_d - perc*inv_cp_d
    hp = hp_imd - perc*inv_cp
  END SUBROUTINE GR_PRODUCTION_D

  SUBROUTINE GR_PRODUCTION(pn, en, cp, beta, hp, pr, perc)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: pn, en, cp, beta
    REAL(sp), INTENT(INOUT) :: hp
    REAL(sp), INTENT(OUT) :: pr, perc
    REAL(sp) :: inv_cp, ps, es, hp_imd
    INTRINSIC TANH
    REAL(sp) :: pwx1
    REAL(sp) :: pwr1
    inv_cp = 1._sp/cp
    pr = 0._sp
    ps = cp*(1._sp-hp*hp)*TANH(pn*inv_cp)/(1._sp+hp*TANH(pn*inv_cp))
    es = hp*cp*(2._sp-hp)*TANH(en*inv_cp)/(1._sp+(1._sp-hp)*TANH(en*&
&     inv_cp))
    hp_imd = hp + (ps-es)*inv_cp
    IF (pn .GT. 0) pr = pn - (hp_imd-hp)*cp
    pwx1 = 1._sp + (hp_imd/beta)**4
    pwr1 = pwx1**(-0.25_sp)
    perc = hp_imd*cp*(1._sp-pwr1)
    hp = hp_imd - perc*inv_cp
  END SUBROUTINE GR_PRODUCTION

!  Differentiation of gr_exchange in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: l
!   with respect to varying inputs: hft exc
  SUBROUTINE GR_EXCHANGE_D(exc, exc_d, hft, hft_d, l, l_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: exc
    REAL(sp), INTENT(IN) :: exc_d
    REAL(sp), INTENT(INOUT) :: hft
    REAL(sp), INTENT(INOUT) :: hft_d
    REAL(sp), INTENT(OUT) :: l
    REAL(sp), INTENT(OUT) :: l_d
    REAL(sp) :: temp
    temp = hft**3.5_sp
    l_d = temp*exc_d + exc*3.5_sp*hft**2.5*hft_d
    l = exc*temp
  END SUBROUTINE GR_EXCHANGE_D

  SUBROUTINE GR_EXCHANGE(exc, hft, l)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: exc
    REAL(sp), INTENT(INOUT) :: hft
    REAL(sp), INTENT(OUT) :: l
    l = exc*hft**3.5_sp
  END SUBROUTINE GR_EXCHANGE

!  Differentiation of gr_transfern in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: q ht
!   with respect to varying inputs: ht ct pr
  SUBROUTINE GR_TRANSFERN_D(n, prcp, pr, pr_d, ct, ct_d, ht, ht_d, q, &
&   q_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: n, prcp, pr, ct
    REAL(sp), INTENT(IN) :: pr_d, ct_d
    REAL(sp), INTENT(INOUT) :: ht
    REAL(sp), INTENT(INOUT) :: ht_d
    REAL(sp), INTENT(OUT) :: q
    REAL(sp), INTENT(OUT) :: q_d
    REAL(sp) :: pr_imd, ht_imd, nm1, d1pnm1
    REAL(sp) :: pr_imd_d, ht_imd_d
    INTRINSIC MAX
    REAL(sp) :: pwx1
    REAL(sp) :: pwx1_d
    REAL(sp) :: pwy1
    REAL(sp) :: pwr1
    REAL(sp) :: pwr1_d
    REAL(sp) :: pwy2
    REAL(sp) :: pwr2
    REAL(sp) :: pwr2_d
    REAL(sp) :: pwx3
    REAL(sp) :: pwx3_d
    REAL(sp) :: pwy3
    REAL(sp) :: pwr3
    REAL(sp) :: pwr3_d
    nm1 = n - 1._sp
    d1pnm1 = 1._sp/nm1
    IF (prcp .LT. 0._sp) THEN
      pwx1_d = ct*ht_d + ht*ct_d
      pwx1 = ht*ct
      pwy1 = -nm1
      IF (pwx1 .LE. 0.0 .AND. (pwy1 .EQ. 0.0 .OR. pwy1 .NE. INT(pwy1))) &
&     THEN
        pwr1_d = 0.0_4
      ELSE
        pwr1_d = pwy1*pwx1**(pwy1-1)*pwx1_d
      END IF
      pwr1 = pwx1**pwy1
      pwy2 = -nm1
      IF (ct .LE. 0.0 .AND. (pwy2 .EQ. 0.0 .OR. pwy2 .NE. INT(pwy2))) &
&     THEN
        pwr2_d = 0.0_4
      ELSE
        pwr2_d = pwy2*ct**(pwy2-1)*ct_d
      END IF
      pwr2 = ct**pwy2
      pwx3_d = pwr1_d - pwr2_d
      pwx3 = pwr1 - pwr2
      pwy3 = -d1pnm1
      IF (pwx3 .LE. 0.0 .AND. (pwy3 .EQ. 0.0 .OR. pwy3 .NE. INT(pwy3))) &
&     THEN
        pwr3_d = 0.0_4
      ELSE
        pwr3_d = pwy3*pwx3**(pwy3-1)*pwx3_d
      END IF
      pwr3 = pwx3**pwy3
      pr_imd_d = pwr3_d - ct*ht_d - ht*ct_d
      pr_imd = pwr3 - ht*ct
    ELSE
      pr_imd_d = pr_d
      pr_imd = pr
    END IF
    IF (1.e-6_sp .LT. ht + pr_imd/ct) THEN
      ht_imd_d = ht_d + (pr_imd_d-pr_imd*ct_d/ct)/ct
      ht_imd = ht + pr_imd/ct
    ELSE
      ht_imd = 1.e-6_sp
      ht_imd_d = 0.0_4
    END IF
    pwx1_d = ct*ht_imd_d + ht_imd*ct_d
    pwx1 = ht_imd*ct
    pwy1 = -nm1
    IF (pwx1 .LE. 0.0 .AND. (pwy1 .EQ. 0.0 .OR. pwy1 .NE. INT(pwy1))) &
&   THEN
      pwr1_d = 0.0_4
    ELSE
      pwr1_d = pwy1*pwx1**(pwy1-1)*pwx1_d
    END IF
    pwr1 = pwx1**pwy1
    pwy2 = -nm1
    IF (ct .LE. 0.0 .AND. (pwy2 .EQ. 0.0 .OR. pwy2 .NE. INT(pwy2))) THEN
      pwr2_d = 0.0_4
    ELSE
      pwr2_d = pwy2*ct**(pwy2-1)*ct_d
    END IF
    pwr2 = ct**pwy2
    pwx3_d = pwr1_d + pwr2_d
    pwx3 = pwr1 + pwr2
    pwy3 = -d1pnm1
    IF (pwx3 .LE. 0.0 .AND. (pwy3 .EQ. 0.0 .OR. pwy3 .NE. INT(pwy3))) &
&   THEN
      pwr3_d = 0.0_4
    ELSE
      pwr3_d = pwy3*pwx3**(pwy3-1)*pwx3_d
    END IF
    pwr3 = pwx3**pwy3
    ht_d = (pwr3_d-pwr3*ct_d/ct)/ct
    ht = pwr3/ct
    q_d = ct*(ht_imd_d-ht_d) + (ht_imd-ht)*ct_d
    q = (ht_imd-ht)*ct
  END SUBROUTINE GR_TRANSFERN_D

  SUBROUTINE GR_TRANSFERN(n, prcp, pr, ct, ht, q)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: n, prcp, pr, ct
    REAL(sp), INTENT(INOUT) :: ht
    REAL(sp), INTENT(OUT) :: q
    REAL(sp) :: pr_imd, ht_imd, nm1, d1pnm1
    INTRINSIC MAX
    REAL(sp) :: pwx1
    REAL(sp) :: pwy1
    REAL(sp) :: pwr1
    REAL(sp) :: pwy2
    REAL(sp) :: pwr2
    REAL(sp) :: pwx3
    REAL(sp) :: pwy3
    REAL(sp) :: pwr3
    nm1 = n - 1._sp
    d1pnm1 = 1._sp/nm1
    IF (prcp .LT. 0._sp) THEN
      pwx1 = ht*ct
      pwy1 = -nm1
      pwr1 = pwx1**pwy1
      pwy2 = -nm1
      pwr2 = ct**pwy2
      pwx3 = pwr1 - pwr2
      pwy3 = -d1pnm1
      pwr3 = pwx3**pwy3
      pr_imd = pwr3 - ht*ct
    ELSE
      pr_imd = pr
    END IF
    IF (1.e-6_sp .LT. ht + pr_imd/ct) THEN
      ht_imd = ht + pr_imd/ct
    ELSE
      ht_imd = 1.e-6_sp
    END IF
    pwx1 = ht_imd*ct
    pwy1 = -nm1
    pwr1 = pwx1**pwy1
    pwy2 = -nm1
    pwr2 = ct**pwy2
    pwx3 = pwr1 + pwr2
    pwy3 = -d1pnm1
    pwr3 = pwx3**pwy3
    ht = pwr3/ct
    q = (ht_imd-ht)*ct
  END SUBROUTINE GR_TRANSFERN

!  Differentiation of upstream_discharge in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: qup
!   with respect to varying inputs: q
  SUBROUTINE UPSTREAM_DISCHARGE_D(dt, dx, nrow, ncol, flow, drained_area&
&   , row, col, q, q_d, qup, qup_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt, dx
    INTEGER, INTENT(IN) :: nrow, ncol, row, col
    INTEGER, DIMENSION(nrow, ncol), INTENT(IN) :: flow, drained_area
    REAL(sp), DIMENSION(nrow, ncol), INTENT(IN) :: q
    REAL(sp), DIMENSION(nrow, ncol), INTENT(IN) :: q_d
    REAL(sp), INTENT(OUT) :: qup
    REAL(sp), INTENT(OUT) :: qup_d
    INTEGER :: i, row_imd, col_imd
    INTEGER, DIMENSION(8), SAVE :: dcol=(/0, -1, -1, -1, 0, 1, 1, 1/)
    INTEGER, DIMENSION(8), SAVE :: drow=(/1, 1, 0, -1, -1, -1, 0, 1/)
    INTEGER, DIMENSION(8), SAVE :: dkind=(/1, 2, 3, 4, 5, 6, 7, 8/)
    INTRINSIC REAL
    REAL*4 :: temp
    qup = 0._sp
    IF (drained_area(row, col) .GT. 1) THEN
      qup_d = 0.0_4
      DO i=1,8
        col_imd = col + dcol(i)
        row_imd = row + drow(i)
        IF (col_imd .GT. 0 .AND. col_imd .LE. ncol .AND. row_imd .GT. 0 &
&           .AND. row_imd .LE. nrow) THEN
          IF (flow(row_imd, col_imd) .EQ. dkind(i)) THEN
            qup_d = qup_d + q_d(row_imd, col_imd)
            qup = qup + q(row_imd, col_imd)
          END IF
        END IF
      END DO
      temp = 0.001_sp*(dx*dx)*REAL(drained_area(row, col)-1)
      qup_d = dt*qup_d/temp
      qup = dt*(qup/temp)
    ELSE
      qup_d = 0.0_4
    END IF
  END SUBROUTINE UPSTREAM_DISCHARGE_D

  SUBROUTINE UPSTREAM_DISCHARGE(dt, dx, nrow, ncol, flow, drained_area, &
&   row, col, q, qup)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt, dx
    INTEGER, INTENT(IN) :: nrow, ncol, row, col
    INTEGER, DIMENSION(nrow, ncol), INTENT(IN) :: flow, drained_area
    REAL(sp), DIMENSION(nrow, ncol), INTENT(IN) :: q
    REAL(sp), INTENT(OUT) :: qup
    INTEGER :: i, row_imd, col_imd
    INTEGER, DIMENSION(8), SAVE :: dcol=(/0, -1, -1, -1, 0, 1, 1, 1/)
    INTEGER, DIMENSION(8), SAVE :: drow=(/1, 1, 0, -1, -1, -1, 0, 1/)
    INTEGER, DIMENSION(8), SAVE :: dkind=(/1, 2, 3, 4, 5, 6, 7, 8/)
    INTRINSIC REAL
    qup = 0._sp
    IF (drained_area(row, col) .GT. 1) THEN
      DO i=1,8
        col_imd = col + dcol(i)
        row_imd = row + drow(i)
        IF (col_imd .GT. 0 .AND. col_imd .LE. ncol .AND. row_imd .GT. 0 &
&           .AND. row_imd .LE. nrow) THEN
          IF (flow(row_imd, col_imd) .EQ. dkind(i)) qup = qup + q(&
&             row_imd, col_imd)
        END IF
      END DO
      qup = qup*dt/(0.001_sp*dx*dx*REAL(drained_area(row, col)-1))
    END IF
  END SUBROUTINE UPSTREAM_DISCHARGE

!  Differentiation of sparse_upstream_discharge in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: qup
!   with respect to varying inputs: q
  SUBROUTINE SPARSE_UPSTREAM_DISCHARGE_D(dt, dx, nrow, ncol, nac, flow, &
&   drained_area, ind_sparse, row, col, q, q_d, qup, qup_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt, dx
    INTEGER, INTENT(IN) :: nrow, ncol, nac, row, col
    INTEGER, DIMENSION(nrow, ncol), INTENT(IN) :: flow, drained_area, &
&   ind_sparse
    REAL(sp), DIMENSION(nac), INTENT(IN) :: q
    REAL(sp), DIMENSION(nac), INTENT(IN) :: q_d
    REAL(sp), INTENT(OUT) :: qup
    REAL(sp), INTENT(OUT) :: qup_d
    INTEGER :: i, row_imd, col_imd, k
    INTEGER, DIMENSION(8), SAVE :: dcol=(/0, -1, -1, -1, 0, 1, 1, 1/)
    INTEGER, DIMENSION(8), SAVE :: drow=(/1, 1, 0, -1, -1, -1, 0, 1/)
    INTEGER, DIMENSION(8), SAVE :: dkind=(/1, 2, 3, 4, 5, 6, 7, 8/)
    INTRINSIC REAL
    REAL*4 :: temp
    qup = 0._sp
    IF (drained_area(row, col) .GT. 1) THEN
      qup_d = 0.0_4
      DO i=1,8
        col_imd = col + dcol(i)
        row_imd = row + drow(i)
        IF (col_imd .GT. 0 .AND. col_imd .LE. ncol .AND. row_imd .GT. 0 &
&           .AND. row_imd .LE. nrow) THEN
          IF (flow(row_imd, col_imd) .EQ. dkind(i)) THEN
            k = ind_sparse(row_imd, col_imd)
            qup_d = qup_d + q_d(k)
            qup = qup + q(k)
          END IF
        END IF
      END DO
      temp = 0.001_sp*(dx*dx)*REAL(drained_area(row, col)-1)
      qup_d = dt*qup_d/temp
      qup = dt*(qup/temp)
    ELSE
      qup_d = 0.0_4
    END IF
  END SUBROUTINE SPARSE_UPSTREAM_DISCHARGE_D

  SUBROUTINE SPARSE_UPSTREAM_DISCHARGE(dt, dx, nrow, ncol, nac, flow, &
&   drained_area, ind_sparse, row, col, q, qup)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt, dx
    INTEGER, INTENT(IN) :: nrow, ncol, nac, row, col
    INTEGER, DIMENSION(nrow, ncol), INTENT(IN) :: flow, drained_area, &
&   ind_sparse
    REAL(sp), DIMENSION(nac), INTENT(IN) :: q
    REAL(sp), INTENT(OUT) :: qup
    INTEGER :: i, row_imd, col_imd, k
    INTEGER, DIMENSION(8), SAVE :: dcol=(/0, -1, -1, -1, 0, 1, 1, 1/)
    INTEGER, DIMENSION(8), SAVE :: drow=(/1, 1, 0, -1, -1, -1, 0, 1/)
    INTEGER, DIMENSION(8), SAVE :: dkind=(/1, 2, 3, 4, 5, 6, 7, 8/)
    INTRINSIC REAL
    qup = 0._sp
    IF (drained_area(row, col) .GT. 1) THEN
      DO i=1,8
        col_imd = col + dcol(i)
        row_imd = row + drow(i)
        IF (col_imd .GT. 0 .AND. col_imd .LE. ncol .AND. row_imd .GT. 0 &
&           .AND. row_imd .LE. nrow) THEN
          IF (flow(row_imd, col_imd) .EQ. dkind(i)) THEN
            k = ind_sparse(row_imd, col_imd)
            qup = qup + q(k)
          END IF
        END IF
      END DO
      qup = qup*dt/(0.001_sp*dx*dx*REAL(drained_area(row, col)-1))
    END IF
  END SUBROUTINE SPARSE_UPSTREAM_DISCHARGE

!  Differentiation of gr_transfer1 in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: hr qrout
!   with respect to varying inputs: qup hr lr
  SUBROUTINE GR_TRANSFER1_D(dt, qup, qup_d, lr, lr_d, hr, hr_d, qrout, &
&   qrout_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt
    REAL(sp), INTENT(IN) :: qup, lr
    REAL(sp), INTENT(IN) :: qup_d, lr_d
    REAL(sp), INTENT(INOUT) :: hr
    REAL(sp), INTENT(INOUT) :: hr_d
    REAL(sp), INTENT(OUT) :: qrout
    REAL(sp), INTENT(OUT) :: qrout_d
    REAL(sp) :: hr_imd
    REAL(sp) :: hr_imd_d
    INTRINSIC EXP
    REAL(sp) :: arg1
    REAL(sp) :: arg1_d
    REAL(sp) :: temp
    hr_imd_d = hr_d + qup_d
    hr_imd = hr + qup
    temp = dt/(60._sp*lr)
    arg1_d = temp*lr_d/lr
    arg1 = -temp
    temp = EXP(arg1)
    hr_d = temp*hr_imd_d + hr_imd*EXP(arg1)*arg1_d
    hr = hr_imd*temp
    qrout_d = hr_imd_d - hr_d
    qrout = hr_imd - hr
  END SUBROUTINE GR_TRANSFER1_D

  SUBROUTINE GR_TRANSFER1(dt, qup, lr, hr, qrout)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt
    REAL(sp), INTENT(IN) :: qup, lr
    REAL(sp), INTENT(INOUT) :: hr
    REAL(sp), INTENT(OUT) :: qrout
    REAL(sp) :: hr_imd
    INTRINSIC EXP
    REAL(sp) :: arg1
    hr_imd = hr + qup
    arg1 = -(dt/(lr*60._sp))
    hr = hr_imd*EXP(arg1)
    qrout = hr_imd - hr
  END SUBROUTINE GR_TRANSFER1

END MODULE MD_OPERATOR_DIFF_D

!%      This module `mwd_states` encapsulates all SMASH states.
!%      This module is wrapped and differentiated.
!%
!%      StatesDT type:
!%      
!%      ======================== =======================================
!%      `Variables`              Description
!%      ======================== =======================================
!%      ``hi``                   Interception state    [-]   (default: 0.01)   ]0, 1[
!%      ``hp``                   Production state      [-]   (default: 0.01)   ]0, 1[
!%      ``hft``                  Fast transfer state   [-]   (default: 0.01)   ]0, 1[
!%      ``hst``                  Slow transfer state   [-]   (default: 0.01)   ]0, 1[
!%      ``hlr``                  Linear routing state  [mm]  (default: 0.01)   ]0, +Inf[
!%      ======================== =======================================
!%
!%      contains
!%
!%      [1] StatesDT_initialise
!%      [2] states_copy
!%      [3] states_to_matrix
!%      [4] matrix_to_states
!%      [5] vector_to_states
MODULE MWD_STATES_DIFF_D
!% only: sp, dp, lchar, np, ns
  USE MWD_COMMON
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
  IMPLICIT NONE
  TYPE STATESDT
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hi
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hp
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hft
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hst
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hlr
  END TYPE STATESDT

CONTAINS
  SUBROUTINE STATESDT_INITIALISE(states, setup, mesh)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(STATESDT), INTENT(INOUT) :: states
    INTEGER :: nrow, ncol
    nrow = mesh%nrow
    ncol = mesh%ncol
    ALLOCATE(states%hi(nrow, ncol))
    ALLOCATE(states%hp(nrow, ncol))
    ALLOCATE(states%hft(nrow, ncol))
    ALLOCATE(states%hst(nrow, ncol))
    ALLOCATE(states%hlr(nrow, ncol))
    CALL VECTOR_TO_STATES(setup%default_states, states)
  END SUBROUTINE STATESDT_INITIALISE

!%      TODO comment       
  SUBROUTINE STATES_COPY(states_in, states_out)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(IN) :: states_in
    TYPE(STATESDT), INTENT(OUT) :: states_out
    states_out = states_in
  END SUBROUTINE STATES_COPY

!%      TODO comment 
  SUBROUTINE STATES_TO_MATRIX(states, matrix)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(IN) :: states
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(states%hp, 1), SIZE(states%hp, 2), ns), &
&   INTENT(INOUT) :: matrix
    matrix(:, :, 1) = states%hi(:, :)
    matrix(:, :, 2) = states%hp(:, :)
    matrix(:, :, 3) = states%hft(:, :)
    matrix(:, :, 4) = states%hst(:, :)
    matrix(:, :, 5) = states%hlr(:, :)
  END SUBROUTINE STATES_TO_MATRIX

!%      TODO comment
  SUBROUTINE MATRIX_TO_STATES(matrix, states)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(INOUT) :: states
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(states%hp, 1), SIZE(states%hp, 2), ns), &
&   INTENT(IN) :: matrix
    states%hi(:, :) = matrix(:, :, 1)
    states%hp(:, :) = matrix(:, :, 2)
    states%hft(:, :) = matrix(:, :, 3)
    states%hst(:, :) = matrix(:, :, 4)
    states%hlr(:, :) = matrix(:, :, 5)
  END SUBROUTINE MATRIX_TO_STATES

!%      TODO comment
  SUBROUTINE VECTOR_TO_STATES(vector, states)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(INOUT) :: states
    REAL(sp), DIMENSION(ns), INTENT(IN) :: vector
    states%hi = vector(1)
    states%hp = vector(2)
    states%hft = vector(3)
    states%hst = vector(4)
    states%hlr = vector(5)
  END SUBROUTINE VECTOR_TO_STATES

END MODULE MWD_STATES_DIFF_D

!%      This module `mwd_parameters` encapsulates all SMASH parameters.
!%      This module is wrapped and differentiated.
!%
!%      ParametersDT type:
!%      
!%      ======================== =======================================
!%      `Variables`              Description
!%      ======================== =======================================
!%      ``ci``                   Interception parameter          [mm]    (default: 1)     ]0, +Inf[
!%      ``cp``                   Production parameter            [mm]    (default: 200)   ]0, +Inf[
!%      ``beta``                 Percolation parameter           [-]     (default: 1000)  ]0, +Inf[
!%      ``cft``                  Fast transfer parameter         [mm]    (default: 500)   ]0, +Inf[
!%      ``cst``                  Slow transfer parameter         [mm]    (default: 500)   ]0, +Inf[
!%      ``alpha``                Transfer partitioning parameter [-]     (default: 0.9)   ]0, 1[
!%      ``exc``                  Exchange parameter              [mm/dt] (default: 0)     ]-Inf, +Inf[
!%      ``lr``                   Linear routing parameter        [min]   (default: 5)     ]0, +Inf[
!%      ======================== =======================================
!%
!%      contains
!%
!%      [1] ParametersDT_initialise
!%      [2] parameters_copy
!%      [3] parameters_to_matrix
!%      [4] matrix_to_parameters
!%      [5] vector_to_parameters
MODULE MWD_PARAMETERS_DIFF_D
!% only: sp, dp, lchar, np, ns
  USE MWD_COMMON
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
  IMPLICIT NONE
  TYPE PARAMETERSDT
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: ci
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cp
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: beta
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cft
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cst
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: alpha
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: exc
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: lr
  END TYPE PARAMETERSDT

CONTAINS
  SUBROUTINE PARAMETERSDT_INITIALISE(parameters, setup, mesh)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    INTEGER :: nrow, ncol
    nrow = mesh%nrow
    ncol = mesh%ncol
    ALLOCATE(parameters%ci(nrow, ncol))
    ALLOCATE(parameters%cp(nrow, ncol))
    ALLOCATE(parameters%beta(nrow, ncol))
    ALLOCATE(parameters%cft(nrow, ncol))
    ALLOCATE(parameters%cst(nrow, ncol))
    ALLOCATE(parameters%alpha(nrow, ncol))
    ALLOCATE(parameters%exc(nrow, ncol))
    ALLOCATE(parameters%lr(nrow, ncol))
    CALL VECTOR_TO_PARAMETERS(setup%default_parameters, parameters)
  END SUBROUTINE PARAMETERSDT_INITIALISE

!%      TODO comment  
  SUBROUTINE PARAMETERS_COPY(parameters_in, parameters_out)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters_in
    TYPE(PARAMETERSDT), INTENT(OUT) :: parameters_out
    parameters_out = parameters_in
  END SUBROUTINE PARAMETERS_COPY

!%      TODO comment  
  SUBROUTINE PARAMETERS_TO_MATRIX(parameters, matrix)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(parameters%cp, 1), SIZE(parameters%cp, 2), &
&   np), INTENT(INOUT) :: matrix
    matrix(:, :, 1) = parameters%ci(:, :)
    matrix(:, :, 2) = parameters%cp(:, :)
    matrix(:, :, 3) = parameters%beta(:, :)
    matrix(:, :, 4) = parameters%cft(:, :)
    matrix(:, :, 5) = parameters%cst(:, :)
    matrix(:, :, 6) = parameters%alpha(:, :)
    matrix(:, :, 7) = parameters%exc(:, :)
    matrix(:, :, 8) = parameters%lr(:, :)
  END SUBROUTINE PARAMETERS_TO_MATRIX

!%      TODO comment  
  SUBROUTINE MATRIX_TO_PARAMETERS(matrix, parameters)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(parameters%cp, 1), SIZE(parameters%cp, 2), &
&   np), INTENT(IN) :: matrix
    parameters%ci(:, :) = matrix(:, :, 1)
    parameters%cp(:, :) = matrix(:, :, 2)
    parameters%beta(:, :) = matrix(:, :, 3)
    parameters%cft(:, :) = matrix(:, :, 4)
    parameters%cst(:, :) = matrix(:, :, 5)
    parameters%alpha(:, :) = matrix(:, :, 6)
    parameters%exc(:, :) = matrix(:, :, 7)
    parameters%lr(:, :) = matrix(:, :, 8)
  END SUBROUTINE MATRIX_TO_PARAMETERS

!%      TODO comment  
  SUBROUTINE VECTOR_TO_PARAMETERS(vector, parameters)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    REAL(sp), DIMENSION(np), INTENT(IN) :: vector
    parameters%ci = vector(1)
    parameters%cp = vector(2)
    parameters%beta = vector(3)
    parameters%cft = vector(4)
    parameters%cst = vector(5)
    parameters%alpha = vector(6)
    parameters%exc = vector(7)
    parameters%lr = vector(8)
  END SUBROUTINE VECTOR_TO_PARAMETERS

END MODULE MWD_PARAMETERS_DIFF_D

!  Differentiation of forward in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: cost
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.alpha)
!                *(parameters.exc) *(parameters.lr) *(states.hi)
!                *(states.hp) *(states.hft) *(states.hlr)
!   RW status of diff variables: parameters.ci:(loc) *(parameters.ci):in
!                parameters.cp:(loc) *(parameters.cp):in parameters.beta:(loc)
!                *(parameters.beta):in parameters.cft:(loc) *(parameters.cft):in
!                parameters.cst:(loc) *(parameters.cst):(loc) parameters.alpha:(loc)
!                *(parameters.alpha):in parameters.exc:(loc) *(parameters.exc):in
!                parameters.lr:(loc) *(parameters.lr):in *(output.qsim):(loc)
!                states.hi:(loc) *(states.hi):in-killed states.hp:(loc)
!                *(states.hp):in-killed states.hft:(loc) *(states.hft):in-killed
!                states.hst:(loc) *(states.hst):(loc) states.hlr:(loc)
!                *(states.hlr):in-killed cost:out
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.alpha:in
!                parameters.exc:in parameters.lr:in output.qsim:in
!                states.hi:in states.hp:in states.hft:in states.hlr:in
SUBROUTINE FORWARD_D(setup, mesh, input_data, parameters, parameters_d, &
& states, states_d, output, output_d, cost, cost_d)
!% =================================================================================================================== %!
!%   Module import ('only' commented because of issues in adjoint model)
!% =================================================================================================================== %!
!% only: sp
  USE MWD_COMMON
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: ParametersDT
  USE MWD_PARAMETERS_DIFF_D
!% only: StatesDT
  USE MWD_STATES_DIFF_D
!% only: OutputDT
  USE MWD_OUTPUT_DIFF_D
!% only: GR_interception, GR_production, GR_exchange, &
  USE MD_OPERATOR_DIFF_D
!% & GR_transferN, upstream_discharge, sparse_upstream_discharge, GR_transfer1
!% only: compute_jobs
  USE MWD_COST_DIFF_D
  IMPLICIT NONE
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
  TYPE(SETUPDT), INTENT(IN) :: setup
  TYPE(MESHDT), INTENT(IN) :: mesh
  TYPE(INPUT_DATADT), INTENT(IN) :: input_data
  TYPE(PARAMETERSDT), INTENT(IN) :: parameters
  TYPE(PARAMETERSDT), INTENT(IN) :: parameters_d
  TYPE(STATESDT), INTENT(INOUT) :: states
  TYPE(STATESDT), INTENT(INOUT) :: states_d
  TYPE(OUTPUTDT), INTENT(INOUT) :: output
  TYPE(OUTPUTDT_DIFF_D), INTENT(INOUT) :: output_d
  REAL(sp), INTENT(INOUT) :: cost
  REAL(sp), INTENT(INOUT) :: cost_d
!% =================================================================================================================== %!
!%   Local Variables (private)
!===================================================================================================================== %!
  REAL(sp), DIMENSION(:, :), ALLOCATABLE :: q
  REAL(sp), DIMENSION(:, :), ALLOCATABLE :: q_d
  REAL(sp), DIMENSION(:), ALLOCATABLE :: sparse_q
  REAL(sp), DIMENSION(:), ALLOCATABLE :: sparse_q_d
  REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prd, qd, qr, ql, &
& qt, qup, qrout
  REAL(sp) :: ei_d, pn_d, en_d, pr_d, perc_d, l_d, prr_d, prd_d, qd_d, &
& qr_d, qt_d, qup_d, qrout_d
  INTEGER :: t, i, row, col, k, g
  INTRINSIC MIN
  INTRINSIC MAX
  INTRINSIC REAL
  REAL(sp) :: temp
  REAL :: temp0
  cost = 0._sp
  IF (setup%sparse_storage) THEN
    ALLOCATE(sparse_q_d(mesh%nac))
    ALLOCATE(sparse_q(mesh%nac))
    output_d%qsim = 0.0_4
  ELSE
    ALLOCATE(q_d(mesh%nrow, mesh%ncol))
    ALLOCATE(q(mesh%nrow, mesh%ncol))
    output_d%qsim = 0.0_4
  END IF
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
  DO t=1,setup%ntime_step
!% [ DO SPACE ]
    DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialisation for time step (t) and cell (i)
!% =============================================================================================================== %!
      ei = 0._sp
      pn = 0._sp
      en = 0._sp
      pr = 0._sp
      perc = 0._sp
      l = 0._sp
      prr = 0._sp
      prd = 0._sp
      qd = 0._sp
      qr = 0._sp
      ql = 0._sp
      qup = 0._sp
      qrout = 0._sp
!% [ END IF PATH ]
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of drained area 
!% =========================================================================================================== %!
      IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
!% [ IF PATH ]
        row = mesh%path(1, i)
        col = mesh%path(2, i)
        IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, col&
&           )
!% [ END IF ACTIVE CELL ]
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
        IF (mesh%global_active_cell(row, col) .EQ. 1 .AND. mesh%&
&           local_active_cell(row, col) .EQ. 1) THEN
!% [ IF ACTIVE CELL ]
          IF (setup%sparse_storage) THEN
            prcp = input_data%sparse_prcp(k, t)
            pet = input_data%sparse_pet(k, t)
          ELSE
            prcp = input_data%prcp(row, col, t)
            pet = input_data%pet(row, col, t)
          END IF
!% [ END IF PRCP GAP ]
          IF (prcp .GE. 0) THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module case [ 0 - 1 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%interception_module) 
            CASE (0) 
              IF (pet .GT. prcp) THEN
                ei = prcp
              ELSE
                ei = pet
              END IF
              IF (0._sp .LT. prcp - ei) THEN
                pn = prcp - ei
                ei_d = 0.0_4
                pn_d = 0.0_4
              ELSE
                pn = 0._sp
                ei_d = 0.0_4
                pn_d = 0.0_4
              END IF
            CASE (1) 
              CALL GR_INTERCEPTION_D(prcp, pet, parameters%ci(row, col)&
&                              , parameters_d%ci(row, col), states%hi(&
&                              row, col), states_d%hi(row, col), pn, &
&                              pn_d, ei, ei_d)
            CASE DEFAULT
              ei_d = 0.0_4
              pn_d = 0.0_4
            END SELECT
            en_d = -ei_d
            en = pet - ei
!% =============================================================================================== %!
!%   Production module case [ 0 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%production_module) 
            CASE (0) 
              CALL GR_PRODUCTION_D(pn, pn_d, en, en_d, parameters%cp(row&
&                            , col), parameters_d%cp(row, col), &
&                            parameters%beta(row, col), parameters_d%&
&                            beta(row, col), states%hp(row, col), &
&                            states_d%hp(row, col), pr, pr_d, perc, &
&                            perc_d)
            CASE DEFAULT
              perc_d = 0.0_4
              pr_d = 0.0_4
            END SELECT
!% =============================================================================================== %!
!%   Exchange module case [ 0 - 1 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%exchange_module) 
            CASE (0) 
              l = 0._sp
              l_d = 0.0_4
            CASE (1) 
              CALL GR_EXCHANGE_D(parameters%exc(row, col), parameters_d%&
&                          exc(row, col), states%hft(row, col), states_d&
&                          %hft(row, col), l, l_d)
            CASE DEFAULT
              l_d = 0.0_4
            END SELECT
          ELSE
            l_d = 0.0_4
            perc_d = 0.0_4
            pr_d = 0.0_4
          END IF
!% =================================================================================================== %!
!%   Transfer module case [ 0 ]
!% =================================================================================================== %!
          SELECT CASE  (setup%transfer_module) 
          CASE (0) 
            prr_d = (pr+perc)*parameters_d%alpha(row, col) + parameters%&
&             alpha(row, col)*(pr_d+perc_d) + l_d
            prr = parameters%alpha(row, col)*(pr+perc) + l
            prd_d = pr_d + perc_d - prr_d
            prd = pr + perc - prr
            CALL GR_TRANSFERN_D(5._sp, prcp, prr, prr_d, parameters%cft(&
&                         row, col), parameters_d%cft(row, col), states%&
&                         hft(row, col), states_d%hft(row, col), qr, &
&                         qr_d)
            IF (0._sp .LT. prd + l) THEN
              qd_d = prd_d + l_d
              qd = prd + l
            ELSE
              qd = 0._sp
              qd_d = 0.0_4
            END IF
          CASE DEFAULT
            qd_d = 0.0_4
            qr_d = 0.0_4
          END SELECT
          qt_d = qd_d + qr_d
          qt = qd + qr + ql
!% =================================================================================================== %!
!%   Routing module case [ 0 - 1 ]
!% =================================================================================================== %!
          SELECT CASE  (setup%routing_module) 
          CASE (0) 
            IF (setup%sparse_storage) THEN
              CALL SPARSE_UPSTREAM_DISCHARGE_D(setup%dt, mesh%dx, mesh%&
&                                        nrow, mesh%ncol, mesh%nac, mesh&
&                                        %flow, mesh%drained_area, mesh%&
&                                        rowcol_to_ind_sparse, row, col&
&                                        , sparse_q, sparse_q_d, qup, &
&                                        qup_d)
              temp = 0.001_sp*(mesh%dx*mesh%dx)
              temp0 = REAL(mesh%drained_area(row, col) - 1)
              sparse_q_d(k) = temp*(qt_d+temp0*qup_d)/setup%dt
              sparse_q(k) = temp*((qt+temp0*qup)/setup%dt)
            ELSE
              CALL UPSTREAM_DISCHARGE_D(setup%dt, mesh%dx, mesh%nrow, &
&                                 mesh%ncol, mesh%flow, mesh%&
&                                 drained_area, row, col, q, q_d, qup, &
&                                 qup_d)
              temp = 0.001_sp*(mesh%dx*mesh%dx)
              temp0 = REAL(mesh%drained_area(row, col) - 1)
              q_d(row, col) = temp*(qt_d+temp0*qup_d)/setup%dt
              q(row, col) = temp*((qt+temp0*qup)/setup%dt)
            END IF
          CASE (1) 
            IF (setup%sparse_storage) THEN
              CALL SPARSE_UPSTREAM_DISCHARGE_D(setup%dt, mesh%dx, mesh%&
&                                        nrow, mesh%ncol, mesh%nac, mesh&
&                                        %flow, mesh%drained_area, mesh%&
&                                        rowcol_to_ind_sparse, row, col&
&                                        , sparse_q, sparse_q_d, qup, &
&                                        qup_d)
              CALL GR_TRANSFER1_D(setup%dt, qup, qup_d, parameters%lr(&
&                           row, col), parameters_d%lr(row, col), states&
&                           %hlr(row, col), states_d%hlr(row, col), &
&                           qrout, qrout_d)
              temp = 0.001_sp*(mesh%dx*mesh%dx)
              temp0 = REAL(mesh%drained_area(row, col) - 1)
              sparse_q_d(k) = temp*(qt_d+temp0*qrout_d)/setup%dt
              sparse_q(k) = temp*((qt+temp0*qrout)/setup%dt)
            ELSE
              CALL UPSTREAM_DISCHARGE_D(setup%dt, mesh%dx, mesh%nrow, &
&                                 mesh%ncol, mesh%flow, mesh%&
&                                 drained_area, row, col, q, q_d, qup, &
&                                 qup_d)
              CALL GR_TRANSFER1_D(setup%dt, qup, qup_d, parameters%lr(&
&                           row, col), parameters_d%lr(row, col), states&
&                           %hlr(row, col), states_d%hlr(row, col), &
&                           qrout, qrout_d)
              temp = 0.001_sp*(mesh%dx*mesh%dx)
              temp0 = REAL(mesh%drained_area(row, col) - 1)
              q_d(row, col) = temp*(qt_d+temp0*qrout_d)/setup%dt
              q(row, col) = temp*((qt+temp0*qrout)/setup%dt)
            END IF
          END SELECT
        END IF
      END IF
    END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
    DO g=1,mesh%ng
      row = mesh%gauge_pos(1, g)
      col = mesh%gauge_pos(2, g)
      IF (setup%sparse_storage) THEN
        k = mesh%rowcol_to_ind_sparse(row, col)
        output_d%qsim(g, t) = sparse_q_d(k)
        output%qsim(g, t) = sparse_q(k)
      ELSE
        output_d%qsim(g, t) = q_d(row, col)
        output%qsim(g, t) = q(row, col)
      END IF
    END DO
!% =============================================================================================================== %!
!%   Store simulated discharge at domain (optional)
!% =============================================================================================================== %!
    IF (setup%save_qsim_domain) THEN
      IF (setup%sparse_storage) THEN
        output%sparse_qsim_domain(:, t) = sparse_q
      ELSE
        output%qsim_domain(:, :, t) = q
      END IF
    END IF
  END DO
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Compute J
!% =================================================================================================================== %!
  CALL COMPUTE_JOBS_D(setup, mesh, input_data, output, output_d, cost, &
&               cost_d)
END SUBROUTINE FORWARD_D

SUBROUTINE FORWARD_NODIFF_D(setup, mesh, input_data, parameters, states, &
& output, cost)
!% =================================================================================================================== %!
!%   Module import ('only' commented because of issues in adjoint model)
!% =================================================================================================================== %!
!% only: sp
  USE MWD_COMMON
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: ParametersDT
  USE MWD_PARAMETERS_DIFF_D
!% only: StatesDT
  USE MWD_STATES_DIFF_D
!% only: OutputDT
  USE MWD_OUTPUT_DIFF_D
!% only: GR_interception, GR_production, GR_exchange, &
  USE MD_OPERATOR_DIFF_D
!% & GR_transferN, upstream_discharge, sparse_upstream_discharge, GR_transfer1
!% only: compute_jobs
  USE MWD_COST_DIFF_D
  IMPLICIT NONE
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
  TYPE(SETUPDT), INTENT(IN) :: setup
  TYPE(MESHDT), INTENT(IN) :: mesh
  TYPE(INPUT_DATADT), INTENT(IN) :: input_data
  TYPE(PARAMETERSDT), INTENT(IN) :: parameters
  TYPE(STATESDT), INTENT(INOUT) :: states
  TYPE(OUTPUTDT), INTENT(INOUT) :: output
  REAL(sp), INTENT(INOUT) :: cost
!% =================================================================================================================== %!
!%   Local Variables (private)
!===================================================================================================================== %!
  REAL(sp), DIMENSION(:, :), ALLOCATABLE :: q
  REAL(sp), DIMENSION(:), ALLOCATABLE :: sparse_q
  REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prd, qd, qr, ql, &
& qt, qup, qrout
  INTEGER :: t, i, row, col, k, g
  INTRINSIC MIN
  INTRINSIC MAX
  INTRINSIC REAL
  cost = 0._sp
  IF (setup%sparse_storage) THEN
    ALLOCATE(sparse_q(mesh%nac))
  ELSE
    ALLOCATE(q(mesh%nrow, mesh%ncol))
  END IF
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
  DO t=1,setup%ntime_step
!% [ DO SPACE ]
    DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialisation for time step (t) and cell (i)
!% =============================================================================================================== %!
      ei = 0._sp
      pn = 0._sp
      en = 0._sp
      pr = 0._sp
      perc = 0._sp
      l = 0._sp
      prr = 0._sp
      prd = 0._sp
      qd = 0._sp
      qr = 0._sp
      ql = 0._sp
      qup = 0._sp
      qrout = 0._sp
!% [ END IF PATH ]
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of drained area 
!% =========================================================================================================== %!
      IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
!% [ IF PATH ]
        row = mesh%path(1, i)
        col = mesh%path(2, i)
        IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, col&
&           )
!% [ END IF ACTIVE CELL ]
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
        IF (mesh%global_active_cell(row, col) .EQ. 1 .AND. mesh%&
&           local_active_cell(row, col) .EQ. 1) THEN
!% [ IF ACTIVE CELL ]
          IF (setup%sparse_storage) THEN
            prcp = input_data%sparse_prcp(k, t)
            pet = input_data%sparse_pet(k, t)
          ELSE
            prcp = input_data%prcp(row, col, t)
            pet = input_data%pet(row, col, t)
          END IF
!% [ END IF PRCP GAP ]
          IF (prcp .GE. 0) THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module case [ 0 - 1 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%interception_module) 
            CASE (0) 
              IF (pet .GT. prcp) THEN
                ei = prcp
              ELSE
                ei = pet
              END IF
              IF (0._sp .LT. prcp - ei) THEN
                pn = prcp - ei
              ELSE
                pn = 0._sp
              END IF
            CASE (1) 
              CALL GR_INTERCEPTION(prcp, pet, parameters%ci(row, col), &
&                            states%hi(row, col), pn, ei)
            END SELECT
            en = pet - ei
!% =============================================================================================== %!
!%   Production module case [ 0 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%production_module) 
            CASE (0) 
              CALL GR_PRODUCTION(pn, en, parameters%cp(row, col), &
&                          parameters%beta(row, col), states%hp(row, col&
&                          ), pr, perc)
            END SELECT
!% =============================================================================================== %!
!%   Exchange module case [ 0 - 1 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%exchange_module) 
            CASE (0) 
              l = 0._sp
            CASE (1) 
              CALL GR_EXCHANGE(parameters%exc(row, col), states%hft(row&
&                        , col), l)
            END SELECT
          END IF
!% =================================================================================================== %!
!%   Transfer module case [ 0 ]
!% =================================================================================================== %!
          SELECT CASE  (setup%transfer_module) 
          CASE (0) 
            prr = parameters%alpha(row, col)*(pr+perc) + l
            prd = pr + perc - prr
            CALL GR_TRANSFERN(5._sp, prcp, prr, parameters%cft(row, col)&
&                       , states%hft(row, col), qr)
            IF (0._sp .LT. prd + l) THEN
              qd = prd + l
            ELSE
              qd = 0._sp
            END IF
          END SELECT
          qt = qd + qr + ql
!% =================================================================================================== %!
!%   Routing module case [ 0 - 1 ]
!% =================================================================================================== %!
          SELECT CASE  (setup%routing_module) 
          CASE (0) 
            IF (setup%sparse_storage) THEN
              CALL SPARSE_UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%&
&                                      nrow, mesh%ncol, mesh%nac, mesh%&
&                                      flow, mesh%drained_area, mesh%&
&                                      rowcol_to_ind_sparse, row, col, &
&                                      sparse_q, qup)
              sparse_q(k) = (qt+qup*REAL(mesh%drained_area(row, col)-1))&
&               *mesh%dx*mesh%dx*0.001_sp/setup%dt
            ELSE
              CALL UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%nrow, mesh&
&                               %ncol, mesh%flow, mesh%drained_area, row&
&                               , col, q, qup)
              q(row, col) = (qt+qup*REAL(mesh%drained_area(row, col)-1))&
&               *mesh%dx*mesh%dx*0.001_sp/setup%dt
            END IF
          CASE (1) 
            IF (setup%sparse_storage) THEN
              CALL SPARSE_UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%&
&                                      nrow, mesh%ncol, mesh%nac, mesh%&
&                                      flow, mesh%drained_area, mesh%&
&                                      rowcol_to_ind_sparse, row, col, &
&                                      sparse_q, qup)
              CALL GR_TRANSFER1(setup%dt, qup, parameters%lr(row, col), &
&                         states%hlr(row, col), qrout)
              sparse_q(k) = (qt+qrout*REAL(mesh%drained_area(row, col)-1&
&               ))*mesh%dx*mesh%dx*0.001_sp/setup%dt
            ELSE
              CALL UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%nrow, mesh&
&                               %ncol, mesh%flow, mesh%drained_area, row&
&                               , col, q, qup)
              CALL GR_TRANSFER1(setup%dt, qup, parameters%lr(row, col), &
&                         states%hlr(row, col), qrout)
              q(row, col) = (qt+qrout*REAL(mesh%drained_area(row, col)-1&
&               ))*mesh%dx*mesh%dx*0.001_sp/setup%dt
            END IF
          END SELECT
        END IF
      END IF
    END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
    DO g=1,mesh%ng
      row = mesh%gauge_pos(1, g)
      col = mesh%gauge_pos(2, g)
      IF (setup%sparse_storage) THEN
        k = mesh%rowcol_to_ind_sparse(row, col)
        output%qsim(g, t) = sparse_q(k)
      ELSE
        output%qsim(g, t) = q(row, col)
      END IF
    END DO
!% =============================================================================================================== %!
!%   Store simulated discharge at domain (optional)
!% =============================================================================================================== %!
    IF (setup%save_qsim_domain) THEN
      IF (setup%sparse_storage) THEN
        output%sparse_qsim_domain(:, t) = sparse_q
      ELSE
        output%qsim_domain(:, :, t) = q
      END IF
    END IF
  END DO
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Compute J
!% =================================================================================================================== %!
  CALL COMPUTE_JOBS(setup, mesh, input_data, output, cost)
END SUBROUTINE FORWARD_NODIFF_D

