!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!%      This module `mwd_parameters` encapsulates all SMASH parameters.
!%      This module is wrapped and differentiated.
!%
!%      ParametersDT type:
!%      
!%      </> Public
!%      ======================== =======================================
!%      `Variables`              Description
!%      ======================== =======================================
!%      ``ci``                   Interception parameter          [mm]    (default: 1)     ]0, +Inf[
!%      ``cp``                   Production parameter            [mm]    (default: 200)   ]0, +Inf[
!%      ``beta``                 Percolation parameter           [-]     (default: 1000)  ]0, +Inf[
!%      ``cft``                  Fast transfer parameter         [mm]    (default: 500)   ]0, +Inf[
!%      ``cst``                  Slow transfer parameter         [mm]    (default: 500)   ]0, +Inf[
!%      ``alpha``                Transfer partitioning parameter [-]     (default: 0.9)   ]0, 1[
!%      ``exc``                  Exchange parameter              [mm/dt] (default: 0)     ]-Inf, +Inf[
!%      ``lr``                   Linear routing parameter        [min]   (default: 5)     ]0, +Inf[
!%      ======================== =======================================
!%
!%      contains
!%
!%      [1] ParametersDT_initialise
!%      [2] parameters_to_matrix
!%      [3] matrix_to_parameters
!%      [4] vector_to_parameters
!%      [5] set0_parameters
!%      [6] set1_parameters
MODULE MWD_PARAMETERS_DIFF_D
!% only: sp, np
  USE MWD_COMMON
!% only: MeshDT
  USE MWD_MESH
  IMPLICIT NONE
  TYPE PARAMETERSDT
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: ci
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cp
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: beta
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cft
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cst
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: alpha
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: exc
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: lr
  END TYPE PARAMETERSDT

CONTAINS
  SUBROUTINE PARAMETERSDT_INITIALISE(parameters, mesh)
    IMPLICIT NONE
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    INTEGER :: nrow, ncol
    nrow = mesh%nrow
    ncol = mesh%ncol
    ALLOCATE(parameters%ci(nrow, ncol))
    ALLOCATE(parameters%cp(nrow, ncol))
    ALLOCATE(parameters%beta(nrow, ncol))
    ALLOCATE(parameters%cft(nrow, ncol))
    ALLOCATE(parameters%cst(nrow, ncol))
    ALLOCATE(parameters%alpha(nrow, ncol))
    ALLOCATE(parameters%exc(nrow, ncol))
    ALLOCATE(parameters%lr(nrow, ncol))
    parameters%ci = 1._sp
    parameters%cp = 200._sp
    parameters%beta = 1000._sp
    parameters%cft = 500._sp
    parameters%cst = 500._sp
    parameters%alpha = 0.9_sp
    parameters%exc = 0._sp
    parameters%lr = 5._sp
  END SUBROUTINE PARAMETERSDT_INITIALISE

!  Differentiation of parameters_to_matrix in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: matrix
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.lr)
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.lr:in
!%      TODO comment  
  SUBROUTINE PARAMETERS_TO_MATRIX_D(parameters, parameters_d, matrix, &
&   matrix_d)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters_d
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(parameters%cp, 1), SIZE(parameters%cp, 2), &
&   np), INTENT(INOUT) :: matrix
    REAL(sp), DIMENSION(SIZE(parameters%cp, 1), SIZE(parameters%cp, 2), &
&   np), INTENT(INOUT) :: matrix_d
    matrix_d = 0.0_4
    matrix_d(:, :, 1) = parameters_d%ci(:, :)
    matrix(:, :, 1) = parameters%ci(:, :)
    matrix_d(:, :, 2) = parameters_d%cp(:, :)
    matrix(:, :, 2) = parameters%cp(:, :)
    matrix_d(:, :, 3) = parameters_d%beta(:, :)
    matrix(:, :, 3) = parameters%beta(:, :)
    matrix_d(:, :, 4) = parameters_d%cft(:, :)
    matrix(:, :, 4) = parameters%cft(:, :)
    matrix_d(:, :, 5) = parameters_d%cst(:, :)
    matrix(:, :, 5) = parameters%cst(:, :)
    matrix_d(:, :, 6) = parameters_d%alpha(:, :)
    matrix(:, :, 6) = parameters%alpha(:, :)
    matrix_d(:, :, 7) = parameters_d%exc(:, :)
    matrix(:, :, 7) = parameters%exc(:, :)
    matrix_d(:, :, 8) = parameters_d%lr(:, :)
    matrix(:, :, 8) = parameters%lr(:, :)
  END SUBROUTINE PARAMETERS_TO_MATRIX_D

!%      TODO comment  
  SUBROUTINE PARAMETERS_TO_MATRIX(parameters, matrix)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(parameters%cp, 1), SIZE(parameters%cp, 2), &
&   np), INTENT(INOUT) :: matrix
    matrix(:, :, 1) = parameters%ci(:, :)
    matrix(:, :, 2) = parameters%cp(:, :)
    matrix(:, :, 3) = parameters%beta(:, :)
    matrix(:, :, 4) = parameters%cft(:, :)
    matrix(:, :, 5) = parameters%cst(:, :)
    matrix(:, :, 6) = parameters%alpha(:, :)
    matrix(:, :, 7) = parameters%exc(:, :)
    matrix(:, :, 8) = parameters%lr(:, :)
  END SUBROUTINE PARAMETERS_TO_MATRIX

!%      TODO comment  
  SUBROUTINE MATRIX_TO_PARAMETERS(matrix, parameters)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(parameters%cp, 1), SIZE(parameters%cp, 2), &
&   np), INTENT(IN) :: matrix
    parameters%ci(:, :) = matrix(:, :, 1)
    parameters%cp(:, :) = matrix(:, :, 2)
    parameters%beta(:, :) = matrix(:, :, 3)
    parameters%cft(:, :) = matrix(:, :, 4)
    parameters%cst(:, :) = matrix(:, :, 5)
    parameters%alpha(:, :) = matrix(:, :, 6)
    parameters%exc(:, :) = matrix(:, :, 7)
    parameters%lr(:, :) = matrix(:, :, 8)
  END SUBROUTINE MATRIX_TO_PARAMETERS

!%      TODO comment  
  SUBROUTINE VECTOR_TO_PARAMETERS(vector, parameters)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    REAL(sp), DIMENSION(np), INTENT(IN) :: vector
    parameters%ci = vector(1)
    parameters%cp = vector(2)
    parameters%beta = vector(3)
    parameters%cft = vector(4)
    parameters%cst = vector(5)
    parameters%alpha = vector(6)
    parameters%exc = vector(7)
    parameters%lr = vector(8)
  END SUBROUTINE VECTOR_TO_PARAMETERS

!%      TODO comment  
  SUBROUTINE SET0_PARAMETERS(parameters)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    REAL(sp), DIMENSION(np) :: vector0
    vector0 = 0._sp
    CALL VECTOR_TO_PARAMETERS(vector0, parameters)
  END SUBROUTINE SET0_PARAMETERS

!%      TODO comment  
  SUBROUTINE SET1_PARAMETERS(parameters)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    REAL(sp), DIMENSION(np) :: vector1
    vector1 = 1._sp
    CALL VECTOR_TO_PARAMETERS(vector1, parameters)
  END SUBROUTINE SET1_PARAMETERS

END MODULE MWD_PARAMETERS_DIFF_D

!%      This module `mwd_states` encapsulates all SMASH states.
!%      This module is wrapped and differentiated.
!%
!%      StatesDT type:
!%      
!%      </> Public
!%      ======================== =======================================
!%      `Variables`              Description
!%      ======================== =======================================
!%      ``hi``                   Interception state    [-]   (default: 0.01)   ]0, 1[
!%      ``hp``                   Production state      [-]   (default: 0.01)   ]0, 1[
!%      ``hft``                  Fast transfer state   [-]   (default: 0.01)   ]0, 1[
!%      ``hst``                  Slow transfer state   [-]   (default: 0.01)   ]0, 1[
!%      ``hlr``                  Linear routing state  [mm]  (default: 0.01)   ]0, +Inf[
!%      ======================== =======================================
!%
!%      contains
!%
!%      [1] StatesDT_initialise
!%      [2] states_to_matrix
!%      [3] matrix_to_states
!%      [4] vector_to_states
!%      [5] set0_states
!%      [6] set1_states
MODULE MWD_STATES_DIFF_D
!% only: sp, ns
  USE MWD_COMMON
!% only: MeshDT
  USE MWD_MESH
  IMPLICIT NONE
  TYPE STATESDT
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hi
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hp
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hft
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hst
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hlr
  END TYPE STATESDT

CONTAINS
  SUBROUTINE STATESDT_INITIALISE(states, mesh)
    IMPLICIT NONE
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(STATESDT), INTENT(INOUT) :: states
    INTEGER :: nrow, ncol
    nrow = mesh%nrow
    ncol = mesh%ncol
    ALLOCATE(states%hi(nrow, ncol))
    ALLOCATE(states%hp(nrow, ncol))
    ALLOCATE(states%hft(nrow, ncol))
    ALLOCATE(states%hst(nrow, ncol))
    ALLOCATE(states%hlr(nrow, ncol))
    states%hi = 0.01_sp
    states%hp = 0.01_sp
    states%hft = 0.01_sp
    states%hst = 0.01_sp
    states%hlr = 0.000001_sp
  END SUBROUTINE STATESDT_INITIALISE

!  Differentiation of states_to_matrix in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: matrix
!   with respect to varying inputs: *(states.hi) *(states.hp) *(states.hft)
!                *(states.hst) *(states.hlr)
!   Plus diff mem management of: states.hi:in states.hp:in states.hft:in
!                states.hst:in states.hlr:in
!%      TODO comment 
  SUBROUTINE STATES_TO_MATRIX_D(states, states_d, matrix, matrix_d)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(IN) :: states
    TYPE(STATESDT), INTENT(IN) :: states_d
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(states%hp, 1), SIZE(states%hp, 2), ns), &
&   INTENT(INOUT) :: matrix
    REAL(sp), DIMENSION(SIZE(states%hp, 1), SIZE(states%hp, 2), ns), &
&   INTENT(INOUT) :: matrix_d
    matrix_d = 0.0_4
    matrix_d(:, :, 1) = states_d%hi(:, :)
    matrix(:, :, 1) = states%hi(:, :)
    matrix_d(:, :, 2) = states_d%hp(:, :)
    matrix(:, :, 2) = states%hp(:, :)
    matrix_d(:, :, 3) = states_d%hft(:, :)
    matrix(:, :, 3) = states%hft(:, :)
    matrix_d(:, :, 4) = states_d%hst(:, :)
    matrix(:, :, 4) = states%hst(:, :)
    matrix_d(:, :, 5) = states_d%hlr(:, :)
    matrix(:, :, 5) = states%hlr(:, :)
  END SUBROUTINE STATES_TO_MATRIX_D

!%      TODO comment 
  SUBROUTINE STATES_TO_MATRIX(states, matrix)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(IN) :: states
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(states%hp, 1), SIZE(states%hp, 2), ns), &
&   INTENT(INOUT) :: matrix
    matrix(:, :, 1) = states%hi(:, :)
    matrix(:, :, 2) = states%hp(:, :)
    matrix(:, :, 3) = states%hft(:, :)
    matrix(:, :, 4) = states%hst(:, :)
    matrix(:, :, 5) = states%hlr(:, :)
  END SUBROUTINE STATES_TO_MATRIX

!%      TODO comment
  SUBROUTINE MATRIX_TO_STATES(matrix, states)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(INOUT) :: states
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(states%hp, 1), SIZE(states%hp, 2), ns), &
&   INTENT(IN) :: matrix
    states%hi(:, :) = matrix(:, :, 1)
    states%hp(:, :) = matrix(:, :, 2)
    states%hft(:, :) = matrix(:, :, 3)
    states%hst(:, :) = matrix(:, :, 4)
    states%hlr(:, :) = matrix(:, :, 5)
  END SUBROUTINE MATRIX_TO_STATES

!%      TODO comment
  SUBROUTINE VECTOR_TO_STATES(vector, states)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(INOUT) :: states
    REAL(sp), DIMENSION(ns), INTENT(IN) :: vector
    states%hi = vector(1)
    states%hp = vector(2)
    states%hft = vector(3)
    states%hst = vector(4)
    states%hlr = vector(5)
  END SUBROUTINE VECTOR_TO_STATES

!%      TODO comment        
  SUBROUTINE SET0_STATES(states)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(INOUT) :: states
    REAL(sp), DIMENSION(ns) :: vector0
    vector0 = 0._sp
    CALL VECTOR_TO_STATES(vector0, states)
  END SUBROUTINE SET0_STATES

!%      TODO comment        
  SUBROUTINE SET1_STATES(states)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(INOUT) :: states
    REAL(sp), DIMENSION(ns) :: vector1
    vector1 = 1._sp
    CALL VECTOR_TO_STATES(vector1, states)
  END SUBROUTINE SET1_STATES

END MODULE MWD_STATES_DIFF_D

!%      This module `mwd_output` encapsulates all SMASH output.
!%      This module is wrapped and differentiated.
!%
!%      OutputDT type:
!%      
!%      </> Public
!%      ======================== =======================================
!%      `Variables`              Description
!%      ======================== =======================================
!%      ``qsim``                 Simulated discharge at gauge            [m3/s]
!%      ``qsim_domain``          Simulated discharge whole domain        [m3/s]
!%      ``sparse_qsim_domain``   Sparse simulated discharge whole domain [m3/s]
!%      ``parameters_gradient``  Parameters gradients
!%      ``cost``                 Cost value
!%      ``sp1``                  Scalar product <dY*, dY>
!%      ``sp2``                  Scalar product <dk*, dk>
!%      ``an``                   Alpha gradient test 
!%      ``ian``                  Ialpha gradient test
!%      ``fstates``              Final states (StatesDT)
!%      ======================== =======================================
!%
!%      contains
!%
!%      [1] OutputDT_initialise
MODULE MWD_OUTPUT_DIFF_D
!% only: sp, dp, lchar, np, ns
  USE MWD_COMMON
!% only: SetupDT
  USE MWD_SETUP
!%only: MeshDT
  USE MWD_MESH
!%only: StatesDT, StatesDT_initialise
  USE MWD_STATES_DIFF_D
  IMPLICIT NONE
  TYPE OUTPUTDT
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: qsim
      REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: qsim_domain
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: sparse_qsim_domain
      REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: parameters_gradient
      REAL(sp) :: cost
      REAL(sp) :: sp1
      REAL(sp) :: sp2
      REAL(sp), DIMENSION(:), ALLOCATABLE :: an
      REAL(sp), DIMENSION(:), ALLOCATABLE :: ian
      TYPE(STATESDT) :: fstates
  END TYPE OUTPUTDT
  TYPE OUTPUTDT_DIFF_D
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: qsim
  END TYPE OUTPUTDT_DIFF_D

CONTAINS
  SUBROUTINE OUTPUTDT_INITIALISE(output, setup, mesh)
    IMPLICIT NONE
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(SETUPDT), INTENT(INOUT) :: setup
    TYPE(MESHDT), INTENT(INOUT) :: mesh
    IF (mesh%ng .GT. 0) THEN
      ALLOCATE(output%qsim(mesh%ng, setup%ntime_step))
      output%qsim = -99._sp
    END IF
    IF (setup%save_qsim_domain) THEN
      IF (setup%sparse_storage) THEN
        ALLOCATE(output%sparse_qsim_domain(mesh%nac, setup%ntime_step))
        output%sparse_qsim_domain = -99._sp
      ELSE
        ALLOCATE(output%qsim_domain(mesh%nrow, mesh%ncol, setup%&
&       ntime_step))
        output%qsim_domain = -99._sp
      END IF
    END IF
    CALL STATESDT_INITIALISE(output%fstates, mesh)
  END SUBROUTINE OUTPUTDT_INITIALISE

END MODULE MWD_OUTPUT_DIFF_D

!%    This module `mwd_cost` encapsulates all SMASH cost (type, subroutines, functions)
!%    This module is wrapped and differentiated.
!%
!%      contains
!%
!%      [1]  compute_jobs
!%      [2]  compute_jreg
!%      [3]  compute_cost
!%      [4]  nse
!%      [5]  kge_components
!%      [6]  kge
!%      [7]  se
!%      [8]  rmse
!%      [9]  logarithmique
!%      [10] reg_prior
MODULE MWD_COST_DIFF_D
!% only: sp, dp, lchar, np, ns
  USE MWD_COMMON
!% only: SetupDT
  USE MWD_SETUP
!%only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: ParametersDT
  USE MWD_PARAMETERS_DIFF_D
!% only: StatesDT
  USE MWD_STATES_DIFF_D
!% only: OutputDT
  USE MWD_OUTPUT_DIFF_D
  IMPLICIT NONE
  PUBLIC :: compute_jobs, compute_jreg, compute_cost
  PUBLIC :: compute_jobs_d, compute_jreg_d, compute_cost_d

CONTAINS
!  Differentiation of compute_jobs in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: jobs
!   with respect to varying inputs: *(output.qsim)
!   Plus diff mem management of: output.qsim:in
  SUBROUTINE COMPUTE_JOBS_D(setup, mesh, input_data, output, output_d, &
&   jobs, jobs_d)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT_DIFF_D), INTENT(INOUT) :: output_d
    REAL(sp), INTENT(OUT) :: jobs
    REAL(sp), INTENT(OUT) :: jobs_d
    REAL(sp), DIMENSION(setup%ntime_step-setup%optim_start_step+1) :: qo&
&   , qs
    REAL(sp), DIMENSION(setup%ntime_step-setup%optim_start_step+1) :: &
&   qs_d
    REAL(sp), DIMENSION(mesh%ng) :: gauge_jobs
    REAL(sp), DIMENSION(mesh%ng) :: gauge_jobs_d
    REAL(sp) :: imd
    REAL(sp) :: imd_d
    INTEGER :: g, row, col
    INTRINSIC REAL
    INTRINSIC ANY
    jobs = 0._sp
    gauge_jobs = 0._sp
    gauge_jobs_d = 0.0_4
    DO g=1,mesh%ng
      qs_d = setup%dt*1e3_sp*output_d%qsim(g, setup%optim_start_step:&
&       setup%ntime_step)/mesh%area(g)
      qs = output%qsim(g, setup%optim_start_step:setup%ntime_step)*setup&
&       %dt/mesh%area(g)*1e3_sp
      row = mesh%gauge_pos(g, 1)
      col = mesh%gauge_pos(g, 2)
      qo = input_data%qobs(g, setup%optim_start_step:setup%ntime_step)*&
&       setup%dt/(REAL(mesh%drained_area(row, col))*mesh%dx*mesh%dx)*&
&       1e3_sp
      IF (ANY(qo .GE. 0._sp)) THEN
        SELECT CASE  (setup%jobs_fun) 
        CASE ('nse') 
          gauge_jobs_d(g) = NSE_D(qo, qs, qs_d, gauge_jobs(g))
        CASE ('kge') 
          gauge_jobs_d(g) = KGE_D(qo, qs, qs_d, gauge_jobs(g))
        CASE ('kge2') 
          imd_d = KGE_D(qo, qs, qs_d, imd)
          gauge_jobs_d(g) = 2*imd*imd_d
          gauge_jobs(g) = imd*imd
        CASE ('se') 
          gauge_jobs_d(g) = SE_D(qo, qs, qs_d, gauge_jobs(g))
        CASE ('rmse') 
          gauge_jobs_d(g) = RMSE_D(qo, qs, qs_d, gauge_jobs(g))
        CASE ('logarithmique') 
          gauge_jobs_d(g) = LOGARITHMIQUE_D(qo, qs, qs_d, gauge_jobs(g))
        END SELECT
      END IF
    END DO
    jobs_d = 0.0_4
    DO g=1,mesh%ng
      jobs_d = jobs_d + mesh%wgauge(g)*gauge_jobs_d(g)
      jobs = jobs + mesh%wgauge(g)*gauge_jobs(g)
    END DO
  END SUBROUTINE COMPUTE_JOBS_D

  SUBROUTINE COMPUTE_JOBS(setup, mesh, input_data, output, jobs)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    REAL(sp), INTENT(OUT) :: jobs
    REAL(sp), DIMENSION(setup%ntime_step-setup%optim_start_step+1) :: qo&
&   , qs
    REAL(sp), DIMENSION(mesh%ng) :: gauge_jobs
    REAL(sp) :: imd
    INTEGER :: g, row, col
    INTRINSIC REAL
    INTRINSIC ANY
    jobs = 0._sp
    gauge_jobs = 0._sp
    DO g=1,mesh%ng
      qs = output%qsim(g, setup%optim_start_step:setup%ntime_step)*setup&
&       %dt/mesh%area(g)*1e3_sp
      row = mesh%gauge_pos(g, 1)
      col = mesh%gauge_pos(g, 2)
      qo = input_data%qobs(g, setup%optim_start_step:setup%ntime_step)*&
&       setup%dt/(REAL(mesh%drained_area(row, col))*mesh%dx*mesh%dx)*&
&       1e3_sp
      IF (ANY(qo .GE. 0._sp)) THEN
        SELECT CASE  (setup%jobs_fun) 
        CASE ('nse') 
          gauge_jobs(g) = NSE(qo, qs)
        CASE ('kge') 
          gauge_jobs(g) = KGE(qo, qs)
        CASE ('kge2') 
          imd = KGE(qo, qs)
          gauge_jobs(g) = imd*imd
        CASE ('se') 
          gauge_jobs(g) = SE(qo, qs)
        CASE ('rmse') 
          gauge_jobs(g) = RMSE(qo, qs)
        CASE ('logarithmique') 
          gauge_jobs(g) = LOGARITHMIQUE(qo, qs)
        END SELECT
      END IF
    END DO
    DO g=1,mesh%ng
      jobs = jobs + mesh%wgauge(g)*gauge_jobs(g)
    END DO
  END SUBROUTINE COMPUTE_JOBS

!  Differentiation of compute_jreg in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: jreg
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.lr)
!                *(states.hi) *(states.hp) *(states.hft) *(states.hst)
!                *(states.hlr)
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.lr:in
!                states.hi:in states.hp:in states.hft:in states.hst:in
!                states.hlr:in
!% WIP
  SUBROUTINE COMPUTE_JREG_D(setup, mesh, parameters, parameters_d, &
&   parameters_bgd, states, states_d, states_bgd, jreg, jreg_d)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters, parameters_bgd
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters_d
    TYPE(STATESDT), INTENT(IN) :: states, states_bgd
    TYPE(STATESDT), INTENT(IN) :: states_d
    REAL(sp), INTENT(INOUT) :: jreg
    REAL(sp), INTENT(INOUT) :: jreg_d
    REAL(sp) :: parameters_jreg, states_jreg
    REAL(sp) :: parameters_jreg_d, states_jreg_d
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, np) :: parameters_matrix, &
&   parameters_bgd_matrix
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, np) :: parameters_matrix_d
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, ns) :: states_matrix, &
&   states_bgd_matrix
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, ns) :: states_matrix_d
    CALL PARAMETERS_TO_MATRIX_D(parameters, parameters_d, &
&                         parameters_matrix, parameters_matrix_d)
    CALL PARAMETERS_TO_MATRIX(parameters_bgd, parameters_bgd_matrix)
    CALL STATES_TO_MATRIX_D(states, states_d, states_matrix, &
&                     states_matrix_d)
    CALL STATES_TO_MATRIX(states_bgd, states_bgd_matrix)
    jreg = 0._sp
    parameters_jreg = 0._sp
    states_jreg = 0._sp
    SELECT CASE  (setup%jreg_fun) 
    CASE ('prior') 
!% Normalize prior between parameters and states
      parameters_jreg_d = REG_PRIOR_D(mesh, np, parameters_matrix, &
&       parameters_matrix_d, parameters_bgd_matrix, parameters_jreg)
      states_jreg_d = REG_PRIOR_D(mesh, ns, states_matrix, &
&       states_matrix_d, states_bgd_matrix, states_jreg)
    CASE DEFAULT
      parameters_jreg_d = 0.0_4
      states_jreg_d = 0.0_4
    END SELECT
    jreg_d = parameters_jreg_d + states_jreg_d
    jreg = parameters_jreg + states_jreg
  END SUBROUTINE COMPUTE_JREG_D

!% WIP
  SUBROUTINE COMPUTE_JREG(setup, mesh, parameters, parameters_bgd, &
&   states, states_bgd, jreg)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters, parameters_bgd
    TYPE(STATESDT), INTENT(IN) :: states, states_bgd
    REAL(sp), INTENT(INOUT) :: jreg
    REAL(sp) :: parameters_jreg, states_jreg
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, np) :: parameters_matrix, &
&   parameters_bgd_matrix
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, ns) :: states_matrix, &
&   states_bgd_matrix
    CALL PARAMETERS_TO_MATRIX(parameters, parameters_matrix)
    CALL PARAMETERS_TO_MATRIX(parameters_bgd, parameters_bgd_matrix)
    CALL STATES_TO_MATRIX(states, states_matrix)
    CALL STATES_TO_MATRIX(states_bgd, states_bgd_matrix)
    jreg = 0._sp
    parameters_jreg = 0._sp
    states_jreg = 0._sp
    SELECT CASE  (setup%jreg_fun) 
    CASE ('prior') 
!% Normalize prior between parameters and states
      parameters_jreg = REG_PRIOR(mesh, np, parameters_matrix, &
&       parameters_bgd_matrix)
      states_jreg = REG_PRIOR(mesh, ns, states_matrix, states_bgd_matrix&
&       )
    END SELECT
    jreg = parameters_jreg + states_jreg
  END SUBROUTINE COMPUTE_JREG

!  Differentiation of compute_cost in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: cost
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.lr)
!                *(output.qsim) *(states.hi) *(states.hp) *(states.hft)
!                *(states.hst) *(states.hlr)
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.lr:in
!                output.qsim:in states.hi:in states.hp:in states.hft:in
!                states.hst:in states.hlr:in
  SUBROUTINE COMPUTE_COST_D(setup, mesh, input_data, parameters, &
&   parameters_d, parameters_bgd, states, states_d, states_bgd, output, &
&   output_d, cost, cost_d)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters, parameters_bgd
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters_d
    TYPE(STATESDT), INTENT(IN) :: states, states_bgd
    TYPE(STATESDT), INTENT(IN) :: states_d
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT_DIFF_D), INTENT(INOUT) :: output_d
    REAL(sp), INTENT(INOUT) :: cost
    REAL(sp), INTENT(INOUT) :: cost_d
    REAL(sp) :: jobs, jreg
    REAL(sp) :: jobs_d, jreg_d
    CALL COMPUTE_JOBS_D(setup, mesh, input_data, output, output_d, jobs&
&                 , jobs_d)
!% Only compute in case wjreg > 0
    IF (setup%wjreg .GT. 0._sp) THEN
      CALL COMPUTE_JREG_D(setup, mesh, parameters, parameters_d, &
&                   parameters_bgd, states, states_d, states_bgd, jreg, &
&                   jreg_d)
    ELSE
      jreg = 0._sp
      jreg_d = 0.0_4
    END IF
    cost_d = jobs_d + setup%wjreg*jreg_d
    cost = jobs + setup%wjreg*jreg
    output%cost = cost
  END SUBROUTINE COMPUTE_COST_D

  SUBROUTINE COMPUTE_COST(setup, mesh, input_data, parameters, &
&   parameters_bgd, states, states_bgd, output, cost)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters, parameters_bgd
    TYPE(STATESDT), INTENT(IN) :: states, states_bgd
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    REAL(sp), INTENT(INOUT) :: cost
    REAL(sp) :: jobs, jreg
    CALL COMPUTE_JOBS(setup, mesh, input_data, output, jobs)
!% Only compute in case wjreg > 0
    IF (setup%wjreg .GT. 0._sp) THEN
      CALL COMPUTE_JREG(setup, mesh, parameters, parameters_bgd, states&
&                 , states_bgd, jreg)
    ELSE
      jreg = 0._sp
    END IF
    cost = jobs + setup%wjreg*jreg
    output%cost = cost
  END SUBROUTINE COMPUTE_COST

!  Differentiation of nse in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: res
!   with respect to varying inputs: y
  FUNCTION NSE_D(x, y, y_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:), INTENT(IN) :: y_d
    REAL(sp) :: res
    REAL(sp) :: res_d
    REAL(sp) :: sum_x, sum_xx, sum_yy, sum_xy, mean_x, num, den
    REAL(sp) :: sum_yy_d, sum_xy_d, num_d
    INTEGER :: i, n
    INTRINSIC SIZE
!% Metric computation
    n = 0
    sum_x = 0.
    sum_xx = 0.
    sum_yy = 0.
    sum_xy = 0.
    sum_yy_d = 0.0_4
    sum_xy_d = 0.0_4
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0.) THEN
        n = n + 1
        sum_x = sum_x + x(i)
        sum_xx = sum_xx + x(i)*x(i)
        sum_yy_d = sum_yy_d + 2*y(i)*y_d(i)
        sum_yy = sum_yy + y(i)*y(i)
        sum_xy_d = sum_xy_d + x(i)*y_d(i)
        sum_xy = sum_xy + x(i)*y(i)
      END IF
    END DO
    mean_x = sum_x/n
!% NSE numerator / denominator
    num_d = sum_yy_d - 2*sum_xy_d
    num = sum_xx - 2*sum_xy + sum_yy
    den = sum_xx - n*mean_x*mean_x
!% NSE criterion
    res_d = num_d/den
    res = num/den
  END FUNCTION NSE_D

  FUNCTION NSE(x, y) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp) :: res
    REAL(sp) :: sum_x, sum_xx, sum_yy, sum_xy, mean_x, num, den
    INTEGER :: i, n
    INTRINSIC SIZE
!% Metric computation
    n = 0
    sum_x = 0.
    sum_xx = 0.
    sum_yy = 0.
    sum_xy = 0.
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0.) THEN
        n = n + 1
        sum_x = sum_x + x(i)
        sum_xx = sum_xx + x(i)*x(i)
        sum_yy = sum_yy + y(i)*y(i)
        sum_xy = sum_xy + x(i)*y(i)
      END IF
    END DO
    mean_x = sum_x/n
!% NSE numerator / denominator
    num = sum_xx - 2*sum_xy + sum_yy
    den = sum_xx - n*mean_x*mean_x
!% NSE criterion
    res = num/den
  END FUNCTION NSE

!  Differentiation of kge_components in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: r a b
!   with respect to varying inputs: y
  SUBROUTINE KGE_COMPONENTS_D(x, y, y_d, r, r_d, a, a_d, b, b_d)
    IMPLICIT NONE
    REAL, DIMENSION(:), INTENT(IN) :: x, y
    REAL, DIMENSION(:), INTENT(IN) :: y_d
    REAL, INTENT(INOUT) :: r, a, b
    REAL, INTENT(INOUT) :: r_d, a_d, b_d
    REAL :: sum_x, sum_y, sum_xx, sum_yy, sum_xy, mean_x, mean_y, var_x&
&   , var_y, cov
    REAL :: sum_y_d, sum_yy_d, sum_xy_d, mean_y_d, var_y_d, cov_d
    INTEGER :: n, i
    INTRINSIC SIZE
    INTRINSIC SQRT
    REAL :: result1
    REAL :: result1_d
    REAL :: result2
    REAL :: result2_d
    REAL :: temp
! Metric computation
    n = 0
    sum_x = 0.
    sum_y = 0.
    sum_xx = 0.
    sum_yy = 0.
    sum_xy = 0.
    sum_yy_d = 0.0
    sum_y_d = 0.0
    sum_xy_d = 0.0
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0.) THEN
        n = n + 1
        sum_x = sum_x + x(i)
        sum_y_d = sum_y_d + y_d(i)
        sum_y = sum_y + y(i)
        sum_xx = sum_xx + x(i)*x(i)
        sum_yy_d = sum_yy_d + 2*y(i)*y_d(i)
        sum_yy = sum_yy + y(i)*y(i)
        sum_xy_d = sum_xy_d + x(i)*y_d(i)
        sum_xy = sum_xy + x(i)*y(i)
      END IF
    END DO
    mean_x = sum_x/n
    mean_y_d = sum_y_d/n
    mean_y = sum_y/n
    var_x = sum_xx/n - mean_x*mean_x
    var_y_d = sum_yy_d/n - 2*mean_y*mean_y_d
    var_y = sum_yy/n - mean_y*mean_y
    cov_d = sum_xy_d/n - mean_x*mean_y_d
    cov = sum_xy/n - mean_x*mean_y
! KGE components (r, alpha, beta)
    result1 = SQRT(var_x)
    temp = SQRT(var_y)
    IF (var_y .EQ. 0.0) THEN
      result2_d = 0.0
    ELSE
      result2_d = var_y_d/(2.0*temp)
    END IF
    result2 = temp
    temp = cov/(result1*result2)
    r_d = (cov_d-temp*result1*result2_d)/(result1*result2)
    r = temp
    temp = SQRT(var_y)
    IF (var_y .EQ. 0.0) THEN
      result1_d = 0.0
    ELSE
      result1_d = var_y_d/(2.0*temp)
    END IF
    result1 = temp
    result2 = SQRT(var_x)
    a_d = result1_d/result2
    a = result1/result2
    b_d = mean_y_d/mean_x
    b = mean_y/mean_x
  END SUBROUTINE KGE_COMPONENTS_D

  SUBROUTINE KGE_COMPONENTS(x, y, r, a, b)
    IMPLICIT NONE
    REAL, DIMENSION(:), INTENT(IN) :: x, y
    REAL, INTENT(INOUT) :: r, a, b
    REAL :: sum_x, sum_y, sum_xx, sum_yy, sum_xy, mean_x, mean_y, var_x&
&   , var_y, cov
    INTEGER :: n, i
    INTRINSIC SIZE
    INTRINSIC SQRT
    REAL :: result1
    REAL :: result2
! Metric computation
    n = 0
    sum_x = 0.
    sum_y = 0.
    sum_xx = 0.
    sum_yy = 0.
    sum_xy = 0.
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0.) THEN
        n = n + 1
        sum_x = sum_x + x(i)
        sum_y = sum_y + y(i)
        sum_xx = sum_xx + x(i)*x(i)
        sum_yy = sum_yy + y(i)*y(i)
        sum_xy = sum_xy + x(i)*y(i)
      END IF
    END DO
    mean_x = sum_x/n
    mean_y = sum_y/n
    var_x = sum_xx/n - mean_x*mean_x
    var_y = sum_yy/n - mean_y*mean_y
    cov = sum_xy/n - mean_x*mean_y
! KGE components (r, alpha, beta)
    result1 = SQRT(var_x)
    result2 = SQRT(var_y)
    r = cov/result1/result2
    result1 = SQRT(var_y)
    result2 = SQRT(var_x)
    a = result1/result2
    b = mean_y/mean_x
  END SUBROUTINE KGE_COMPONENTS

!  Differentiation of kge in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: res
!   with respect to varying inputs: y
  FUNCTION KGE_D(x, y, y_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL, DIMENSION(:), INTENT(IN) :: x, y
    REAL, DIMENSION(:), INTENT(IN) :: y_d
    REAL :: res
    REAL :: res_d
    REAL :: r, a, b
    REAL :: r_d, a_d, b_d
    INTRINSIC SQRT
    REAL :: arg1
    REAL :: arg1_d
    REAL :: temp
    CALL KGE_COMPONENTS_D(x, y, y_d, r, r_d, a, a_d, b, b_d)
! KGE criterion
    arg1_d = 2*(r-1)*r_d + 2*(b-1)*b_d + 2*(a-1)*a_d
    arg1 = (r-1)*(r-1) + (b-1)*(b-1) + (a-1)*(a-1)
    temp = SQRT(arg1)
    IF (arg1 .EQ. 0.0) THEN
      res_d = 0.0
    ELSE
      res_d = arg1_d/(2.0*temp)
    END IF
    res = temp
  END FUNCTION KGE_D

  FUNCTION KGE(x, y) RESULT (RES)
    IMPLICIT NONE
    REAL, DIMENSION(:), INTENT(IN) :: x, y
    REAL :: res
    REAL :: r, a, b
    INTRINSIC SQRT
    REAL :: arg1
    CALL KGE_COMPONENTS(x, y, r, a, b)
! KGE criterion
    arg1 = (r-1)*(r-1) + (b-1)*(b-1) + (a-1)*(a-1)
    res = SQRT(arg1)
  END FUNCTION KGE

!  Differentiation of se in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: res
!   with respect to varying inputs: y
  FUNCTION SE_D(x, y, y_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL, DIMENSION(:), INTENT(IN) :: x, y
    REAL, DIMENSION(:), INTENT(IN) :: y_d
    REAL :: res
    REAL :: res_d
    INTEGER :: i
    INTRINSIC SIZE
    res = 0.
    res_d = 0.0
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0.) THEN
        res_d = res_d - 2*(x(i)-y(i))*y_d(i)
        res = res + (x(i)-y(i))*(x(i)-y(i))
      END IF
    END DO
  END FUNCTION SE_D

  FUNCTION SE(x, y) RESULT (RES)
    IMPLICIT NONE
    REAL, DIMENSION(:), INTENT(IN) :: x, y
    REAL :: res
    INTEGER :: i
    INTRINSIC SIZE
    res = 0.
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0.) res = res + (x(i)-y(i))*(x(i)-y(i))
    END DO
  END FUNCTION SE

!  Differentiation of rmse in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: res
!   with respect to varying inputs: y
  FUNCTION RMSE_D(x, y, y_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL, DIMENSION(:), INTENT(IN) :: x, y
    REAL, DIMENSION(:), INTENT(IN) :: y_d
    REAL :: res
    REAL :: res_d
    INTEGER :: i, n
    INTRINSIC SIZE
    INTRINSIC SQRT
    REAL :: result1
    REAL :: result1_d
    REAL :: temp
    n = 0
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0.) n = n + 1
    END DO
    result1_d = SE_D(x, y, y_d, result1)
    temp = SQRT(result1/n)
    IF (result1/n .EQ. 0.0) THEN
      res_d = 0.0
    ELSE
      res_d = result1_d/(2.0*temp*n)
    END IF
    res = temp
  END FUNCTION RMSE_D

  FUNCTION RMSE(x, y) RESULT (RES)
    IMPLICIT NONE
    REAL, DIMENSION(:), INTENT(IN) :: x, y
    REAL :: res
    INTEGER :: i, n
    INTRINSIC SIZE
    INTRINSIC SQRT
    REAL :: result1
    n = 0
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0.) n = n + 1
    END DO
    result1 = SE(x, y)
    res = SQRT(result1/n)
  END FUNCTION RMSE

!  Differentiation of logarithmique in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: res
!   with respect to varying inputs: y
  FUNCTION LOGARITHMIQUE_D(x, y, y_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL, DIMENSION(:), INTENT(IN) :: x, y
    REAL, DIMENSION(:), INTENT(IN) :: y_d
    REAL :: res
    REAL :: res_d
    INTEGER :: i
    INTRINSIC SIZE
    INTRINSIC LOG
    REAL :: arg1
    REAL :: arg1_d
    REAL :: arg2
    REAL :: arg2_d
    REAL :: temp
    REAL :: temp0
    res = 0.
    res_d = 0.0
    DO i=1,SIZE(x)
      IF (x(i) .GT. 0. .AND. y(i) .GT. 0.) THEN
        arg1_d = y_d(i)/x(i)
        arg1 = y(i)/x(i)
        arg2_d = y_d(i)/x(i)
        arg2 = y(i)/x(i)
        temp = LOG(arg2)
        temp0 = LOG(arg1)
        res_d = res_d + x(i)*(temp*arg1_d/arg1+temp0*arg2_d/arg2)
        res = res + x(i)*(temp0*temp)
      END IF
    END DO
  END FUNCTION LOGARITHMIQUE_D

  FUNCTION LOGARITHMIQUE(x, y) RESULT (RES)
    IMPLICIT NONE
    REAL, DIMENSION(:), INTENT(IN) :: x, y
    REAL :: res
    INTEGER :: i
    INTRINSIC SIZE
    INTRINSIC LOG
    REAL :: arg1
    REAL :: arg2
    res = 0.
    DO i=1,SIZE(x)
      IF (x(i) .GT. 0. .AND. y(i) .GT. 0.) THEN
        arg1 = y(i)/x(i)
        arg2 = y(i)/x(i)
        res = res + x(i)*LOG(arg1)*LOG(arg2)
      END IF
    END DO
  END FUNCTION LOGARITHMIQUE

!  Differentiation of reg_prior in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: res
!   with respect to varying inputs: matrix
!% TODO refactorize
  FUNCTION REG_PRIOR_D(mesh, size_mat3, matrix, matrix_d, matrix_bgd, &
&   res) RESULT (RES_D)
    IMPLICIT NONE
    TYPE(MESHDT), INTENT(IN) :: mesh
    INTEGER, INTENT(IN) :: size_mat3
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, size_mat3), INTENT(IN) :: &
&   matrix, matrix_bgd
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, size_mat3), INTENT(IN) :: &
&   matrix_d
    REAL(sp) :: res
    REAL(sp) :: res_d
    INTRINSIC SUM
    res_d = SUM(2*(matrix-matrix_bgd)*matrix_d)
    res = SUM((matrix-matrix_bgd)*(matrix-matrix_bgd))
  END FUNCTION REG_PRIOR_D

!% TODO refactorize
  FUNCTION REG_PRIOR(mesh, size_mat3, matrix, matrix_bgd) RESULT (RES)
    IMPLICIT NONE
    TYPE(MESHDT), INTENT(IN) :: mesh
    INTEGER, INTENT(IN) :: size_mat3
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, size_mat3), INTENT(IN) :: &
&   matrix, matrix_bgd
    REAL(sp) :: res
    INTRINSIC SUM
    res = SUM((matrix-matrix_bgd)*(matrix-matrix_bgd))
  END FUNCTION REG_PRIOR

END MODULE MWD_COST_DIFF_D

!%      This module `md_operator` encapsulates all SMASH operator.
!%      This module is differentiated.
!%
!%      contains
!%
!%      [1] GR_interception
!%      [2] GR_production
!%      [3] GR_exchange
!%      [4] GR_transferN
!%      [5] upstream_discharge
!%      [6] sparse_upstream_discharge
!%      [7] GR_transfer1
MODULE MD_OPERATOR_DIFF_D
!% only : sp
  USE MWD_COMMON
  IMPLICIT NONE

CONTAINS
!  Differentiation of gr_interception in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: hi ei pn
!   with respect to varying inputs: hi ci
!% TODO comment
  SUBROUTINE GR_INTERCEPTION_D(prcp, pet, ci, ci_d, hi, hi_d, pn, pn_d, &
&   ei, ei_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: prcp, pet, ci
    REAL(sp), INTENT(IN) :: ci_d
    REAL(sp), INTENT(INOUT) :: hi
    REAL(sp), INTENT(INOUT) :: hi_d
    REAL(sp), INTENT(OUT) :: pn, ei
    REAL(sp), INTENT(OUT) :: pn_d, ei_d
    INTRINSIC MIN
    INTRINSIC MAX
    REAL(sp) :: temp
    IF (pet .GT. prcp + hi*ci) THEN
      ei_d = ci*hi_d + hi*ci_d
      ei = prcp + hi*ci
    ELSE
      ei = pet
      ei_d = 0.0_4
    END IF
    IF (0._sp .LT. prcp - ci*(1._sp-hi) - ei) THEN
      pn_d = ci*hi_d - (1._sp-hi)*ci_d - ei_d
      pn = prcp - ci*(1._sp-hi) - ei
    ELSE
      pn = 0._sp
      pn_d = 0.0_4
    END IF
    temp = (prcp-ei-pn)/ci
    hi_d = hi_d + (-ei_d-pn_d-temp*ci_d)/ci
    hi = hi + temp
  END SUBROUTINE GR_INTERCEPTION_D

!% TODO comment
  SUBROUTINE GR_INTERCEPTION(prcp, pet, ci, hi, pn, ei)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: prcp, pet, ci
    REAL(sp), INTENT(INOUT) :: hi
    REAL(sp), INTENT(OUT) :: pn, ei
    INTRINSIC MIN
    INTRINSIC MAX
    IF (pet .GT. prcp + hi*ci) THEN
      ei = prcp + hi*ci
    ELSE
      ei = pet
    END IF
    IF (0._sp .LT. prcp - ci*(1._sp-hi) - ei) THEN
      pn = prcp - ci*(1._sp-hi) - ei
    ELSE
      pn = 0._sp
    END IF
    hi = hi + (prcp-ei-pn)/ci
  END SUBROUTINE GR_INTERCEPTION

!  Differentiation of gr_production in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: hp perc pr
!   with respect to varying inputs: hp en beta cp pn
  SUBROUTINE GR_PRODUCTION_D(pn, pn_d, en, en_d, cp, cp_d, beta, beta_d&
&   , hp, hp_d, pr, pr_d, perc, perc_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: pn, en, cp, beta
    REAL(sp), INTENT(IN) :: pn_d, en_d, cp_d, beta_d
    REAL(sp), INTENT(INOUT) :: hp
    REAL(sp), INTENT(INOUT) :: hp_d
    REAL(sp), INTENT(OUT) :: pr, perc
    REAL(sp), INTENT(OUT) :: pr_d, perc_d
    REAL(sp) :: inv_cp, ps, es, hp_imd
    REAL(sp) :: inv_cp_d, ps_d, es_d, hp_imd_d
    INTRINSIC TANH
    REAL(sp) :: pwx1
    REAL(sp) :: pwx1_d
    REAL(sp) :: pwr1
    REAL(sp) :: pwr1_d
    REAL(sp) :: temp
    REAL(sp) :: temp0
    REAL(sp) :: temp1
    REAL(sp) :: temp2
    inv_cp_d = -(cp_d/cp**2)
    inv_cp = 1._sp/cp
    pr = 0._sp
    temp = TANH(pn*inv_cp)
    temp0 = TANH(pn*inv_cp)
    temp1 = cp*(-(hp*hp)+1._sp)
    temp2 = temp1*temp0/(hp*temp+1._sp)
    ps_d = (temp0*((1._sp-hp**2)*cp_d-cp*2*hp*hp_d)+temp1*(1.0-TANH(pn*&
&     inv_cp)**2)*(inv_cp*pn_d+pn*inv_cp_d)-temp2*(temp*hp_d+hp*(1.0-&
&     TANH(pn*inv_cp)**2)*(inv_cp*pn_d+pn*inv_cp_d)))/(hp*temp+1._sp)
    ps = temp2
    temp2 = TANH(en*inv_cp)
    temp1 = TANH(en*inv_cp)
    temp0 = hp*cp*(-hp+2._sp)
    temp = temp0*temp1/((-hp+1._sp)*temp2+1._sp)
    es_d = (temp1*((2._sp-hp)*(cp*hp_d+hp*cp_d)-hp*cp*hp_d)+temp0*(1.0-&
&     TANH(en*inv_cp)**2)*(inv_cp*en_d+en*inv_cp_d)-temp*((1._sp-hp)*(&
&     1.0-TANH(en*inv_cp)**2)*(inv_cp*en_d+en*inv_cp_d)-temp2*hp_d))/((&
&     1._sp-hp)*temp2+1._sp)
    es = temp
    hp_imd_d = hp_d + inv_cp*(ps_d-es_d) + (ps-es)*inv_cp_d
    hp_imd = hp + (ps-es)*inv_cp
    IF (pn .GT. 0) THEN
      pr_d = pn_d - cp*(hp_imd_d-hp_d) - (hp_imd-hp)*cp_d
      pr = pn - (hp_imd-hp)*cp
    ELSE
      pr_d = 0.0_4
    END IF
    pwx1_d = 4*hp_imd**3*(hp_imd_d-hp_imd*beta_d/beta)/beta**4
    pwx1 = 1._sp + (hp_imd/beta)**4
    pwr1_d = -(0.25_sp*pwx1**(-1.25)*pwx1_d)
    pwr1 = pwx1**(-0.25_sp)
    perc_d = (1._sp-pwr1)*(cp*hp_imd_d+hp_imd*cp_d) - hp_imd*cp*pwr1_d
    perc = hp_imd*cp*(1._sp-pwr1)
    hp_d = hp_imd_d - inv_cp*perc_d - perc*inv_cp_d
    hp = hp_imd - perc*inv_cp
  END SUBROUTINE GR_PRODUCTION_D

  SUBROUTINE GR_PRODUCTION(pn, en, cp, beta, hp, pr, perc)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: pn, en, cp, beta
    REAL(sp), INTENT(INOUT) :: hp
    REAL(sp), INTENT(OUT) :: pr, perc
    REAL(sp) :: inv_cp, ps, es, hp_imd
    INTRINSIC TANH
    REAL(sp) :: pwx1
    REAL(sp) :: pwr1
    inv_cp = 1._sp/cp
    pr = 0._sp
    ps = cp*(1._sp-hp*hp)*TANH(pn*inv_cp)/(1._sp+hp*TANH(pn*inv_cp))
    es = hp*cp*(2._sp-hp)*TANH(en*inv_cp)/(1._sp+(1._sp-hp)*TANH(en*&
&     inv_cp))
    hp_imd = hp + (ps-es)*inv_cp
    IF (pn .GT. 0) pr = pn - (hp_imd-hp)*cp
    pwx1 = 1._sp + (hp_imd/beta)**4
    pwr1 = pwx1**(-0.25_sp)
    perc = hp_imd*cp*(1._sp-pwr1)
    hp = hp_imd - perc*inv_cp
  END SUBROUTINE GR_PRODUCTION

!  Differentiation of gr_exchange in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: l
!   with respect to varying inputs: hft exc
  SUBROUTINE GR_EXCHANGE_D(exc, exc_d, hft, hft_d, l, l_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: exc
    REAL(sp), INTENT(IN) :: exc_d
    REAL(sp), INTENT(INOUT) :: hft
    REAL(sp), INTENT(INOUT) :: hft_d
    REAL(sp), INTENT(OUT) :: l
    REAL(sp), INTENT(OUT) :: l_d
    REAL(sp) :: temp
    temp = hft**3.5_sp
    l_d = temp*exc_d + exc*3.5_sp*hft**2.5*hft_d
    l = exc*temp
  END SUBROUTINE GR_EXCHANGE_D

  SUBROUTINE GR_EXCHANGE(exc, hft, l)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: exc
    REAL(sp), INTENT(INOUT) :: hft
    REAL(sp), INTENT(OUT) :: l
    l = exc*hft**3.5_sp
  END SUBROUTINE GR_EXCHANGE

!  Differentiation of gr_transfern in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: q ht
!   with respect to varying inputs: ht ct pr
  SUBROUTINE GR_TRANSFERN_D(n, prcp, pr, pr_d, ct, ct_d, ht, ht_d, q, &
&   q_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: n, prcp, pr, ct
    REAL(sp), INTENT(IN) :: pr_d, ct_d
    REAL(sp), INTENT(INOUT) :: ht
    REAL(sp), INTENT(INOUT) :: ht_d
    REAL(sp), INTENT(OUT) :: q
    REAL(sp), INTENT(OUT) :: q_d
    REAL(sp) :: pr_imd, ht_imd, nm1, d1pnm1
    REAL(sp) :: pr_imd_d, ht_imd_d
    INTRINSIC MAX
    REAL(sp) :: pwx1
    REAL(sp) :: pwx1_d
    REAL(sp) :: pwy1
    REAL(sp) :: pwr1
    REAL(sp) :: pwr1_d
    REAL(sp) :: pwy2
    REAL(sp) :: pwr2
    REAL(sp) :: pwr2_d
    REAL(sp) :: pwx3
    REAL(sp) :: pwx3_d
    REAL(sp) :: pwy3
    REAL(sp) :: pwr3
    REAL(sp) :: pwr3_d
    nm1 = n - 1._sp
    d1pnm1 = 1._sp/nm1
    IF (prcp .LT. 0._sp) THEN
      pwx1_d = ct*ht_d + ht*ct_d
      pwx1 = ht*ct
      pwy1 = -nm1
      IF (pwx1 .LE. 0.0 .AND. (pwy1 .EQ. 0.0 .OR. pwy1 .NE. INT(pwy1))) &
&     THEN
        pwr1_d = 0.0_4
      ELSE
        pwr1_d = pwy1*pwx1**(pwy1-1)*pwx1_d
      END IF
      pwr1 = pwx1**pwy1
      pwy2 = -nm1
      IF (ct .LE. 0.0 .AND. (pwy2 .EQ. 0.0 .OR. pwy2 .NE. INT(pwy2))) &
&     THEN
        pwr2_d = 0.0_4
      ELSE
        pwr2_d = pwy2*ct**(pwy2-1)*ct_d
      END IF
      pwr2 = ct**pwy2
      pwx3_d = pwr1_d - pwr2_d
      pwx3 = pwr1 - pwr2
      pwy3 = -d1pnm1
      IF (pwx3 .LE. 0.0 .AND. (pwy3 .EQ. 0.0 .OR. pwy3 .NE. INT(pwy3))) &
&     THEN
        pwr3_d = 0.0_4
      ELSE
        pwr3_d = pwy3*pwx3**(pwy3-1)*pwx3_d
      END IF
      pwr3 = pwx3**pwy3
      pr_imd_d = pwr3_d - ct*ht_d - ht*ct_d
      pr_imd = pwr3 - ht*ct
    ELSE
      pr_imd_d = pr_d
      pr_imd = pr
    END IF
    IF (1.e-6_sp .LT. ht + pr_imd/ct) THEN
      ht_imd_d = ht_d + (pr_imd_d-pr_imd*ct_d/ct)/ct
      ht_imd = ht + pr_imd/ct
    ELSE
      ht_imd = 1.e-6_sp
      ht_imd_d = 0.0_4
    END IF
    pwx1_d = ct*ht_imd_d + ht_imd*ct_d
    pwx1 = ht_imd*ct
    pwy1 = -nm1
    IF (pwx1 .LE. 0.0 .AND. (pwy1 .EQ. 0.0 .OR. pwy1 .NE. INT(pwy1))) &
&   THEN
      pwr1_d = 0.0_4
    ELSE
      pwr1_d = pwy1*pwx1**(pwy1-1)*pwx1_d
    END IF
    pwr1 = pwx1**pwy1
    pwy2 = -nm1
    IF (ct .LE. 0.0 .AND. (pwy2 .EQ. 0.0 .OR. pwy2 .NE. INT(pwy2))) THEN
      pwr2_d = 0.0_4
    ELSE
      pwr2_d = pwy2*ct**(pwy2-1)*ct_d
    END IF
    pwr2 = ct**pwy2
    pwx3_d = pwr1_d + pwr2_d
    pwx3 = pwr1 + pwr2
    pwy3 = -d1pnm1
    IF (pwx3 .LE. 0.0 .AND. (pwy3 .EQ. 0.0 .OR. pwy3 .NE. INT(pwy3))) &
&   THEN
      pwr3_d = 0.0_4
    ELSE
      pwr3_d = pwy3*pwx3**(pwy3-1)*pwx3_d
    END IF
    pwr3 = pwx3**pwy3
    ht_d = (pwr3_d-pwr3*ct_d/ct)/ct
    ht = pwr3/ct
    q_d = ct*(ht_imd_d-ht_d) + (ht_imd-ht)*ct_d
    q = (ht_imd-ht)*ct
  END SUBROUTINE GR_TRANSFERN_D

  SUBROUTINE GR_TRANSFERN(n, prcp, pr, ct, ht, q)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: n, prcp, pr, ct
    REAL(sp), INTENT(INOUT) :: ht
    REAL(sp), INTENT(OUT) :: q
    REAL(sp) :: pr_imd, ht_imd, nm1, d1pnm1
    INTRINSIC MAX
    REAL(sp) :: pwx1
    REAL(sp) :: pwy1
    REAL(sp) :: pwr1
    REAL(sp) :: pwy2
    REAL(sp) :: pwr2
    REAL(sp) :: pwx3
    REAL(sp) :: pwy3
    REAL(sp) :: pwr3
    nm1 = n - 1._sp
    d1pnm1 = 1._sp/nm1
    IF (prcp .LT. 0._sp) THEN
      pwx1 = ht*ct
      pwy1 = -nm1
      pwr1 = pwx1**pwy1
      pwy2 = -nm1
      pwr2 = ct**pwy2
      pwx3 = pwr1 - pwr2
      pwy3 = -d1pnm1
      pwr3 = pwx3**pwy3
      pr_imd = pwr3 - ht*ct
    ELSE
      pr_imd = pr
    END IF
    IF (1.e-6_sp .LT. ht + pr_imd/ct) THEN
      ht_imd = ht + pr_imd/ct
    ELSE
      ht_imd = 1.e-6_sp
    END IF
    pwx1 = ht_imd*ct
    pwy1 = -nm1
    pwr1 = pwx1**pwy1
    pwy2 = -nm1
    pwr2 = ct**pwy2
    pwx3 = pwr1 + pwr2
    pwy3 = -d1pnm1
    pwr3 = pwx3**pwy3
    ht = pwr3/ct
    q = (ht_imd-ht)*ct
  END SUBROUTINE GR_TRANSFERN

!  Differentiation of upstream_discharge in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: qup
!   with respect to varying inputs: q
  SUBROUTINE UPSTREAM_DISCHARGE_D(dt, dx, nrow, ncol, flwdir, &
&   drained_area, row, col, q, q_d, qup, qup_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt, dx
    INTEGER, INTENT(IN) :: nrow, ncol, row, col
    INTEGER, DIMENSION(nrow, ncol), INTENT(IN) :: flwdir, drained_area
    REAL(sp), DIMENSION(nrow, ncol), INTENT(IN) :: q
    REAL(sp), DIMENSION(nrow, ncol), INTENT(IN) :: q_d
    REAL(sp), INTENT(OUT) :: qup
    REAL(sp), INTENT(OUT) :: qup_d
    INTEGER :: i, row_imd, col_imd
    INTEGER, DIMENSION(8), SAVE :: dcol=(/0, -1, -1, -1, 0, 1, 1, 1/)
    INTEGER, DIMENSION(8), SAVE :: drow=(/1, 1, 0, -1, -1, -1, 0, 1/)
    INTEGER, DIMENSION(8), SAVE :: dkind=(/1, 2, 3, 4, 5, 6, 7, 8/)
    INTRINSIC REAL
    REAL*4 :: temp
    qup = 0._sp
    IF (drained_area(row, col) .GT. 1) THEN
      qup_d = 0.0_4
      DO i=1,8
        col_imd = col + dcol(i)
        row_imd = row + drow(i)
        IF (col_imd .GT. 0 .AND. col_imd .LE. ncol .AND. row_imd .GT. 0 &
&           .AND. row_imd .LE. nrow) THEN
          IF (flwdir(row_imd, col_imd) .EQ. dkind(i)) THEN
            qup_d = qup_d + q_d(row_imd, col_imd)
            qup = qup + q(row_imd, col_imd)
          END IF
        END IF
      END DO
      temp = 0.001_sp*(dx*dx)*REAL(drained_area(row, col)-1)
      qup_d = dt*qup_d/temp
      qup = dt*(qup/temp)
    ELSE
      qup_d = 0.0_4
    END IF
  END SUBROUTINE UPSTREAM_DISCHARGE_D

  SUBROUTINE UPSTREAM_DISCHARGE(dt, dx, nrow, ncol, flwdir, drained_area&
&   , row, col, q, qup)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt, dx
    INTEGER, INTENT(IN) :: nrow, ncol, row, col
    INTEGER, DIMENSION(nrow, ncol), INTENT(IN) :: flwdir, drained_area
    REAL(sp), DIMENSION(nrow, ncol), INTENT(IN) :: q
    REAL(sp), INTENT(OUT) :: qup
    INTEGER :: i, row_imd, col_imd
    INTEGER, DIMENSION(8), SAVE :: dcol=(/0, -1, -1, -1, 0, 1, 1, 1/)
    INTEGER, DIMENSION(8), SAVE :: drow=(/1, 1, 0, -1, -1, -1, 0, 1/)
    INTEGER, DIMENSION(8), SAVE :: dkind=(/1, 2, 3, 4, 5, 6, 7, 8/)
    INTRINSIC REAL
    qup = 0._sp
    IF (drained_area(row, col) .GT. 1) THEN
      DO i=1,8
        col_imd = col + dcol(i)
        row_imd = row + drow(i)
        IF (col_imd .GT. 0 .AND. col_imd .LE. ncol .AND. row_imd .GT. 0 &
&           .AND. row_imd .LE. nrow) THEN
          IF (flwdir(row_imd, col_imd) .EQ. dkind(i)) qup = qup + q(&
&             row_imd, col_imd)
        END IF
      END DO
      qup = qup*dt/(0.001_sp*dx*dx*REAL(drained_area(row, col)-1))
    END IF
  END SUBROUTINE UPSTREAM_DISCHARGE

!  Differentiation of sparse_upstream_discharge in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: qup
!   with respect to varying inputs: q
  SUBROUTINE SPARSE_UPSTREAM_DISCHARGE_D(dt, dx, nrow, ncol, nac, flwdir&
&   , drained_area, ind_sparse, row, col, q, q_d, qup, qup_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt, dx
    INTEGER, INTENT(IN) :: nrow, ncol, nac, row, col
    INTEGER, DIMENSION(nrow, ncol), INTENT(IN) :: flwdir, drained_area, &
&   ind_sparse
    REAL(sp), DIMENSION(nac), INTENT(IN) :: q
    REAL(sp), DIMENSION(nac), INTENT(IN) :: q_d
    REAL(sp), INTENT(OUT) :: qup
    REAL(sp), INTENT(OUT) :: qup_d
    INTEGER :: i, row_imd, col_imd, k
    INTEGER, DIMENSION(8), SAVE :: dcol=(/0, -1, -1, -1, 0, 1, 1, 1/)
    INTEGER, DIMENSION(8), SAVE :: drow=(/1, 1, 0, -1, -1, -1, 0, 1/)
    INTEGER, DIMENSION(8), SAVE :: dkind=(/1, 2, 3, 4, 5, 6, 7, 8/)
    INTRINSIC REAL
    REAL*4 :: temp
    qup = 0._sp
    IF (drained_area(row, col) .GT. 1) THEN
      qup_d = 0.0_4
      DO i=1,8
        col_imd = col + dcol(i)
        row_imd = row + drow(i)
        IF (col_imd .GT. 0 .AND. col_imd .LE. ncol .AND. row_imd .GT. 0 &
&           .AND. row_imd .LE. nrow) THEN
          IF (flwdir(row_imd, col_imd) .EQ. dkind(i)) THEN
            k = ind_sparse(row_imd, col_imd)
            qup_d = qup_d + q_d(k)
            qup = qup + q(k)
          END IF
        END IF
      END DO
      temp = 0.001_sp*(dx*dx)*REAL(drained_area(row, col)-1)
      qup_d = dt*qup_d/temp
      qup = dt*(qup/temp)
    ELSE
      qup_d = 0.0_4
    END IF
  END SUBROUTINE SPARSE_UPSTREAM_DISCHARGE_D

  SUBROUTINE SPARSE_UPSTREAM_DISCHARGE(dt, dx, nrow, ncol, nac, flwdir, &
&   drained_area, ind_sparse, row, col, q, qup)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt, dx
    INTEGER, INTENT(IN) :: nrow, ncol, nac, row, col
    INTEGER, DIMENSION(nrow, ncol), INTENT(IN) :: flwdir, drained_area, &
&   ind_sparse
    REAL(sp), DIMENSION(nac), INTENT(IN) :: q
    REAL(sp), INTENT(OUT) :: qup
    INTEGER :: i, row_imd, col_imd, k
    INTEGER, DIMENSION(8), SAVE :: dcol=(/0, -1, -1, -1, 0, 1, 1, 1/)
    INTEGER, DIMENSION(8), SAVE :: drow=(/1, 1, 0, -1, -1, -1, 0, 1/)
    INTEGER, DIMENSION(8), SAVE :: dkind=(/1, 2, 3, 4, 5, 6, 7, 8/)
    INTRINSIC REAL
    qup = 0._sp
    IF (drained_area(row, col) .GT. 1) THEN
      DO i=1,8
        col_imd = col + dcol(i)
        row_imd = row + drow(i)
        IF (col_imd .GT. 0 .AND. col_imd .LE. ncol .AND. row_imd .GT. 0 &
&           .AND. row_imd .LE. nrow) THEN
          IF (flwdir(row_imd, col_imd) .EQ. dkind(i)) THEN
            k = ind_sparse(row_imd, col_imd)
            qup = qup + q(k)
          END IF
        END IF
      END DO
      qup = qup*dt/(0.001_sp*dx*dx*REAL(drained_area(row, col)-1))
    END IF
  END SUBROUTINE SPARSE_UPSTREAM_DISCHARGE

!  Differentiation of gr_transfer1 in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: hr qrout
!   with respect to varying inputs: qup hr lr
  SUBROUTINE GR_TRANSFER1_D(dt, qup, qup_d, lr, lr_d, hr, hr_d, qrout, &
&   qrout_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt
    REAL(sp), INTENT(IN) :: qup, lr
    REAL(sp), INTENT(IN) :: qup_d, lr_d
    REAL(sp), INTENT(INOUT) :: hr
    REAL(sp), INTENT(INOUT) :: hr_d
    REAL(sp), INTENT(OUT) :: qrout
    REAL(sp), INTENT(OUT) :: qrout_d
    REAL(sp) :: hr_imd
    REAL(sp) :: hr_imd_d
    INTRINSIC EXP
    REAL(sp) :: arg1
    REAL(sp) :: arg1_d
    REAL(sp) :: temp
    hr_imd_d = hr_d + qup_d
    hr_imd = hr + qup
    temp = dt/(60._sp*lr)
    arg1_d = temp*lr_d/lr
    arg1 = -temp
    temp = EXP(arg1)
    hr_d = temp*hr_imd_d + hr_imd*EXP(arg1)*arg1_d
    hr = hr_imd*temp
    qrout_d = hr_imd_d - hr_d
    qrout = hr_imd - hr
  END SUBROUTINE GR_TRANSFER1_D

  SUBROUTINE GR_TRANSFER1(dt, qup, lr, hr, qrout)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt
    REAL(sp), INTENT(IN) :: qup, lr
    REAL(sp), INTENT(INOUT) :: hr
    REAL(sp), INTENT(OUT) :: qrout
    REAL(sp) :: hr_imd
    INTRINSIC EXP
    REAL(sp) :: arg1
    hr_imd = hr + qup
    arg1 = -(dt/(lr*60._sp))
    hr = hr_imd*EXP(arg1)
    qrout = hr_imd - hr
  END SUBROUTINE GR_TRANSFER1

END MODULE MD_OPERATOR_DIFF_D

!  Differentiation of forward in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: cost
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.lr)
!                *(states.hi) *(states.hp) *(states.hft) *(states.hst)
!                *(states.hlr)
!   RW status of diff variables: parameters.ci:(loc) *(parameters.ci):in
!                parameters.cp:(loc) *(parameters.cp):in parameters.beta:(loc)
!                *(parameters.beta):in parameters.cft:(loc) *(parameters.cft):in
!                parameters.cst:(loc) *(parameters.cst):in parameters.alpha:(loc)
!                *(parameters.alpha):in parameters.exc:(loc) *(parameters.exc):in
!                parameters.lr:(loc) *(parameters.lr):in *(output.qsim):(loc)
!                states.hi:(loc) *(states.hi):in-killed states.hp:(loc)
!                *(states.hp):in-killed states.hft:(loc) *(states.hft):in-killed
!                states.hst:(loc) *(states.hst):in-killed states.hlr:(loc)
!                *(states.hlr):in-killed cost:out
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.lr:in
!                output.qsim:in states.hi:in states.hp:in states.hft:in
!                states.hst:in states.hlr:in
SUBROUTINE FORWARD_D(setup, mesh, input_data, parameters, parameters_d, &
& parameters_bgd, states, states_d, states_bgd, output, output_d, cost, &
& cost_d)
!% =================================================================================================================== %!
!%   Module import ('only' is commented because of issues in adjoint model)
!% =================================================================================================================== %!
!% only: sp
  USE MWD_COMMON
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: ParametersDT
  USE MWD_PARAMETERS_DIFF_D
!% only: StatesDT
  USE MWD_STATES_DIFF_D
!% only: OutputDT
  USE MWD_OUTPUT_DIFF_D
!% only: GR_interception, GR_production, GR_exchange, &
  USE MD_OPERATOR_DIFF_D
!% & GR_transferN, upstream_discharge, sparse_upstream_discharge, GR_transfer1
!% only: compute_cost
  USE MWD_COST_DIFF_D
  IMPLICIT NONE
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
  TYPE(SETUPDT), INTENT(IN) :: setup
  TYPE(MESHDT), INTENT(IN) :: mesh
  TYPE(INPUT_DATADT), INTENT(IN) :: input_data
  TYPE(PARAMETERSDT), INTENT(IN) :: parameters, parameters_bgd
  TYPE(PARAMETERSDT), INTENT(IN) :: parameters_d
  TYPE(STATESDT), INTENT(INOUT) :: states, states_bgd
  TYPE(STATESDT), INTENT(INOUT) :: states_d
  TYPE(OUTPUTDT), INTENT(INOUT) :: output
  TYPE(OUTPUTDT_DIFF_D), INTENT(INOUT) :: output_d
  REAL(sp), INTENT(INOUT) :: cost
  REAL(sp), INTENT(INOUT) :: cost_d
!% =================================================================================================================== %!
!%   Local Variables (private)
!===================================================================================================================== %!
  TYPE(STATESDT) :: states_imd
  TYPE(STATESDT) :: states_imd_d
  REAL(sp), DIMENSION(:, :), ALLOCATABLE :: q
  REAL(sp), DIMENSION(:, :), ALLOCATABLE :: q_d
  REAL(sp), DIMENSION(:), ALLOCATABLE :: sparse_q
  REAL(sp), DIMENSION(:), ALLOCATABLE :: sparse_q_d
  REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prl, prd, qd, qr&
& , ql, qt, qup, qrout
  REAL(sp) :: ei_d, pn_d, en_d, pr_d, perc_d, l_d, prr_d, prl_d, prd_d, &
& qd_d, qr_d, ql_d, qt_d, qup_d, qrout_d
  INTEGER :: t, i, row, col, k, g
  INTRINSIC MIN
  INTRINSIC MAX
  INTRINSIC REAL
  REAL(sp) :: temp
  REAL :: temp0
  cost = 0._sp
  states_imd_d = states_d
  states_imd = states
  IF (setup%sparse_storage) THEN
    ALLOCATE(sparse_q_d(mesh%nac))
    ALLOCATE(sparse_q(mesh%nac))
    output_d%qsim = 0.0_4
  ELSE
    ALLOCATE(q_d(mesh%nrow, mesh%ncol))
    ALLOCATE(q(mesh%nrow, mesh%ncol))
    output_d%qsim = 0.0_4
  END IF
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
  DO t=1,setup%ntime_step
!% [ DO SPACE ]
    DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialisation for time step (t) and cell (i)
!% =============================================================================================================== %!
      ei = 0._sp
      pn = 0._sp
      en = 0._sp
      pr = 0._sp
      perc = 0._sp
      l = 0._sp
      prr = 0._sp
      prl = 0._sp
      prd = 0._sp
      qd = 0._sp
      qr = 0._sp
      ql = 0._sp
      qup = 0._sp
      qrout = 0._sp
!% [ END IF PATH ]
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of drained area 
!% =========================================================================================================== %!
      IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
!% [ IF PATH ]
        row = mesh%path(1, i)
        col = mesh%path(2, i)
        IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, col&
&           )
!% [ END IF ACTIVE CELL ]
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
        IF (mesh%active_cell(row, col) .EQ. 1 .AND. mesh%&
&           local_active_cell(row, col) .EQ. 1) THEN
!% [ IF ACTIVE CELL ]
          IF (setup%sparse_storage) THEN
            prcp = input_data%sparse_prcp(k, t)
            pet = input_data%sparse_pet(k, t)
          ELSE
            prcp = input_data%prcp(row, col, t)
            pet = input_data%pet(row, col, t)
          END IF
!% [ END IF PRCP GAP ]
          IF (prcp .GE. 0 .AND. pet .GE. 0) THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module case [ 0 - 1 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%interception_module) 
            CASE (0) 
              IF (pet .GT. prcp) THEN
                ei = prcp
              ELSE
                ei = pet
              END IF
              IF (0._sp .LT. prcp - ei) THEN
                pn = prcp - ei
                ei_d = 0.0_4
                pn_d = 0.0_4
              ELSE
                pn = 0._sp
                ei_d = 0.0_4
                pn_d = 0.0_4
              END IF
            CASE (1) 
              CALL GR_INTERCEPTION_D(prcp, pet, parameters%ci(row, col)&
&                              , parameters_d%ci(row, col), states%hi(&
&                              row, col), states_d%hi(row, col), pn, &
&                              pn_d, ei, ei_d)
            CASE DEFAULT
              ei_d = 0.0_4
              pn_d = 0.0_4
            END SELECT
            en_d = -ei_d
            en = pet - ei
!% =============================================================================================== %!
!%   Production module case [ 0 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%production_module) 
            CASE (0) 
              CALL GR_PRODUCTION_D(pn, pn_d, en, en_d, parameters%cp(row&
&                            , col), parameters_d%cp(row, col), &
&                            parameters%beta(row, col), parameters_d%&
&                            beta(row, col), states%hp(row, col), &
&                            states_d%hp(row, col), pr, pr_d, perc, &
&                            perc_d)
            CASE DEFAULT
              perc_d = 0.0_4
              pr_d = 0.0_4
            END SELECT
!% =============================================================================================== %!
!%   Exchange module case [ 0 - 1 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%exchange_module) 
            CASE (0) 
              l = 0._sp
              l_d = 0.0_4
            CASE (1) 
              CALL GR_EXCHANGE_D(parameters%exc(row, col), parameters_d%&
&                          exc(row, col), states%hft(row, col), states_d&
&                          %hft(row, col), l, l_d)
            CASE DEFAULT
              l_d = 0.0_4
            END SELECT
          ELSE
            l_d = 0.0_4
            perc_d = 0.0_4
            pr_d = 0.0_4
          END IF
!% =================================================================================================== %!
!%   Transfer module case [ 0 ]
!% =================================================================================================== %!
          SELECT CASE  (setup%transfer_module) 
          CASE (0) 
            prr_d = (pr+perc)*parameters_d%alpha(row, col) + parameters%&
&             alpha(row, col)*(pr_d+perc_d) + l_d
            prr = parameters%alpha(row, col)*(pr+perc) + l
            prd_d = (1._sp-parameters%alpha(row, col))*(pr_d+perc_d) - (&
&             pr+perc)*parameters_d%alpha(row, col)
            prd = (1._sp-parameters%alpha(row, col))*(pr+perc)
            CALL GR_TRANSFERN_D(5._sp, prcp, prr, prr_d, parameters%cft(&
&                         row, col), parameters_d%cft(row, col), states%&
&                         hft(row, col), states_d%hft(row, col), qr, &
&                         qr_d)
            IF (0._sp .LT. prd + l) THEN
              qd_d = prd_d + l_d
              qd = prd + l
              ql_d = 0.0_4
            ELSE
              qd = 0._sp
              qd_d = 0.0_4
              ql_d = 0.0_4
            END IF
          CASE (1) 
            prr_d = 0.9_sp*((pr+perc)*parameters_d%alpha(row, col)+&
&             parameters%alpha(row, col)*(pr_d+perc_d)) + l_d
            prr = 0.9_sp*parameters%alpha(row, col)*(pr+perc) + l
            prl_d = 0.9_sp*((1._sp-parameters%alpha(row, col))*(pr_d+&
&             perc_d)-(pr+perc)*parameters_d%alpha(row, col))
            prl = 0.9_sp*(1._sp-parameters%alpha(row, col))*(pr+perc)
            prd_d = 0.1_sp*(pr_d+perc_d)
            prd = 0.1_sp*(pr+perc)
            CALL GR_TRANSFERN_D(5._sp, prcp, prr, prr_d, parameters%cft(&
&                         row, col), parameters_d%cft(row, col), states%&
&                         hft(row, col), states_d%hft(row, col), qr, &
&                         qr_d)
            CALL GR_TRANSFERN_D(5._sp, prcp, prl, prl_d, parameters%cst(&
&                         row, col), parameters_d%cst(row, col), states%&
&                         hst(row, col), states_d%hst(row, col), ql, &
&                         ql_d)
            IF (0._sp .LT. prd + l) THEN
              qd_d = prd_d + l_d
              qd = prd + l
            ELSE
              qd = 0._sp
              qd_d = 0.0_4
            END IF
          CASE DEFAULT
            qd_d = 0.0_4
            ql_d = 0.0_4
            qr_d = 0.0_4
          END SELECT
          qt_d = qd_d + qr_d + ql_d
          qt = qd + qr + ql
!% =================================================================================================== %!
!%   Routing module case [ 0 - 1 ]
!% =================================================================================================== %!
          SELECT CASE  (setup%routing_module) 
          CASE (0) 
            IF (setup%sparse_storage) THEN
              CALL SPARSE_UPSTREAM_DISCHARGE_D(setup%dt, mesh%dx, mesh%&
&                                        nrow, mesh%ncol, mesh%nac, mesh&
&                                        %flwdir, mesh%drained_area, &
&                                        mesh%rowcol_to_ind_sparse, row&
&                                        , col, sparse_q, sparse_q_d, &
&                                        qup, qup_d)
              temp = 0.001_sp*(mesh%dx*mesh%dx)
              temp0 = REAL(mesh%drained_area(row, col) - 1)
              sparse_q_d(k) = temp*(qt_d+temp0*qup_d)/setup%dt
              sparse_q(k) = temp*((qt+temp0*qup)/setup%dt)
            ELSE
              CALL UPSTREAM_DISCHARGE_D(setup%dt, mesh%dx, mesh%nrow, &
&                                 mesh%ncol, mesh%flwdir, mesh%&
&                                 drained_area, row, col, q, q_d, qup, &
&                                 qup_d)
              temp = 0.001_sp*(mesh%dx*mesh%dx)
              temp0 = REAL(mesh%drained_area(row, col) - 1)
              q_d(row, col) = temp*(qt_d+temp0*qup_d)/setup%dt
              q(row, col) = temp*((qt+temp0*qup)/setup%dt)
            END IF
          CASE (1) 
            IF (setup%sparse_storage) THEN
              CALL SPARSE_UPSTREAM_DISCHARGE_D(setup%dt, mesh%dx, mesh%&
&                                        nrow, mesh%ncol, mesh%nac, mesh&
&                                        %flwdir, mesh%drained_area, &
&                                        mesh%rowcol_to_ind_sparse, row&
&                                        , col, sparse_q, sparse_q_d, &
&                                        qup, qup_d)
              CALL GR_TRANSFER1_D(setup%dt, qup, qup_d, parameters%lr(&
&                           row, col), parameters_d%lr(row, col), states&
&                           %hlr(row, col), states_d%hlr(row, col), &
&                           qrout, qrout_d)
              temp = 0.001_sp*(mesh%dx*mesh%dx)
              temp0 = REAL(mesh%drained_area(row, col) - 1)
              sparse_q_d(k) = temp*(qt_d+temp0*qrout_d)/setup%dt
              sparse_q(k) = temp*((qt+temp0*qrout)/setup%dt)
            ELSE
              CALL UPSTREAM_DISCHARGE_D(setup%dt, mesh%dx, mesh%nrow, &
&                                 mesh%ncol, mesh%flwdir, mesh%&
&                                 drained_area, row, col, q, q_d, qup, &
&                                 qup_d)
              CALL GR_TRANSFER1_D(setup%dt, qup, qup_d, parameters%lr(&
&                           row, col), parameters_d%lr(row, col), states&
&                           %hlr(row, col), states_d%hlr(row, col), &
&                           qrout, qrout_d)
              temp = 0.001_sp*(mesh%dx*mesh%dx)
              temp0 = REAL(mesh%drained_area(row, col) - 1)
              q_d(row, col) = temp*(qt_d+temp0*qrout_d)/setup%dt
              q(row, col) = temp*((qt+temp0*qrout)/setup%dt)
            END IF
          END SELECT
        END IF
      END IF
    END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
    DO g=1,mesh%ng
      row = mesh%gauge_pos(g, 1)
      col = mesh%gauge_pos(g, 2)
      IF (setup%sparse_storage) THEN
        k = mesh%rowcol_to_ind_sparse(row, col)
        output_d%qsim(g, t) = sparse_q_d(k)
        output%qsim(g, t) = sparse_q(k)
      ELSE
        output_d%qsim(g, t) = q_d(row, col)
        output%qsim(g, t) = q(row, col)
      END IF
    END DO
!% =============================================================================================================== %!
!%   Store simulated discharge on domain (optional)
!% =============================================================================================================== %!
    IF (setup%save_qsim_domain) THEN
      IF (setup%sparse_storage) THEN
        output%sparse_qsim_domain(:, t) = sparse_q
      ELSE
        output%qsim_domain(:, :, t) = q
      END IF
    END IF
  END DO
!% [ END DO TIME ]
!% =============================================================================================================== %!
!%   Store states at final time step (optional)
!% =============================================================================================================== %!
  output%fstates = states
!% =================================================================================================================== %!
!%   Compute J
!% =================================================================================================================== %!
  CALL COMPUTE_COST_D(setup, mesh, input_data, parameters, parameters_d&
&               , parameters_bgd, states_imd, states_imd_d, states_bgd, &
&               output, output_d, cost, cost_d)
END SUBROUTINE FORWARD_D

SUBROUTINE FORWARD_NODIFF_D(setup, mesh, input_data, parameters, &
& parameters_bgd, states, states_bgd, output, cost)
!% =================================================================================================================== %!
!%   Module import ('only' is commented because of issues in adjoint model)
!% =================================================================================================================== %!
!% only: sp
  USE MWD_COMMON
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: ParametersDT
  USE MWD_PARAMETERS_DIFF_D
!% only: StatesDT
  USE MWD_STATES_DIFF_D
!% only: OutputDT
  USE MWD_OUTPUT_DIFF_D
!% only: GR_interception, GR_production, GR_exchange, &
  USE MD_OPERATOR_DIFF_D
!% & GR_transferN, upstream_discharge, sparse_upstream_discharge, GR_transfer1
!% only: compute_cost
  USE MWD_COST_DIFF_D
  IMPLICIT NONE
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
  TYPE(SETUPDT), INTENT(IN) :: setup
  TYPE(MESHDT), INTENT(IN) :: mesh
  TYPE(INPUT_DATADT), INTENT(IN) :: input_data
  TYPE(PARAMETERSDT), INTENT(IN) :: parameters, parameters_bgd
  TYPE(STATESDT), INTENT(INOUT) :: states, states_bgd
  TYPE(OUTPUTDT), INTENT(INOUT) :: output
  REAL(sp), INTENT(INOUT) :: cost
!% =================================================================================================================== %!
!%   Local Variables (private)
!===================================================================================================================== %!
  TYPE(STATESDT) :: states_imd
  REAL(sp), DIMENSION(:, :), ALLOCATABLE :: q
  REAL(sp), DIMENSION(:), ALLOCATABLE :: sparse_q
  REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prl, prd, qd, qr&
& , ql, qt, qup, qrout
  INTEGER :: t, i, row, col, k, g
  INTRINSIC MIN
  INTRINSIC MAX
  INTRINSIC REAL
  cost = 0._sp
  states_imd = states
  IF (setup%sparse_storage) THEN
    ALLOCATE(sparse_q(mesh%nac))
  ELSE
    ALLOCATE(q(mesh%nrow, mesh%ncol))
  END IF
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
  DO t=1,setup%ntime_step
!% [ DO SPACE ]
    DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialisation for time step (t) and cell (i)
!% =============================================================================================================== %!
      ei = 0._sp
      pn = 0._sp
      en = 0._sp
      pr = 0._sp
      perc = 0._sp
      l = 0._sp
      prr = 0._sp
      prl = 0._sp
      prd = 0._sp
      qd = 0._sp
      qr = 0._sp
      ql = 0._sp
      qup = 0._sp
      qrout = 0._sp
!% [ END IF PATH ]
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of drained area 
!% =========================================================================================================== %!
      IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
!% [ IF PATH ]
        row = mesh%path(1, i)
        col = mesh%path(2, i)
        IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, col&
&           )
!% [ END IF ACTIVE CELL ]
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
        IF (mesh%active_cell(row, col) .EQ. 1 .AND. mesh%&
&           local_active_cell(row, col) .EQ. 1) THEN
!% [ IF ACTIVE CELL ]
          IF (setup%sparse_storage) THEN
            prcp = input_data%sparse_prcp(k, t)
            pet = input_data%sparse_pet(k, t)
          ELSE
            prcp = input_data%prcp(row, col, t)
            pet = input_data%pet(row, col, t)
          END IF
!% [ END IF PRCP GAP ]
          IF (prcp .GE. 0 .AND. pet .GE. 0) THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module case [ 0 - 1 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%interception_module) 
            CASE (0) 
              IF (pet .GT. prcp) THEN
                ei = prcp
              ELSE
                ei = pet
              END IF
              IF (0._sp .LT. prcp - ei) THEN
                pn = prcp - ei
              ELSE
                pn = 0._sp
              END IF
            CASE (1) 
              CALL GR_INTERCEPTION(prcp, pet, parameters%ci(row, col), &
&                            states%hi(row, col), pn, ei)
            END SELECT
            en = pet - ei
!% =============================================================================================== %!
!%   Production module case [ 0 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%production_module) 
            CASE (0) 
              CALL GR_PRODUCTION(pn, en, parameters%cp(row, col), &
&                          parameters%beta(row, col), states%hp(row, col&
&                          ), pr, perc)
            END SELECT
!% =============================================================================================== %!
!%   Exchange module case [ 0 - 1 ]
!% =============================================================================================== %!
            SELECT CASE  (setup%exchange_module) 
            CASE (0) 
              l = 0._sp
            CASE (1) 
              CALL GR_EXCHANGE(parameters%exc(row, col), states%hft(row&
&                        , col), l)
            END SELECT
          END IF
!% =================================================================================================== %!
!%   Transfer module case [ 0 ]
!% =================================================================================================== %!
          SELECT CASE  (setup%transfer_module) 
          CASE (0) 
            prr = parameters%alpha(row, col)*(pr+perc) + l
            prd = (1._sp-parameters%alpha(row, col))*(pr+perc)
            CALL GR_TRANSFERN(5._sp, prcp, prr, parameters%cft(row, col)&
&                       , states%hft(row, col), qr)
            IF (0._sp .LT. prd + l) THEN
              qd = prd + l
            ELSE
              qd = 0._sp
            END IF
          CASE (1) 
            prr = 0.9_sp*parameters%alpha(row, col)*(pr+perc) + l
            prl = 0.9_sp*(1._sp-parameters%alpha(row, col))*(pr+perc)
            prd = 0.1_sp*(pr+perc)
            CALL GR_TRANSFERN(5._sp, prcp, prr, parameters%cft(row, col)&
&                       , states%hft(row, col), qr)
            CALL GR_TRANSFERN(5._sp, prcp, prl, parameters%cst(row, col)&
&                       , states%hst(row, col), ql)
            IF (0._sp .LT. prd + l) THEN
              qd = prd + l
            ELSE
              qd = 0._sp
            END IF
          END SELECT
          qt = qd + qr + ql
!% =================================================================================================== %!
!%   Routing module case [ 0 - 1 ]
!% =================================================================================================== %!
          SELECT CASE  (setup%routing_module) 
          CASE (0) 
            IF (setup%sparse_storage) THEN
              CALL SPARSE_UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%&
&                                      nrow, mesh%ncol, mesh%nac, mesh%&
&                                      flwdir, mesh%drained_area, mesh%&
&                                      rowcol_to_ind_sparse, row, col, &
&                                      sparse_q, qup)
              sparse_q(k) = (qt+qup*REAL(mesh%drained_area(row, col)-1))&
&               *mesh%dx*mesh%dx*0.001_sp/setup%dt
            ELSE
              CALL UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%nrow, mesh&
&                               %ncol, mesh%flwdir, mesh%drained_area, &
&                               row, col, q, qup)
              q(row, col) = (qt+qup*REAL(mesh%drained_area(row, col)-1))&
&               *mesh%dx*mesh%dx*0.001_sp/setup%dt
            END IF
          CASE (1) 
            IF (setup%sparse_storage) THEN
              CALL SPARSE_UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%&
&                                      nrow, mesh%ncol, mesh%nac, mesh%&
&                                      flwdir, mesh%drained_area, mesh%&
&                                      rowcol_to_ind_sparse, row, col, &
&                                      sparse_q, qup)
              CALL GR_TRANSFER1(setup%dt, qup, parameters%lr(row, col), &
&                         states%hlr(row, col), qrout)
              sparse_q(k) = (qt+qrout*REAL(mesh%drained_area(row, col)-1&
&               ))*mesh%dx*mesh%dx*0.001_sp/setup%dt
            ELSE
              CALL UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%nrow, mesh&
&                               %ncol, mesh%flwdir, mesh%drained_area, &
&                               row, col, q, qup)
              CALL GR_TRANSFER1(setup%dt, qup, parameters%lr(row, col), &
&                         states%hlr(row, col), qrout)
              q(row, col) = (qt+qrout*REAL(mesh%drained_area(row, col)-1&
&               ))*mesh%dx*mesh%dx*0.001_sp/setup%dt
            END IF
          END SELECT
        END IF
      END IF
    END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
    DO g=1,mesh%ng
      row = mesh%gauge_pos(g, 1)
      col = mesh%gauge_pos(g, 2)
      IF (setup%sparse_storage) THEN
        k = mesh%rowcol_to_ind_sparse(row, col)
        output%qsim(g, t) = sparse_q(k)
      ELSE
        output%qsim(g, t) = q(row, col)
      END IF
    END DO
!% =============================================================================================================== %!
!%   Store simulated discharge on domain (optional)
!% =============================================================================================================== %!
    IF (setup%save_qsim_domain) THEN
      IF (setup%sparse_storage) THEN
        output%sparse_qsim_domain(:, t) = sparse_q
      ELSE
        output%qsim_domain(:, :, t) = q
      END IF
    END IF
  END DO
!% [ END DO TIME ]
!% =============================================================================================================== %!
!%   Store states at final time step (optional)
!% =============================================================================================================== %!
  output%fstates = states
!% =================================================================================================================== %!
!%   Compute J
!% =================================================================================================================== %!
  CALL COMPUTE_COST(setup, mesh, input_data, parameters, parameters_bgd&
&             , states_imd, states_bgd, output, cost)
END SUBROUTINE FORWARD_NODIFF_D

