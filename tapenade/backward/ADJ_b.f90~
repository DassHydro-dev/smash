!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!%    This module (wrap) `mw_output` encapsulates all SMASH output
MODULE MW_OUTPUT_DIFF
  USE M_COMMON, ONLY : sp, dp, lchar, np, ns
  USE MW_SETUP, ONLY : setupdt
  USE MW_MESH, ONLY : meshdt
  IMPLICIT NONE
  PUBLIC :: outputdt
!%      OutputDT type:
!%
!%      ====================    ==========================================================
!%      `args`                  Description
!%      ====================    ==========================================================
!%      ====================    ==========================================================
  TYPE OUTPUTDT
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: qsim
      REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: qsim_grid
      REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: gradient_parameters
      REAL(sp) :: cost
  END TYPE OUTPUTDT
  TYPE OUTPUTDT_DIFF
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: qsim
  END TYPE OUTPUTDT_DIFF

CONTAINS
  SUBROUTINE OUTPUTDT_INITIALISE(output, setup, mesh)
    IMPLICIT NONE
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(SETUPDT), INTENT(INOUT) :: setup
    TYPE(MESHDT), INTENT(INOUT) :: mesh
    ALLOCATE(output%qsim(mesh%ng, setup%ntime_step))
    output%qsim = -99._sp
    IF (.NOT.setup%active_cell_only) THEN
      ALLOCATE(output%qsim_grid(mesh%nrow, mesh%ncol, setup%ntime_step))
      output%qsim_grid = -99._sp
    END IF
    IF (.NOT.setup%simulation_only) THEN
      ALLOCATE(output%gradient_parameters(mesh%nrow, mesh%ncol, np))
      output%gradient_parameters = 0._sp
    END IF
  END SUBROUTINE OUTPUTDT_INITIALISE

END MODULE MW_OUTPUT_DIFF

!%    This module `mw_cost` encapsulates all SMASH cost (type, subroutines, functions)
MODULE MW_COST_DIFF
  USE M_COMMON, ONLY : sp, dp, lchar, np, ns
  USE MW_SETUP, ONLY : setupdt
  USE MW_MESH, ONLY : meshdt
  USE MW_INPUT_DATA, ONLY : input_datadt
  USE MW_OUTPUT_DIFF, ONLY : outputdt, outputdt_diff
  IMPLICIT NONE

CONTAINS
  SUBROUTINE COMPUTE_JOBS(setup, mesh, input_data, output, jobs)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    REAL(sp), INTENT(OUT) :: jobs
    REAL(sp), DIMENSION(setup%ntime_step-setup%optim_start_step+1) :: qo&
&   , qs
    INTEGER :: g, row_g, col_g
    INTRINSIC REAL
    INTRINSIC ANY
    REAL(sp) :: result1
    jobs = 0._sp
    DO g=1,mesh%ng
      qs = output%qsim(g, setup%optim_start_step:setup%ntime_step)*setup&
&       %dt*0.001_sp/mesh%area(g)
      row_g = mesh%gauge_pos(1, g)
      col_g = mesh%gauge_pos(2, g)
      qo = input_data%qobs(g, setup%optim_start_step:setup%ntime_step)*&
&       setup%dt*0.001_sp/(REAL(mesh%drained_area(row_g, col_g))*(setup%&
&       dx/1000._sp)*(setup%dx/1000._sp))
      IF (ANY(qo .GE. 0._sp)) THEN
        result1 = NSE(qo, qs)
        jobs = jobs + result1
      END IF
    END DO
  END SUBROUTINE COMPUTE_JOBS

!~         subroutine compute_jreg
!~         end subroutine compute_jreg
  FUNCTION NSE(x, y) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp) :: res
    REAL(sp) :: sum_x, sum_xx, sum_yy, sum_xy, mean_x, num, den
    INTEGER :: i, n
    INTRINSIC SIZE
!% Metric computation
    n = 0
    sum_x = 0.
    sum_xx = 0.
    sum_yy = 0.
    sum_xy = 0.
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0.) THEN
        n = n + 1
        sum_x = sum_x + x(i)
        sum_xx = sum_xx + x(i)*x(i)
        sum_yy = sum_yy + y(i)*y(i)
        sum_xy = sum_xy + x(i)*y(i)
      END IF
    END DO
    mean_x = sum_x/n
!% NSE numerator / denominator
    num = sum_xx - 2*sum_xy + sum_yy
    den = sum_xx - n*mean_x*mean_x
!% NSE criterion
    res = num/den
  END FUNCTION NSE

END MODULE MW_COST_DIFF

!%    This module `mw_states` encapsulates all SMASH states
MODULE MW_STATES_DIFF
  USE M_COMMON, ONLY : sp, dp, lchar, np, ns
  USE MW_SETUP, ONLY : setupdt
  USE MW_MESH, ONLY : meshdt
  IMPLICIT NONE
  PUBLIC :: statesdt, states_derived_type_to_matrix, &
& matrix_to_states_derived_type, vector_to_states_derived_type
  TYPE STATESDT
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hi
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hp
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hft
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hst
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hr
  END TYPE STATESDT

CONTAINS
  SUBROUTINE STATESDT_INITIALISE(states, setup, mesh)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(STATESDT), INTENT(INOUT) :: states
    INTEGER :: nrow, ncol
    nrow = mesh%nrow
    ncol = mesh%ncol
    ALLOCATE(states%hi(nrow, ncol))
    ALLOCATE(states%hp(nrow, ncol))
    ALLOCATE(states%hft(nrow, ncol))
    ALLOCATE(states%hst(nrow, ncol))
    ALLOCATE(states%hr(nrow, ncol))
    CALL VECTOR_TO_STATES_DERIVED_TYPE(setup%default_states, states)
  END SUBROUTINE STATESDT_INITIALISE

  SUBROUTINE STATES_DERIVED_TYPE_TO_MATRIX(states, matrix)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(IN) :: states
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(states%hp, 1), SIZE(states%hp, 2), ns), &
&   INTENT(INOUT) :: matrix
    matrix(:, :, 1) = states%hi(:, :)
    matrix(:, :, 2) = states%hp(:, :)
    matrix(:, :, 3) = states%hft(:, :)
    matrix(:, :, 4) = states%hst(:, :)
    matrix(:, :, 5) = states%hr(:, :)
  END SUBROUTINE STATES_DERIVED_TYPE_TO_MATRIX

  SUBROUTINE MATRIX_TO_STATES_DERIVED_TYPE(matrix, states)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(INOUT) :: states
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(states%hp, 1), SIZE(states%hp, 2), ns), &
&   INTENT(IN) :: matrix
    states%hi(:, :) = matrix(:, :, 1)
    states%hp(:, :) = matrix(:, :, 2)
    states%hft(:, :) = matrix(:, :, 3)
    states%hst(:, :) = matrix(:, :, 4)
    states%hr(:, :) = matrix(:, :, 5)
  END SUBROUTINE MATRIX_TO_STATES_DERIVED_TYPE

  SUBROUTINE VECTOR_TO_STATES_DERIVED_TYPE(vector, states)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(INOUT) :: states
    REAL(sp), DIMENSION(ns), INTENT(IN) :: vector
    states%hi = vector(1)
    states%hp = vector(2)
    states%hft = vector(3)
    states%hst = vector(4)
    states%hr = vector(5)
  END SUBROUTINE VECTOR_TO_STATES_DERIVED_TYPE

END MODULE MW_STATES_DIFF

!%    This module (wrap) `mw_parameters` encapsulates all SMASH parameters
MODULE MW_PARAMETERS_DIFF
  USE M_COMMON, ONLY : sp, dp, lchar, np, ns
  USE MW_SETUP, ONLY : setupdt
  USE MW_MESH, ONLY : meshdt
  IMPLICIT NONE
  PUBLIC :: parametersdt, parameters_derived_type_to_matrix, &
& matrix_to_parameters_derived_type, vector_to_parameters_derived_type
  TYPE PARAMETERSDT
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: ci
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cp
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: beta
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cft
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cst
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: alpha
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: exc
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: lr
  END TYPE PARAMETERSDT

CONTAINS
  SUBROUTINE PARAMETERSDT_INITIALISE(parameters, setup, mesh)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    INTEGER :: nrow, ncol
    nrow = mesh%nrow
    ncol = mesh%ncol
    ALLOCATE(parameters%ci(nrow, ncol))
    ALLOCATE(parameters%cp(nrow, ncol))
    ALLOCATE(parameters%beta(nrow, ncol))
    ALLOCATE(parameters%cft(nrow, ncol))
    ALLOCATE(parameters%cst(nrow, ncol))
    ALLOCATE(parameters%alpha(nrow, ncol))
    ALLOCATE(parameters%exc(nrow, ncol))
    ALLOCATE(parameters%lr(nrow, ncol))
    CALL VECTOR_TO_PARAMETERS_DERIVED_TYPE(setup%default_parameters, &
&                                    parameters)
  END SUBROUTINE PARAMETERSDT_INITIALISE

  SUBROUTINE PARAMETERS_DERIVED_TYPE_TO_MATRIX(parameters, matrix)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(parameters%cp, 1), SIZE(parameters%cp, 2), &
&   np), INTENT(INOUT) :: matrix
    matrix(:, :, 1) = parameters%ci(:, :)
    matrix(:, :, 2) = parameters%cp(:, :)
    matrix(:, :, 3) = parameters%beta(:, :)
    matrix(:, :, 4) = parameters%cft(:, :)
    matrix(:, :, 5) = parameters%cst(:, :)
    matrix(:, :, 6) = parameters%alpha(:, :)
    matrix(:, :, 7) = parameters%exc(:, :)
    matrix(:, :, 8) = parameters%lr(:, :)
  END SUBROUTINE PARAMETERS_DERIVED_TYPE_TO_MATRIX

  SUBROUTINE MATRIX_TO_PARAMETERS_DERIVED_TYPE(matrix, parameters)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(parameters%cp, 1), SIZE(parameters%cp, 2), &
&   np), INTENT(IN) :: matrix
    parameters%ci(:, :) = matrix(:, :, 1)
    parameters%cp(:, :) = matrix(:, :, 2)
    parameters%beta(:, :) = matrix(:, :, 3)
    parameters%cft(:, :) = matrix(:, :, 4)
    parameters%cst(:, :) = matrix(:, :, 5)
    parameters%alpha(:, :) = matrix(:, :, 6)
    parameters%exc(:, :) = matrix(:, :, 7)
    parameters%lr(:, :) = matrix(:, :, 8)
  END SUBROUTINE MATRIX_TO_PARAMETERS_DERIVED_TYPE

  SUBROUTINE VECTOR_TO_PARAMETERS_DERIVED_TYPE(vector, parameters)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    REAL(sp), DIMENSION(np), INTENT(IN) :: vector
    parameters%ci = vector(1)
    parameters%cp = vector(2)
    parameters%beta = vector(3)
    parameters%cft = vector(4)
    parameters%cst = vector(5)
    parameters%alpha = vector(6)
    parameters%exc = vector(7)
    parameters%lr = vector(8)
  END SUBROUTINE VECTOR_TO_PARAMETERS_DERIVED_TYPE

END MODULE MW_PARAMETERS_DIFF

!%    This module (wrap) `mw_run` encapsulates all SMASH run (type, subroutines, functions)
MODULE MW_RUN_DIFF
  USE M_COMMON, ONLY : sp, dp, lchar, np, np
  USE MW_SETUP, ONLY : setupdt
  USE MW_MESH, ONLY : meshdt
  USE MW_INPUT_DATA, ONLY : input_datadt
  USE MW_PARAMETERS_DIFF, ONLY : parametersdt, parametersdt_diff
  USE MW_STATES_DIFF, ONLY : statesdt, statesdt_diff
  USE MW_OUTPUT_DIFF, ONLY : outputdt, outputdt_diff
  USE M_OPERATOR, ONLY : gr_interception, gr_production, gr_exchange, &
& gr_transfern, upstream_discharge, sparse_upstream_discharge
  USE MW_COST_DIFF, ONLY : compute_jobs
  IMPLICIT NONE
!~         subroutine adjoint_model(a)
!~         end subroutine adjoint_model
!~         subroutine tangent_linear_model()
!~         end subroutine tangent_linear_model

CONTAINS
!  Differentiation of direct_model in reverse (adjoint) mode (with options OpenMP context fixinterface):
!   with respect to varying inputs: cost
!   RW status of diff variables: parameters.ci:(loc) *(parameters.ci):(loc)
!                parameters.cp:(loc) *(parameters.cp):(loc) parameters.beta:(loc)
!                *(parameters.beta):(loc) parameters.cft:(loc)
!                *(parameters.cft):(loc) parameters.cst:(loc) *(parameters.cst):(loc)
!                parameters.alpha:(loc) *(parameters.alpha):(loc)
!                parameters.exc:(loc) *(parameters.exc):(loc) parameters.lr:(loc)
!                *(parameters.lr):(loc) states.hi:(loc) *(states.hi):(loc)
!                states.hp:(loc) *(states.hp):(loc) states.hft:(loc)
!                *(states.hft):(loc) states.hst:(loc) *(states.hst):(loc)
!                states.hr:(loc) *(states.hr):(loc) cost:zero
!   Plus diff mem management of: output.qsim:in
  SUBROUTINE DIRECT_MODEL_B(setup, mesh, input_data, parameters, &
&   parametersb, states, statesb, output, outputb, cost, costb)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(PARAMETERSDT) :: parametersb
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(STATESDT), INTENT(INOUT) :: statesb
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: outputb
    REAL(sp) :: cost
    REAL(sp) :: costb
!~             integer, external :: omp_get_max_threads
    INTEGER :: t, i, row, col, k, g, row_g, col_g, k_g
    REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prd, qd, qr, ql&
&   , qt, qup
    REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: q
    REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: qb
    REAL(sp), DIMENSION(:, :), ALLOCATABLE :: sparse_q
    REAL(sp), DIMENSION(:, :), ALLOCATABLE :: sparse_qb
    INTRINSIC MIN
    INTRINSIC MAX
    INTRINSIC REAL
    IF (setup%sparse_storage) THEN
      ALLOCATE(sparse_qb(mesh%nac, setup%ntime_step))
      sparse_qb = 0.0_4
      ALLOCATE(sparse_q(mesh%nac, setup%ntime_step))
      DEALLOCATE(sparse_q)
      DEALLOCATE(sparse_qb)
    ELSE
      ALLOCATE(qb(mesh%nrow, mesh%ncol, setup%ntime_step))
      qb = 0.0_4
      ALLOCATE(q(mesh%nrow, mesh%ncol, setup%ntime_step))
      DEALLOCATE(q)
      DEALLOCATE(qb)
    END IF
    costb = 0.0_4
  END SUBROUTINE DIRECT_MODEL_B

  SUBROUTINE DIRECT_MODEL(setup, mesh, input_data, parameters, states, &
&   output, cost)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    REAL(sp), INTENT(OUT) :: cost
!~             integer, external :: omp_get_max_threads
    INTEGER :: t, i, row, col, k, g, row_g, col_g, k_g
    REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prd, qd, qr, ql&
&   , qt, qup
    REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: q
    REAL(sp), DIMENSION(:, :), ALLOCATABLE :: sparse_q
    INTRINSIC MIN
    INTRINSIC MAX
    INTRINSIC REAL
    IF (setup%sparse_storage) THEN
      ALLOCATE(sparse_q(mesh%nac, setup%ntime_step))
    ELSE
      ALLOCATE(q(mesh%nrow, mesh%ncol, setup%ntime_step))
    END IF
    cost = 0._sp
    DO t=1,setup%ntime_step
      DO i=1,mesh%nrow*mesh%ncol
        ei = 0._sp
        pn = 0._sp
        en = 0._sp
        pr = 0._sp
        perc = 0._sp
        l = 0._sp
        prr = 0._sp
        prd = 0._sp
        qd = 0._sp
        qr = 0._sp
        ql = 0._sp
        qup = 0._sp
!% {end if: path}
        IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
          row = mesh%path(1, i)
          col = mesh%path(2, i)
          IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, &
&             col)
!% {end if: global active cell}
          IF (mesh%global_active_cell(row, col) .EQ. 1 .AND. mesh%&
&             local_active_cell(row, col) .EQ. 1) THEN
            IF (setup%sparse_storage) THEN
              prcp = input_data%sparse_prcp(k, t)
              pet = input_data%sparse_pet(k, t)
            ELSE
              prcp = input_data%prcp(row, col, t)
              pet = input_data%pet(row, col, t)
            END IF
!% {end if: prcp ge 0}
            IF (prcp .GE. 0) THEN
!% -------------------------------- Interception module case
              SELECT CASE  (setup%interception_module) 
              CASE (0) 
                IF (pet .GT. prcp) THEN
                  ei = prcp
                ELSE
                  ei = pet
                END IF
                IF (0._sp .LT. prcp - ei) THEN
                  pn = prcp - ei
                ELSE
                  pn = 0._sp
                END IF
              CASE (1) 
                CALL GR_INTERCEPTION(prcp, pet, parameters%ci(row, col)&
&                              , states%hi(row, col), pn, ei)
              END SELECT
              en = pet - ei
              SELECT CASE  (setup%production_module) 
              CASE (0) 
!% -------------------------------- Production module case
                CALL GR_PRODUCTION(pn, en, parameters%cp(row, col), &
&                            parameters%beta(row, col), states%hp(row, &
&                            col), pr, perc)
              END SELECT
!% -------------------------------- Exchange module case
              SELECT CASE  (setup%exchange_module) 
              CASE (0) 
                l = 0._sp
              CASE (1) 
                CALL GR_EXCHANGE(parameters%exc(row, col), states%hft(&
&                          row, col), l)
              END SELECT
            END IF
!% ---------------------------- Transfer module case
            SELECT CASE  (setup%transfer_module) 
            CASE (0) 
              prr = parameters%alpha(row, col)*(pr+perc) + l
              prd = pr + perc - prr
              CALL GR_TRANSFERN(5._sp, prcp, prr, parameters%cft(row, &
&                         col), states%hft(row, col), qr)
              IF (0._sp .LT. prd + l) THEN
                qd = prd + l
              ELSE
                qd = 0._sp
              END IF
            END SELECT
            qt = qd + qr + ql
!% ------------------------ Routing module case
            SELECT CASE  (setup%routing_module) 
            CASE (0) 
              IF (setup%sparse_storage) THEN
                CALL SPARSE_UPSTREAM_DISCHARGE(setup%dt, setup%dx, setup&
&                                        %ntime_step, mesh%nrow, mesh%&
&                                        ncol, mesh%nac, mesh%flow, mesh&
&                                        %drained_area, mesh%&
&                                        rowcol_to_ind_sparse, row, col&
&                                        , t, sparse_q, qup)
                sparse_q(k, t) = (qt+qup*REAL(mesh%drained_area(row, col&
&                 )-1))*setup%dx*setup%dx*0.001_sp/setup%dt
              ELSE
                CALL UPSTREAM_DISCHARGE(setup%dt, setup%dx, setup%&
&                                 ntime_step, mesh%nrow, mesh%ncol, mesh&
&                                 %flow, mesh%drained_area, row, col, t&
&                                 , q, qup)
                q(row, col, t) = (qt+qup*REAL(mesh%drained_area(row, col&
&                 )-1))*setup%dx*setup%dx*0.001_sp/setup%dt
              END IF
            END SELECT
          END IF
        END IF
      END DO
    END DO
!% {end do: space}
!% {end do: time}
    DO g=1,mesh%ng
      row_g = mesh%gauge_pos(1, g)
      col_g = mesh%gauge_pos(2, g)
      IF (setup%sparse_storage) THEN
        k_g = mesh%rowcol_to_ind_sparse(row_g, col_g)
        output%qsim(g, :) = sparse_q(k_g, :)
      ELSE
        output%qsim(g, :) = q(row_g, col_g, :)
      END IF
    END DO
    CALL COMPUTE_JOBS(setup, mesh, input_data, output, cost)
  END SUBROUTINE DIRECT_MODEL

END MODULE MW_RUN_DIFF

