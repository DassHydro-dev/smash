!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!%    This module (wrap) `mw_output` encapsulates all SMASH output
MODULE MW_OUTPUT_DIFF
  USE M_COMMON, ONLY : sp, dp, lchar, np, ns
  USE MW_SETUP, ONLY : setupdt
  USE MW_MESH, ONLY : meshdt
  IMPLICIT NONE
  PUBLIC :: outputdt
!%      OutputDT type:
!%
!%      ====================    ==========================================================
!%      `args`                  Description
!%      ====================    ==========================================================
!%      ====================    ==========================================================
  TYPE OUTPUTDT
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: qsim
      REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: qsim_grid
      REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: gradient_parameters
      REAL(sp) :: cost
  END TYPE OUTPUTDT
  TYPE OUTPUTDT_DIFF
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: qsim
  END TYPE OUTPUTDT_DIFF

CONTAINS
  SUBROUTINE OUTPUTDT_INITIALISE(output, setup, mesh)
    IMPLICIT NONE
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(SETUPDT), INTENT(INOUT) :: setup
    TYPE(MESHDT), INTENT(INOUT) :: mesh
    ALLOCATE(output%qsim(mesh%ng, setup%ntime_step))
    output%qsim = -99._sp
    IF (.NOT.setup%active_cell_only) THEN
      ALLOCATE(output%qsim_grid(mesh%nrow, mesh%ncol, setup%ntime_step))
      output%qsim_grid = -99._sp
    END IF
    IF (.NOT.setup%simulation_only) THEN
      ALLOCATE(output%gradient_parameters(mesh%nrow, mesh%ncol, np))
      output%gradient_parameters = 0._sp
    END IF
  END SUBROUTINE OUTPUTDT_INITIALISE

END MODULE MW_OUTPUT_DIFF

!%    This module `mw_cost` encapsulates all SMASH cost (type, subroutines, functions)
MODULE MW_COST_DIFF
  USE M_COMMON, ONLY : sp, dp, lchar, np, ns
  USE MW_SETUP, ONLY : setupdt
  USE MW_MESH, ONLY : meshdt
  USE MW_INPUT_DATA, ONLY : input_datadt
  USE MW_OUTPUT_DIFF, ONLY : outputdt, outputdt_diff
  IMPLICIT NONE

CONTAINS
!  Differentiation of compute_jobs in reverse (adjoint) mode (with options OpenMP context fixinterface):
!   gradient     of useful results: jobs
!   with respect to varying inputs: *(output.qsim)
!   Plus diff mem management of: output.qsim:in
  SUBROUTINE COMPUTE_JOBS_B(setup, mesh, input_data, output, outputb, &
&   jobs, jobsb)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: outputb
    REAL(sp) :: jobs
    REAL(sp) :: jobsb
    REAL(sp), DIMENSION(setup%ntime_step-setup%optim_start_step+1) :: qo&
&   , qs
    REAL(sp), DIMENSION(setup%ntime_step-setup%optim_start_step+1) :: &
&   qsb
    INTEGER :: g, row_g, col_g
    INTRINSIC REAL
    INTRINSIC ANY
    REAL(sp) :: result1
    REAL(sp) :: result1b
    INTEGER :: branch
    DO g=1,mesh%ng
      qs = output%qsim(g, setup%optim_start_step:setup%ntime_step)*setup&
&       %dt*0.001_sp/mesh%area(g)
      row_g = mesh%gauge_pos(1, g)
      col_g = mesh%gauge_pos(2, g)
      CALL PUSHREAL4ARRAY(qo, setup%ntime_step - setup%optim_start_step &
&                   + 1)
      qo = input_data%qobs(g, setup%optim_start_step:setup%ntime_step)*&
&       setup%dt*0.001_sp/(REAL(mesh%drained_area(row_g, col_g))*(setup%&
&       dx/1000._sp)*(setup%dx/1000._sp))
      IF (ANY(qo .GE. 0._sp)) THEN
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    outputb%qsim = 0.0_4
    DO g=mesh%ng,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        qsb = 0.0_4
      ELSE
        result1b = jobsb
        qs = output%qsim(g, setup%optim_start_step:setup%ntime_step)*&
&         setup%dt*0.001_sp/mesh%area(g)
        CALL NSE_B(qo, qs, qsb, result1b)
      END IF
      CALL POPREAL4ARRAY(qo, setup%ntime_step - setup%optim_start_step +&
&                  1)
      outputb%qsim(g, setup%optim_start_step:setup%ntime_step) = outputb&
&       %qsim(g, setup%optim_start_step:setup%ntime_step) + setup%dt*&
&       0.001_sp*qsb/mesh%area(g)
    END DO
  END SUBROUTINE COMPUTE_JOBS_B

  SUBROUTINE COMPUTE_JOBS(setup, mesh, input_data, output, jobs)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    REAL(sp), INTENT(OUT) :: jobs
    REAL(sp), DIMENSION(setup%ntime_step-setup%optim_start_step+1) :: qo&
&   , qs
    INTEGER :: g, row_g, col_g
    INTRINSIC REAL
    INTRINSIC ANY
    REAL(sp) :: result1
    jobs = 0._sp
    DO g=1,mesh%ng
      qs = output%qsim(g, setup%optim_start_step:setup%ntime_step)*setup&
&       %dt*0.001_sp/mesh%area(g)
      row_g = mesh%gauge_pos(1, g)
      col_g = mesh%gauge_pos(2, g)
      qo = input_data%qobs(g, setup%optim_start_step:setup%ntime_step)*&
&       setup%dt*0.001_sp/(REAL(mesh%drained_area(row_g, col_g))*(setup%&
&       dx/1000._sp)*(setup%dx/1000._sp))
      IF (ANY(qo .GE. 0._sp)) THEN
        result1 = NSE(qo, qs)
        jobs = jobs + result1
      END IF
    END DO
  END SUBROUTINE COMPUTE_JOBS

!  Differentiation of nse in reverse (adjoint) mode (with options OpenMP context fixinterface):
!   gradient     of useful results: res
!   with respect to varying inputs: y
!~         subroutine compute_jreg
!~         end subroutine compute_jreg
  SUBROUTINE NSE_B(x, y, yb, resb)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:) :: yb
    REAL(sp) :: res
    REAL(sp) :: resb
    REAL(sp) :: sum_x, sum_xx, sum_yy, sum_xy, mean_x, num, den
    REAL(sp) :: sum_yyb, sum_xyb, numb
    INTEGER :: i, n
    INTRINSIC SIZE
    INTEGER :: ad_to
    INTEGER :: branch
!% Metric computation
    n = 0
    sum_x = 0.
    sum_xx = 0.
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0.) THEN
        n = n + 1
        sum_x = sum_x + x(i)
        sum_xx = sum_xx + x(i)*x(i)
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    CALL PUSHINTEGER4(i - 1)
    mean_x = sum_x/n
!% NSE numerator / denominator
    den = sum_xx - n*mean_x*mean_x
!% NSE criterion
    numb = resb/den
    sum_yyb = numb
    sum_xyb = -(2*numb)
    yb = 0.0_4
    CALL POPINTEGER4(ad_to)
    DO i=ad_to,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) yb(i) = yb(i) + x(i)*sum_xyb + 2*y(i)*sum_yyb
    END DO
  END SUBROUTINE NSE_B

!~         subroutine compute_jreg
!~         end subroutine compute_jreg
  FUNCTION NSE(x, y) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp) :: res
    REAL(sp) :: sum_x, sum_xx, sum_yy, sum_xy, mean_x, num, den
    INTEGER :: i, n
    INTRINSIC SIZE
!% Metric computation
    n = 0
    sum_x = 0.
    sum_xx = 0.
    sum_yy = 0.
    sum_xy = 0.
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0.) THEN
        n = n + 1
        sum_x = sum_x + x(i)
        sum_xx = sum_xx + x(i)*x(i)
        sum_yy = sum_yy + y(i)*y(i)
        sum_xy = sum_xy + x(i)*y(i)
      END IF
    END DO
    mean_x = sum_x/n
!% NSE numerator / denominator
    num = sum_xx - 2*sum_xy + sum_yy
    den = sum_xx - n*mean_x*mean_x
!% NSE criterion
    res = num/den
  END FUNCTION NSE

END MODULE MW_COST_DIFF

!%    This module `m_operator` encapsulates all SMASH operator (type, subroutines, functions)
MODULE M_OPERATOR_DIFF
  USE M_COMMON, ONLY : sp, dp, lchar, np, ns
  IMPLICIT NONE

CONTAINS
!  Differentiation of gr_interception in reverse (adjoint) mode (with options OpenMP context fixinterface):
!   gradient     of useful results: hi ei ci pn
!   with respect to varying inputs: hi ci
  ELEMENTAL SUBROUTINE GR_INTERCEPTION_B(prcp, pet, ci, cib, hi, hib, pn&
&   , pnb, ei, eib)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: prcp, pet, ci
    REAL(sp), INTENT(OUT) :: cib
    REAL(sp), INTENT(INOUT) :: hi
    REAL(sp), INTENT(INOUT) :: hib
    REAL(sp), INTENT(OUT) :: pn, ei
    REAL(sp) :: pnb, eib
    INTRINSIC MIN
    INTRINSIC MAX
    REAL(sp) :: tempb
    INTEGER :: branch
    IF (pet .GT. prcp + hi*ci) THEN
      ei = prcp + hi*ci
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      ei = pet
    END IF
    IF (0._sp .LT. prcp - ci*(1._sp-hi) - ei) THEN
      pn = prcp - ci*(1._sp-hi) - ei
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      pn = 0._sp
    END IF
    tempb = hib/ci
    eib = eib - tempb
    pnb = pnb - tempb
    cib = cib - (prcp-ei-pn)*tempb/ci
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      cib = cib - (1._sp-hi)*pnb
      hib = hib + ci*pnb
      eib = eib - pnb
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      hib = hib + ci*eib
      cib = cib + hi*eib
    END IF
  END SUBROUTINE GR_INTERCEPTION_B

  ELEMENTAL SUBROUTINE GR_INTERCEPTION(prcp, pet, ci, hi, pn, ei)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: prcp, pet, ci
    REAL(sp), INTENT(INOUT) :: hi
    REAL(sp), INTENT(OUT) :: pn, ei
    INTRINSIC MIN
    INTRINSIC MAX
    IF (pet .GT. prcp + hi*ci) THEN
      ei = prcp + hi*ci
    ELSE
      ei = pet
    END IF
    IF (0._sp .LT. prcp - ci*(1._sp-hi) - ei) THEN
      pn = prcp - ci*(1._sp-hi) - ei
    ELSE
      pn = 0._sp
    END IF
    hi = hi + (prcp-ei-pn)/ci
  END SUBROUTINE GR_INTERCEPTION

!  Differentiation of gr_production in reverse (adjoint) mode (with options OpenMP context fixinterface):
!   gradient     of useful results: hp beta cp perc pr
!   with respect to varying inputs: hp en beta cp pn
  ELEMENTAL SUBROUTINE GR_PRODUCTION_B(pn, pnb, en, enb, cp, cpb, beta, &
&   betab, hp, hpb, pr, prb, perc, percb)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: pn, en, cp, beta
    REAL(sp) :: pnb, enb, cpb, betab
    REAL(sp), INTENT(INOUT) :: hp
    REAL(sp), INTENT(INOUT) :: hpb
    REAL(sp), INTENT(OUT) :: pr, perc
    REAL(sp) :: prb, percb
    REAL(sp) :: inv_cp, ps, es, hp_imd
    REAL(sp) :: inv_cpb, psb, esb, hp_imdb
    INTRINSIC TANH
    REAL(sp) :: temp
    REAL(sp) :: temp0
    REAL(sp) :: tempb
    REAL(sp) :: temp1
    REAL(sp) :: temp2
    REAL(sp) :: temp3
    REAL(sp) :: tempb0
    REAL(sp) :: tempb1
    REAL(sp) :: temp4
    REAL(sp) :: tempb2
    REAL(sp) :: tempb3
    REAL(sp) :: tempb4
    REAL(sp) :: temp5
    REAL(sp) :: tempb5
    INTEGER :: branch
    inv_cp = 1._sp/cp
    ps = cp*(1._sp-hp*hp)*TANH(pn*inv_cp)/(1._sp+hp*TANH(pn*inv_cp))
    es = hp*cp*(2._sp-hp)*TANH(en*inv_cp)/(1._sp+(1._sp-hp)*TANH(en*&
&     inv_cp))
    hp_imd = hp + (ps-es)*inv_cp
    IF (pn .GT. 0) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    perc = hp_imd*cp*(1._sp-(1._sp+(hp_imd/beta)**4)**(-0.25_sp))
    percb = percb - inv_cp*hpb
    temp5 = hp_imd/beta
    temp4 = temp5**4 + 1._sp
    tempb0 = (1._sp-temp4**(-0.25_sp))*percb
    tempb5 = 4*temp5**3*0.25_sp*temp4**(-1.25)*hp_imd*cp*percb/beta
    hp_imdb = hpb + tempb5 + cp*tempb0
    inv_cpb = -(perc*hpb)
    betab = betab - temp5*tempb5
    cpb = cpb + hp_imd*tempb0
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      pnb = prb
      hp_imdb = hp_imdb - cp*prb
      hpb = cp*prb
      cpb = cpb - (hp_imd-hp)*prb
    ELSE
      hpb = 0.0_4
      pnb = 0.0_4
    END IF
    esb = -(inv_cp*hp_imdb)
    temp4 = TANH(en*inv_cp)
    temp3 = (-hp+1._sp)*temp4 + 1._sp
    temp1 = TANH(en*inv_cp)
    temp0 = hp*cp*(-hp+2._sp)
    tempb3 = esb/temp3
    tempb = (2._sp-hp)*temp1*tempb3
    tempb0 = -(temp0*temp1*tempb3/temp3)
    hpb = hpb + hp_imdb + cp*tempb - hp*cp*temp1*tempb3 - temp4*tempb0
    psb = inv_cp*hp_imdb
    tempb4 = (1.0-TANH(en*inv_cp)**2)*temp0*tempb3
    tempb5 = (1.0-TANH(en*inv_cp)**2)*(1._sp-hp)*tempb0
    enb = inv_cp*tempb5 + inv_cp*tempb4
    cpb = cpb + hp*tempb
    temp = TANH(pn*inv_cp)
    temp0 = hp*temp + 1._sp
    temp1 = TANH(pn*inv_cp)
    temp2 = cp*(-(hp*hp)+1._sp)
    tempb = psb/temp0
    tempb0 = (1.0-TANH(pn*inv_cp)**2)*temp2*tempb
    tempb1 = -(temp2*temp1*tempb/temp0)
    hpb = hpb + temp*tempb1 - 2*hp*cp*temp1*tempb
    tempb2 = (1.0-TANH(pn*inv_cp)**2)*hp*tempb1
    inv_cpb = inv_cpb + (ps-es)*hp_imdb + en*tempb5 + en*tempb4 + pn*&
&     tempb2 + pn*tempb0
    cpb = cpb + (1._sp-hp**2)*temp1*tempb - inv_cpb/cp**2
    pnb = pnb + inv_cp*tempb2 + inv_cp*tempb0
  END SUBROUTINE GR_PRODUCTION_B

  ELEMENTAL SUBROUTINE GR_PRODUCTION(pn, en, cp, beta, hp, pr, perc)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: pn, en, cp, beta
    REAL(sp), INTENT(INOUT) :: hp
    REAL(sp), INTENT(OUT) :: pr, perc
    REAL(sp) :: inv_cp, ps, es, hp_imd
    INTRINSIC TANH
    inv_cp = 1._sp/cp
    pr = 0._sp
    ps = cp*(1._sp-hp*hp)*TANH(pn*inv_cp)/(1._sp+hp*TANH(pn*inv_cp))
    es = hp*cp*(2._sp-hp)*TANH(en*inv_cp)/(1._sp+(1._sp-hp)*TANH(en*&
&     inv_cp))
    hp_imd = hp + (ps-es)*inv_cp
    IF (pn .GT. 0) pr = pn - (hp_imd-hp)*cp
    perc = hp_imd*cp*(1._sp-(1._sp+(hp_imd/beta)**4)**(-0.25_sp))
    hp = hp_imd - perc*inv_cp
  END SUBROUTINE GR_PRODUCTION

!  Differentiation of gr_exchange in reverse (adjoint) mode (with options OpenMP context fixinterface):
!   gradient     of useful results: l hft exc
!   with respect to varying inputs: hft exc
  ELEMENTAL SUBROUTINE GR_EXCHANGE_B(exc, excb, hft, hftb, l, lb)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: exc
    REAL(sp), INTENT(OUT) :: excb
    REAL(sp), INTENT(INOUT) :: hft
    REAL(sp), INTENT(INOUT) :: hftb
    REAL(sp), INTENT(OUT) :: l
    REAL(sp), INTENT(IN) :: lb
    excb = excb + hft**3.5_sp*lb
    hftb = hftb + 3.5_sp*hft**2.5*exc*lb
  END SUBROUTINE GR_EXCHANGE_B

  ELEMENTAL SUBROUTINE GR_EXCHANGE(exc, hft, l)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: exc
    REAL(sp), INTENT(INOUT) :: hft
    REAL(sp), INTENT(OUT) :: l
    l = exc*hft**3.5_sp
  END SUBROUTINE GR_EXCHANGE

!  Differentiation of gr_transfern in reverse (adjoint) mode (with options OpenMP context fixinterface):
!   gradient     of useful results: q ht ct
!   with respect to varying inputs: ht ct pr
  ELEMENTAL SUBROUTINE GR_TRANSFERN_B(n, prcp, pr, prb, ct, ctb, ht, htb&
&   , q, qb)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: n, prcp, pr, ct
    REAL(sp) :: prb, ctb
    REAL(sp), INTENT(INOUT) :: ht
    REAL(sp), INTENT(INOUT) :: htb
    REAL(sp), INTENT(OUT) :: q
    REAL(sp), INTENT(IN) :: qb
    REAL(sp) :: pr_imd, ht_imd, nm1, d1pnm1
    REAL(sp) :: pr_imdb, ht_imdb
    INTRINSIC MAX
    REAL(sp) :: tempb
    REAL(sp) :: temp
    REAL(sp) :: tempb0
    INTEGER :: branch
    nm1 = n - 1._sp
    d1pnm1 = 1._sp/nm1
    IF (prcp .LT. 0._sp) THEN
      pr_imd = ((ht*ct)**(-nm1)-ct**(-nm1))**(-d1pnm1) - ht*ct
      CALL PUSHCONTROL1B(1)
    ELSE
      pr_imd = pr
      CALL PUSHCONTROL1B(0)
    END IF
    IF (1.e-6_sp .LT. ht + pr_imd/ct) THEN
      ht_imd = ht + pr_imd/ct
      CALL PUSHCONTROL1B(0)
    ELSE
      ht_imd = 1.e-6_sp
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL4(ht)
    ht = ((ht_imd*ct)**(-nm1)+ct**(-nm1))**(-d1pnm1)/ct
    htb = htb - ct*qb
    temp = (ht_imd*ct)**(-nm1) + ct**(-nm1)
    IF (temp .LE. 0.0 .AND. (-d1pnm1 .EQ. 0.0 .OR. -d1pnm1 .NE. INT(-&
&       d1pnm1))) THEN
      tempb0 = 0.0_4
    ELSE
      tempb0 = -(d1pnm1*temp**((-1)-d1pnm1)*htb/ct)
    END IF
    IF (ht_imd*ct .LE. 0.0 .AND. (-nm1 .EQ. 0.0 .OR. -nm1 .NE. INT(-nm1)&
&       )) THEN
      tempb = 0.0_4
    ELSE
      tempb = -(nm1*(ht_imd*ct)**((-1)-nm1)*tempb0)
    END IF
    ht_imdb = ct*qb + ct*tempb
    IF (ct .LE. 0.0 .AND. (-nm1 .EQ. 0.0 .OR. -nm1 .NE. INT(-nm1))) THEN
      ctb = ctb + (ht_imd-ht)*qb + ht_imd*tempb - temp**(-d1pnm1)*htb/ct&
&       **2
    ELSE
      ctb = ctb + (ht_imd-ht)*qb + ht_imd*tempb - temp**(-d1pnm1)*htb/ct&
&       **2 - nm1*ct**((-1)-nm1)*tempb0
    END IF
    CALL POPREAL4(ht)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      htb = ht_imdb
      pr_imdb = ht_imdb/ct
      ctb = ctb - pr_imd*ht_imdb/ct**2
    ELSE
      htb = 0.0_4
      pr_imdb = 0.0_4
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      prb = pr_imdb
    ELSE
      IF ((ht*ct)**(-nm1) - ct**(-nm1) .LE. 0.0 .AND. (-d1pnm1 .EQ. 0.0 &
&         .OR. -d1pnm1 .NE. INT(-d1pnm1))) THEN
        tempb = 0.0_4
      ELSE
        tempb = -(d1pnm1*((ht*ct)**(-nm1)-ct**(-nm1))**((-1)-d1pnm1)*&
&         pr_imdb)
      END IF
      IF (ht*ct .LE. 0.0 .AND. (-nm1 .EQ. 0.0 .OR. -nm1 .NE. INT(-nm1))&
&     ) THEN
        tempb0 = 0.0_4
      ELSE
        tempb0 = -(nm1*(ht*ct)**((-1)-nm1)*tempb)
      END IF
      htb = htb + ct*tempb0 - ct*pr_imdb
      IF (ct .LE. 0.0 .AND. (-nm1 .EQ. 0.0 .OR. -nm1 .NE. INT(-nm1))) &
&     THEN
        ctb = ctb + ht*tempb0 - ht*pr_imdb
      ELSE
        ctb = ctb + nm1*ct**((-1)-nm1)*tempb - ht*pr_imdb + ht*tempb0
      END IF
      prb = 0.0_4
    END IF
  END SUBROUTINE GR_TRANSFERN_B

  ELEMENTAL SUBROUTINE GR_TRANSFERN(n, prcp, pr, ct, ht, q)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: n, prcp, pr, ct
    REAL(sp), INTENT(INOUT) :: ht
    REAL(sp), INTENT(OUT) :: q
    REAL(sp) :: pr_imd, ht_imd, nm1, d1pnm1
    INTRINSIC MAX
    nm1 = n - 1._sp
    d1pnm1 = 1._sp/nm1
    IF (prcp .LT. 0._sp) THEN
      pr_imd = ((ht*ct)**(-nm1)-ct**(-nm1))**(-d1pnm1) - ht*ct
    ELSE
      pr_imd = pr
    END IF
    IF (1.e-6_sp .LT. ht + pr_imd/ct) THEN
      ht_imd = ht + pr_imd/ct
    ELSE
      ht_imd = 1.e-6_sp
    END IF
    ht = ((ht_imd*ct)**(-nm1)+ct**(-nm1))**(-d1pnm1)/ct
    q = (ht_imd-ht)*ct
  END SUBROUTINE GR_TRANSFERN

!  Differentiation of upstream_discharge in reverse (adjoint) mode (with options OpenMP context fixinterface):
!   gradient     of useful results: q qup
!   with respect to varying inputs: q
  SUBROUTINE UPSTREAM_DISCHARGE_B(dt, dx, ntime_step, nrow, ncol, flow, &
&   drained_area, row, col, t, q, qb, qup, qupb)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt, dx
    INTEGER, INTENT(IN) :: ntime_step, nrow, ncol, row, col, t
    INTEGER, DIMENSION(nrow, ncol), INTENT(IN) :: flow, drained_area
    REAL(sp), DIMENSION(nrow, ncol, ntime_step), INTENT(IN) :: q
    REAL(sp), DIMENSION(nrow, ncol, ntime_step) :: qb
    REAL(sp) :: qup
    REAL(sp) :: qupb
    INTEGER :: i, row_imd, col_imd
    INTEGER, DIMENSION(8), SAVE :: dcol=(/0, -1, -1, -1, 0, 1, 1, 1/)
    INTEGER, DIMENSION(8), SAVE :: drow=(/1, 1, 0, -1, -1, -1, 0, 1/)
    INTEGER, DIMENSION(8), SAVE :: dkind=(/1, 2, 3, 4, 5, 6, 7, 8/)
    INTRINSIC REAL
    INTEGER :: branch
    IF (drained_area(row, col) .GT. 1) THEN
      DO i=1,8
        col_imd = col + dcol(i)
        row_imd = row + drow(i)
        IF (col_imd .GT. 0 .AND. col_imd .LE. ncol .AND. row_imd .GT. 0 &
&           .AND. row_imd .LE. nrow) THEN
          IF (flow(row_imd, col_imd) .EQ. dkind(i)) THEN
            CALL PUSHCONTROL2B(2)
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(0)
        END IF
      END DO
      qupb = dt*qupb/(0.001_sp*dx**2*REAL(drained_area(row, col)-1))
      DO i=8,1,-1
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .NE. 1) THEN
            row_imd = row + drow(i)
            col_imd = col + dcol(i)
            qb(row_imd, col_imd, t) = qb(row_imd, col_imd, t) + qupb
          END IF
        END IF
      END DO
    END IF
  END SUBROUTINE UPSTREAM_DISCHARGE_B

  SUBROUTINE UPSTREAM_DISCHARGE(dt, dx, ntime_step, nrow, ncol, flow, &
&   drained_area, row, col, t, q, qup)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt, dx
    INTEGER, INTENT(IN) :: ntime_step, nrow, ncol, row, col, t
    INTEGER, DIMENSION(nrow, ncol), INTENT(IN) :: flow, drained_area
    REAL(sp), DIMENSION(nrow, ncol, ntime_step), INTENT(IN) :: q
    REAL(sp), INTENT(OUT) :: qup
    INTEGER :: i, row_imd, col_imd
    INTEGER, DIMENSION(8), SAVE :: dcol=(/0, -1, -1, -1, 0, 1, 1, 1/)
    INTEGER, DIMENSION(8), SAVE :: drow=(/1, 1, 0, -1, -1, -1, 0, 1/)
    INTEGER, DIMENSION(8), SAVE :: dkind=(/1, 2, 3, 4, 5, 6, 7, 8/)
    INTRINSIC REAL
    qup = 0._sp
    IF (drained_area(row, col) .GT. 1) THEN
      DO i=1,8
        col_imd = col + dcol(i)
        row_imd = row + drow(i)
        IF (col_imd .GT. 0 .AND. col_imd .LE. ncol .AND. row_imd .GT. 0 &
&           .AND. row_imd .LE. nrow) THEN
          IF (flow(row_imd, col_imd) .EQ. dkind(i)) qup = qup + q(&
&             row_imd, col_imd, t)
        END IF
      END DO
      qup = qup*dt/(0.001_sp*dx*dx*REAL(drained_area(row, col)-1))
    END IF
  END SUBROUTINE UPSTREAM_DISCHARGE

!  Differentiation of sparse_upstream_discharge in reverse (adjoint) mode (with options OpenMP context fixinterface):
!   gradient     of useful results: q qup
!   with respect to varying inputs: q
  SUBROUTINE SPARSE_UPSTREAM_DISCHARGE_B(dt, dx, ntime_step, nrow, ncol&
&   , nac, flow, drained_area, ind_sparse, row, col, t, q, qb, qup, qupb&
& )
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt, dx
    INTEGER, INTENT(IN) :: ntime_step, nrow, ncol, nac, row, col, t
    INTEGER, DIMENSION(nrow, ncol), INTENT(IN) :: flow, drained_area, &
&   ind_sparse
    REAL(sp), DIMENSION(nac, ntime_step), INTENT(IN) :: q
    REAL(sp), DIMENSION(nac, ntime_step) :: qb
    REAL(sp) :: qup
    REAL(sp) :: qupb
    INTEGER :: i, row_imd, col_imd, k
    INTEGER, DIMENSION(8), SAVE :: dcol=(/0, -1, -1, -1, 0, 1, 1, 1/)
    INTEGER, DIMENSION(8), SAVE :: drow=(/1, 1, 0, -1, -1, -1, 0, 1/)
    INTEGER, DIMENSION(8), SAVE :: dkind=(/1, 2, 3, 4, 5, 6, 7, 8/)
    INTRINSIC REAL
    INTEGER :: branch
    IF (drained_area(row, col) .GT. 1) THEN
      DO i=1,8
        col_imd = col + dcol(i)
        row_imd = row + drow(i)
        IF (col_imd .GT. 0 .AND. col_imd .LE. ncol .AND. row_imd .GT. 0 &
&           .AND. row_imd .LE. nrow) THEN
          IF (flow(row_imd, col_imd) .EQ. dkind(i)) THEN
            CALL PUSHCONTROL2B(2)
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(0)
        END IF
      END DO
      qupb = dt*qupb/(0.001_sp*dx**2*REAL(drained_area(row, col)-1))
      DO i=8,1,-1
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .NE. 1) THEN
            row_imd = row + drow(i)
            col_imd = col + dcol(i)
            k = ind_sparse(row_imd, col_imd)
            qb(k, t) = qb(k, t) + qupb
          END IF
        END IF
      END DO
    END IF
  END SUBROUTINE SPARSE_UPSTREAM_DISCHARGE_B

  SUBROUTINE SPARSE_UPSTREAM_DISCHARGE(dt, dx, ntime_step, nrow, ncol, &
&   nac, flow, drained_area, ind_sparse, row, col, t, q, qup)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt, dx
    INTEGER, INTENT(IN) :: ntime_step, nrow, ncol, nac, row, col, t
    INTEGER, DIMENSION(nrow, ncol), INTENT(IN) :: flow, drained_area, &
&   ind_sparse
    REAL(sp), DIMENSION(nac, ntime_step), INTENT(IN) :: q
    REAL(sp), INTENT(OUT) :: qup
    INTEGER :: i, row_imd, col_imd, k
    INTEGER, DIMENSION(8), SAVE :: dcol=(/0, -1, -1, -1, 0, 1, 1, 1/)
    INTEGER, DIMENSION(8), SAVE :: drow=(/1, 1, 0, -1, -1, -1, 0, 1/)
    INTEGER, DIMENSION(8), SAVE :: dkind=(/1, 2, 3, 4, 5, 6, 7, 8/)
    INTRINSIC REAL
    qup = 0._sp
    IF (drained_area(row, col) .GT. 1) THEN
      DO i=1,8
        col_imd = col + dcol(i)
        row_imd = row + drow(i)
        IF (col_imd .GT. 0 .AND. col_imd .LE. ncol .AND. row_imd .GT. 0 &
&           .AND. row_imd .LE. nrow) THEN
          IF (flow(row_imd, col_imd) .EQ. dkind(i)) THEN
            k = ind_sparse(row_imd, col_imd)
            qup = qup + q(k, t)
          END IF
        END IF
      END DO
      qup = qup*dt/(0.001_sp*dx*dx*REAL(drained_area(row, col)-1))
    END IF
  END SUBROUTINE SPARSE_UPSTREAM_DISCHARGE

END MODULE M_OPERATOR_DIFF

!%    This module `mw_states` encapsulates all SMASH states
MODULE MW_STATES_DIFF
  USE M_COMMON, ONLY : sp, dp, lchar, np, ns
  USE MW_SETUP, ONLY : setupdt
  USE MW_MESH, ONLY : meshdt
  IMPLICIT NONE
  PUBLIC :: statesdt, states_derived_type_to_matrix, &
& matrix_to_states_derived_type, vector_to_states_derived_type
  TYPE STATESDT
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hi
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hp
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hft
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hst
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hr
  END TYPE STATESDT

CONTAINS
  SUBROUTINE STATESDT_INITIALISE(states, setup, mesh)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(STATESDT), INTENT(INOUT) :: states
    INTEGER :: nrow, ncol
    nrow = mesh%nrow
    ncol = mesh%ncol
    ALLOCATE(states%hi(nrow, ncol))
    ALLOCATE(states%hp(nrow, ncol))
    ALLOCATE(states%hft(nrow, ncol))
    ALLOCATE(states%hst(nrow, ncol))
    ALLOCATE(states%hr(nrow, ncol))
    CALL VECTOR_TO_STATES_DERIVED_TYPE(setup%default_states, states)
  END SUBROUTINE STATESDT_INITIALISE

  SUBROUTINE STATES_DERIVED_TYPE_TO_MATRIX(states, matrix)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(IN) :: states
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(states%hp, 1), SIZE(states%hp, 2), ns), &
&   INTENT(INOUT) :: matrix
    matrix(:, :, 1) = states%hi(:, :)
    matrix(:, :, 2) = states%hp(:, :)
    matrix(:, :, 3) = states%hft(:, :)
    matrix(:, :, 4) = states%hst(:, :)
    matrix(:, :, 5) = states%hr(:, :)
  END SUBROUTINE STATES_DERIVED_TYPE_TO_MATRIX

  SUBROUTINE MATRIX_TO_STATES_DERIVED_TYPE(matrix, states)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(INOUT) :: states
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(states%hp, 1), SIZE(states%hp, 2), ns), &
&   INTENT(IN) :: matrix
    states%hi(:, :) = matrix(:, :, 1)
    states%hp(:, :) = matrix(:, :, 2)
    states%hft(:, :) = matrix(:, :, 3)
    states%hst(:, :) = matrix(:, :, 4)
    states%hr(:, :) = matrix(:, :, 5)
  END SUBROUTINE MATRIX_TO_STATES_DERIVED_TYPE

  SUBROUTINE VECTOR_TO_STATES_DERIVED_TYPE(vector, states)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(INOUT) :: states
    REAL(sp), DIMENSION(ns), INTENT(IN) :: vector
    states%hi = vector(1)
    states%hp = vector(2)
    states%hft = vector(3)
    states%hst = vector(4)
    states%hr = vector(5)
  END SUBROUTINE VECTOR_TO_STATES_DERIVED_TYPE

END MODULE MW_STATES_DIFF

!%    This module (wrap) `mw_parameters` encapsulates all SMASH parameters
MODULE MW_PARAMETERS_DIFF
  USE M_COMMON, ONLY : sp, dp, lchar, np, ns
  USE MW_SETUP, ONLY : setupdt
  USE MW_MESH, ONLY : meshdt
  IMPLICIT NONE
  PUBLIC :: parametersdt, parameters_derived_type_to_matrix, &
& matrix_to_parameters_derived_type, vector_to_parameters_derived_type
  TYPE PARAMETERSDT
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: ci
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cp
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: beta
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cft
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cst
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: alpha
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: exc
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: lr
  END TYPE PARAMETERSDT

CONTAINS
  SUBROUTINE PARAMETERSDT_INITIALISE(parameters, setup, mesh)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    INTEGER :: nrow, ncol
    nrow = mesh%nrow
    ncol = mesh%ncol
    ALLOCATE(parameters%ci(nrow, ncol))
    ALLOCATE(parameters%cp(nrow, ncol))
    ALLOCATE(parameters%beta(nrow, ncol))
    ALLOCATE(parameters%cft(nrow, ncol))
    ALLOCATE(parameters%cst(nrow, ncol))
    ALLOCATE(parameters%alpha(nrow, ncol))
    ALLOCATE(parameters%exc(nrow, ncol))
    ALLOCATE(parameters%lr(nrow, ncol))
    CALL VECTOR_TO_PARAMETERS_DERIVED_TYPE(setup%default_parameters, &
&                                    parameters)
  END SUBROUTINE PARAMETERSDT_INITIALISE

  SUBROUTINE PARAMETERS_DERIVED_TYPE_TO_MATRIX(parameters, matrix)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(parameters%cp, 1), SIZE(parameters%cp, 2), &
&   np), INTENT(INOUT) :: matrix
    matrix(:, :, 1) = parameters%ci(:, :)
    matrix(:, :, 2) = parameters%cp(:, :)
    matrix(:, :, 3) = parameters%beta(:, :)
    matrix(:, :, 4) = parameters%cft(:, :)
    matrix(:, :, 5) = parameters%cst(:, :)
    matrix(:, :, 6) = parameters%alpha(:, :)
    matrix(:, :, 7) = parameters%exc(:, :)
    matrix(:, :, 8) = parameters%lr(:, :)
  END SUBROUTINE PARAMETERS_DERIVED_TYPE_TO_MATRIX

  SUBROUTINE MATRIX_TO_PARAMETERS_DERIVED_TYPE(matrix, parameters)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(parameters%cp, 1), SIZE(parameters%cp, 2), &
&   np), INTENT(IN) :: matrix
    parameters%ci(:, :) = matrix(:, :, 1)
    parameters%cp(:, :) = matrix(:, :, 2)
    parameters%beta(:, :) = matrix(:, :, 3)
    parameters%cft(:, :) = matrix(:, :, 4)
    parameters%cst(:, :) = matrix(:, :, 5)
    parameters%alpha(:, :) = matrix(:, :, 6)
    parameters%exc(:, :) = matrix(:, :, 7)
    parameters%lr(:, :) = matrix(:, :, 8)
  END SUBROUTINE MATRIX_TO_PARAMETERS_DERIVED_TYPE

  SUBROUTINE VECTOR_TO_PARAMETERS_DERIVED_TYPE(vector, parameters)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    REAL(sp), DIMENSION(np), INTENT(IN) :: vector
    parameters%ci = vector(1)
    parameters%cp = vector(2)
    parameters%beta = vector(3)
    parameters%cft = vector(4)
    parameters%cst = vector(5)
    parameters%alpha = vector(6)
    parameters%exc = vector(7)
    parameters%lr = vector(8)
  END SUBROUTINE VECTOR_TO_PARAMETERS_DERIVED_TYPE

END MODULE MW_PARAMETERS_DIFF

!%    This module (wrap) `mw_run` encapsulates all SMASH run (type, subroutines, functions)
MODULE MW_RUN_DIFF
  USE M_COMMON, ONLY : sp, dp, lchar, np, np
  USE MW_SETUP, ONLY : setupdt
  USE MW_MESH, ONLY : meshdt
  USE MW_INPUT_DATA, ONLY : input_datadt
  USE MW_PARAMETERS_DIFF, ONLY : parametersdt, parametersdt_diff
  USE MW_STATES_DIFF, ONLY : statesdt, statesdt_diff
  USE MW_OUTPUT_DIFF, ONLY : outputdt, outputdt_diff
  USE M_OPERATOR_DIFF, ONLY : gr_interception, gr_interception_b, &
& gr_production, gr_production_b, gr_exchange, gr_exchange_b, &
& gr_transfern, gr_transfern_b, upstream_discharge, upstream_discharge_b&
& , sparse_upstream_discharge, sparse_upstream_discharge_b
  USE MW_COST_DIFF, ONLY : compute_jobs, compute_jobs_b
  IMPLICIT NONE
!~         subroutine adjoint_model(a)
!~         end subroutine adjoint_model
!~         subroutine tangent_linear_model()
!~         end subroutine tangent_linear_model

CONTAINS
!  Differentiation of direct_model in reverse (adjoint) mode (with options OpenMP context fixinterface):
!   gradient     of useful results: cost
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.alpha)
!                *(parameters.exc) *(states.hi) *(states.hp) *(states.hft)
!                cost
!   RW status of diff variables: parameters.ci:(loc) *(parameters.ci):out
!                parameters.cp:(loc) *(parameters.cp):out parameters.beta:(loc)
!                *(parameters.beta):out parameters.cft:(loc) *(parameters.cft):out
!                parameters.cst:(loc) *(parameters.cst):(loc) parameters.alpha:(loc)
!                *(parameters.alpha):out parameters.exc:(loc) *(parameters.exc):out
!                parameters.lr:(loc) *(parameters.lr):(loc) *(output.qsim):(loc)
!                states.hi:(loc) *(states.hi):out states.hp:(loc)
!                *(states.hp):out states.hft:(loc) *(states.hft):out
!                states.hst:(loc) *(states.hst):(loc) states.hr:(loc)
!                *(states.hr):(loc) cost:in-zero
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.alpha:in
!                parameters.exc:in output.qsim:in states.hi:in
!                states.hp:in states.hft:in
  SUBROUTINE DIRECT_MODEL_B(setup, mesh, input_data, parameters, &
&   parametersb, states, statesb, output, outputb, cost, costb)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(PARAMETERSDT) :: parametersb
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(STATESDT), INTENT(INOUT) :: statesb
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: outputb
    REAL(sp) :: cost
    REAL(sp) :: costb
!~             integer, external :: omp_get_max_threads
    INTEGER :: t, i, row, col, k, g, row_g, col_g, k_g
    REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prd, qd, qr, ql&
&   , qt, qup
    REAL(sp) :: eib, pnb, enb, prb, percb, lb, prrb, prdb, qdb, qrb, qtb&
&   , qupb
    REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: q
    REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: qb
    REAL(sp), DIMENSION(:, :), ALLOCATABLE :: sparse_q
    REAL(sp), DIMENSION(:, :), ALLOCATABLE :: sparse_qb
    INTRINSIC MIN
    INTRINSIC MAX
    INTRINSIC REAL
    REAL(sp) :: tempb
    REAL*4 :: tempb0
    INTEGER :: branch
    IF (setup%sparse_storage) THEN
      ALLOCATE(sparse_qb(mesh%nac, setup%ntime_step))
      sparse_qb = 0.0_4
      ALLOCATE(sparse_q(mesh%nac, setup%ntime_step))
      CALL PUSHCONTROL1B(0)
    ELSE
      ALLOCATE(qb(mesh%nrow, mesh%ncol, setup%ntime_step))
      qb = 0.0_4
      ALLOCATE(q(mesh%nrow, mesh%ncol, setup%ntime_step))
      CALL PUSHCONTROL1B(1)
    END IF
    DO t=1,setup%ntime_step
      DO i=1,mesh%nrow*mesh%ncol
        ei = 0._sp
        CALL PUSHREAL4(pn)
        pn = 0._sp
        CALL PUSHREAL4(pr)
        pr = 0._sp
        CALL PUSHREAL4(perc)
        perc = 0._sp
        l = 0._sp
        qd = 0._sp
        qr = 0._sp
        ql = 0._sp
!% {end if: path}
        IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
          CALL PUSHINTEGER4(row)
          row = mesh%path(1, i)
          CALL PUSHINTEGER4(col)
          col = mesh%path(2, i)
          IF (setup%sparse_storage) THEN
            CALL PUSHINTEGER4(k)
            k = mesh%rowcol_to_ind_sparse(row, col)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
!% {end if: global active cell}
          IF (mesh%global_active_cell(row, col) .EQ. 1 .AND. mesh%&
&             local_active_cell(row, col) .EQ. 1) THEN
            IF (setup%sparse_storage) THEN
              CALL PUSHREAL4(prcp)
              prcp = input_data%sparse_prcp(k, t)
              CALL PUSHREAL4(pet)
              pet = input_data%sparse_pet(k, t)
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREAL4(prcp)
              prcp = input_data%prcp(row, col, t)
              CALL PUSHREAL4(pet)
              pet = input_data%pet(row, col, t)
              CALL PUSHCONTROL1B(1)
            END IF
!% {end if: prcp ge 0}
            IF (prcp .GE. 0) THEN
!% -------------------------------- Interception module case
              SELECT CASE  (setup%interception_module) 
              CASE (0) 
                IF (pet .GT. prcp) THEN
                  ei = prcp
                ELSE
                  ei = pet
                END IF
                IF (0._sp .LT. prcp - ei) THEN
                  CALL PUSHCONTROL2B(2)
                  pn = prcp - ei
                ELSE
                  CALL PUSHCONTROL2B(2)
                  pn = 0._sp
                END IF
              CASE (1) 
                CALL PUSHREAL4(states%hi(row, col))
                CALL GR_INTERCEPTION(prcp, pet, parameters%ci(row, col)&
&                              , states%hi(row, col), pn, ei)
                CALL PUSHCONTROL2B(1)
              CASE DEFAULT
                CALL PUSHCONTROL2B(0)
              END SELECT
              CALL PUSHREAL4(en)
              en = pet - ei
              SELECT CASE  (setup%production_module) 
              CASE (0) 
!% -------------------------------- Production module case
                CALL PUSHREAL4(states%hp(row, col))
                CALL GR_PRODUCTION(pn, en, parameters%cp(row, col), &
&                            parameters%beta(row, col), states%hp(row, &
&                            col), pr, perc)
                CALL PUSHCONTROL1B(1)
              CASE DEFAULT
                CALL PUSHCONTROL1B(0)
              END SELECT
!% -------------------------------- Exchange module case
              SELECT CASE  (setup%exchange_module) 
              CASE (0) 
                CALL PUSHCONTROL2B(0)
                l = 0._sp
              CASE (1) 
                CALL GR_EXCHANGE(parameters%exc(row, col), states%hft(&
&                          row, col), l)
                CALL PUSHCONTROL2B(1)
              CASE DEFAULT
                CALL PUSHCONTROL2B(0)
              END SELECT
            ELSE
              CALL PUSHCONTROL2B(2)
            END IF
!% ---------------------------- Transfer module case
            SELECT CASE  (setup%transfer_module) 
            CASE (0) 
              CALL PUSHREAL4(prr)
              prr = parameters%alpha(row, col)*(pr+perc) + l
              prd = pr + perc - prr
              CALL PUSHREAL4(states%hft(row, col))
              CALL GR_TRANSFERN(5._sp, prcp, prr, parameters%cft(row, &
&                         col), states%hft(row, col), qr)
              IF (0._sp .LT. prd + l) THEN
                qd = prd + l
                CALL PUSHCONTROL2B(2)
              ELSE
                qd = 0._sp
                CALL PUSHCONTROL2B(1)
              END IF
            CASE DEFAULT
              CALL PUSHCONTROL2B(0)
            END SELECT
            qt = qd + qr + ql
!% ------------------------ Routing module case
            SELECT CASE  (setup%routing_module) 
            CASE (0) 
              IF (setup%sparse_storage) THEN
                CALL SPARSE_UPSTREAM_DISCHARGE(setup%dt, setup%dx, setup&
&                                        %ntime_step, mesh%nrow, mesh%&
&                                        ncol, mesh%nac, mesh%flow, mesh&
&                                        %drained_area, mesh%&
&                                        rowcol_to_ind_sparse, row, col&
&                                        , t, sparse_q, qup)
                sparse_q(k, t) = (qt+qup*REAL(mesh%drained_area(row, col&
&                 )-1))*setup%dx*setup%dx*0.001_sp/setup%dt
                CALL PUSHCONTROL3B(3)
              ELSE
                CALL UPSTREAM_DISCHARGE(setup%dt, setup%dx, setup%&
&                                 ntime_step, mesh%nrow, mesh%ncol, mesh&
&                                 %flow, mesh%drained_area, row, col, t&
&                                 , q, qup)
                q(row, col, t) = (qt+qup*REAL(mesh%drained_area(row, col&
&                 )-1))*setup%dx*setup%dx*0.001_sp/setup%dt
                CALL PUSHCONTROL3B(2)
              END IF
            CASE DEFAULT
              CALL PUSHCONTROL3B(4)
            END SELECT
          ELSE
            CALL PUSHCONTROL3B(1)
          END IF
        ELSE
          CALL PUSHCONTROL3B(0)
        END IF
      END DO
    END DO
!% {end do: space}
!% {end do: time}
    DO g=1,mesh%ng
      row_g = mesh%gauge_pos(1, g)
      col_g = mesh%gauge_pos(2, g)
      IF (setup%sparse_storage) THEN
        k_g = mesh%rowcol_to_ind_sparse(row_g, col_g)
        output%qsim(g, :) = sparse_q(k_g, :)
        CALL PUSHCONTROL1B(1)
      ELSE
        output%qsim(g, :) = q(row_g, col_g, :)
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    CALL COMPUTE_JOBS_B(setup, mesh, input_data, output, outputb, cost, &
&                 costb)
    DO g=mesh%ng,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        row_g = mesh%gauge_pos(1, g)
        col_g = mesh%gauge_pos(2, g)
        qb(row_g, col_g, :) = qb(row_g, col_g, :) + outputb%qsim(g, :)
        outputb%qsim(g, :) = 0.0_4
      ELSE
        row_g = mesh%gauge_pos(1, g)
        col_g = mesh%gauge_pos(2, g)
        k_g = mesh%rowcol_to_ind_sparse(row_g, col_g)
        sparse_qb(k_g, :) = sparse_qb(k_g, :) + outputb%qsim(g, :)
        outputb%qsim(g, :) = 0.0_4
      END IF
    END DO
    parametersb%ci = 0.0_4
    parametersb%cp = 0.0_4
    parametersb%beta = 0.0_4
    parametersb%cft = 0.0_4
    parametersb%alpha = 0.0_4
    parametersb%exc = 0.0_4
    statesb%hi = 0.0_4
    statesb%hp = 0.0_4
    statesb%hft = 0.0_4
    DO t=setup%ntime_step,1,-1
      DO i=mesh%nrow*mesh%ncol,1,-1
        CALL POPCONTROL3B(branch)
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) GOTO 110
        ELSE
          IF (branch .EQ. 2) THEN
            row = mesh%path(1, i)
            col = mesh%path(2, i)
            tempb0 = setup%dx**2*0.001_sp*qb(row, col, t)/setup%dt
            qb(row, col, t) = 0.0_4
            qtb = tempb0
            qupb = REAL(mesh%drained_area(row, col)-1)*tempb0
            CALL UPSTREAM_DISCHARGE_B(setup%dt, setup%dx, setup%&
&                               ntime_step, mesh%nrow, mesh%ncol, mesh%&
&                               flow, mesh%drained_area, row, col, t, q&
&                               , qb, qup, qupb)
          ELSE IF (branch .EQ. 3) THEN
            row = mesh%path(1, i)
            col = mesh%path(2, i)
            tempb0 = setup%dx**2*0.001_sp*sparse_qb(k, t)/setup%dt
            sparse_qb(k, t) = 0.0_4
            qtb = tempb0
            qupb = REAL(mesh%drained_area(row, col)-1)*tempb0
            CALL SPARSE_UPSTREAM_DISCHARGE_B(setup%dt, setup%dx, setup%&
&                                      ntime_step, mesh%nrow, mesh%ncol&
&                                      , mesh%nac, mesh%flow, mesh%&
&                                      drained_area, mesh%&
&                                      rowcol_to_ind_sparse, row, col, t&
&                                      , sparse_q, sparse_qb, qup, qupb)
          ELSE
            qtb = 0.0_4
          END IF
          qdb = qtb
          qrb = qtb
          CALL POPCONTROL2B(branch)
          IF (branch .EQ. 0) THEN
            lb = 0.0_4
            percb = 0.0_4
            prb = 0.0_4
          ELSE
            IF (branch .EQ. 1) THEN
              lb = 0.0_4
              prdb = 0.0_4
            ELSE
              prdb = qdb
              lb = qdb
            END IF
            CALL POPREAL4(states%hft(row, col))
            CALL GR_TRANSFERN_B(5._sp, prcp, prr, prrb, parameters%cft(&
&                         row, col), parametersb%cft(row, col), states%&
&                         hft(row, col), statesb%hft(row, col), qr, qrb)
            prrb = prrb - prdb
            CALL POPREAL4(prr)
            parametersb%alpha(row, col) = parametersb%alpha(row, col) + &
&             (pr+perc)*prrb
            tempb = parameters%alpha(row, col)*prrb
            prb = prdb + tempb
            percb = prdb + tempb
            lb = lb + prrb
          END IF
          CALL POPCONTROL2B(branch)
          IF (branch .NE. 0) THEN
            IF (branch .EQ. 1) THEN
              CALL GR_EXCHANGE_B(parameters%exc(row, col), parametersb%&
&                          exc(row, col), states%hft(row, col), statesb%&
&                          hft(row, col), l, lb)
            ELSE
              GOTO 100
            END IF
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            enb = 0.0_4
            pnb = 0.0_4
          ELSE
            CALL POPREAL4(states%hp(row, col))
            CALL GR_PRODUCTION_B(pn, pnb, en, enb, parameters%cp(row, &
&                          col), parametersb%cp(row, col), parameters%&
&                          beta(row, col), parametersb%beta(row, col), &
&                          states%hp(row, col), statesb%hp(row, col), pr&
&                          , prb, perc, percb)
          END IF
          CALL POPREAL4(en)
          eib = -enb
          CALL POPCONTROL2B(branch)
          IF (branch .NE. 0) THEN
            IF (branch .EQ. 1) THEN
              CALL POPREAL4(states%hi(row, col))
              CALL GR_INTERCEPTION_B(prcp, pet, parameters%ci(row, col)&
&                              , parametersb%ci(row, col), states%hi(row&
&                              , col), statesb%hi(row, col), pn, pnb, ei&
&                              , eib)
            END IF
          END IF
 100      CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL4(pet)
            CALL POPREAL4(prcp)
          ELSE
            CALL POPREAL4(pet)
            CALL POPREAL4(prcp)
          END IF
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) CALL POPINTEGER4(k)
        CALL POPINTEGER4(col)
        CALL POPINTEGER4(row)
 110    CALL POPREAL4(perc)
        CALL POPREAL4(pr)
        CALL POPREAL4(pn)
      END DO
    END DO
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      DEALLOCATE(sparse_q)
      DEALLOCATE(sparse_qb)
    ELSE
      DEALLOCATE(q)
      DEALLOCATE(qb)
    END IF
    parametersb%cst = 0.0_4
    parametersb%lr = 0.0_4
    statesb%hst = 0.0_4
    statesb%hr = 0.0_4
    costb = 0.0_4
  END SUBROUTINE DIRECT_MODEL_B

  SUBROUTINE DIRECT_MODEL(setup, mesh, input_data, parameters, states, &
&   output, cost)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    REAL(sp), INTENT(OUT) :: cost
!~             integer, external :: omp_get_max_threads
    INTEGER :: t, i, row, col, k, g, row_g, col_g, k_g
    REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prd, qd, qr, ql&
&   , qt, qup
    REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: q
    REAL(sp), DIMENSION(:, :), ALLOCATABLE :: sparse_q
    INTRINSIC MIN
    INTRINSIC MAX
    INTRINSIC REAL
    IF (setup%sparse_storage) THEN
      ALLOCATE(sparse_q(mesh%nac, setup%ntime_step))
    ELSE
      ALLOCATE(q(mesh%nrow, mesh%ncol, setup%ntime_step))
    END IF
    cost = 0._sp
    DO t=1,setup%ntime_step
      DO i=1,mesh%nrow*mesh%ncol
        ei = 0._sp
        pn = 0._sp
        en = 0._sp
        pr = 0._sp
        perc = 0._sp
        l = 0._sp
        prr = 0._sp
        prd = 0._sp
        qd = 0._sp
        qr = 0._sp
        ql = 0._sp
        qup = 0._sp
!% {end if: path}
        IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
          row = mesh%path(1, i)
          col = mesh%path(2, i)
          IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, &
&             col)
!% {end if: global active cell}
          IF (mesh%global_active_cell(row, col) .EQ. 1 .AND. mesh%&
&             local_active_cell(row, col) .EQ. 1) THEN
            IF (setup%sparse_storage) THEN
              prcp = input_data%sparse_prcp(k, t)
              pet = input_data%sparse_pet(k, t)
            ELSE
              prcp = input_data%prcp(row, col, t)
              pet = input_data%pet(row, col, t)
            END IF
!% {end if: prcp ge 0}
            IF (prcp .GE. 0) THEN
!% -------------------------------- Interception module case
              SELECT CASE  (setup%interception_module) 
              CASE (0) 
                IF (pet .GT. prcp) THEN
                  ei = prcp
                ELSE
                  ei = pet
                END IF
                IF (0._sp .LT. prcp - ei) THEN
                  pn = prcp - ei
                ELSE
                  pn = 0._sp
                END IF
              CASE (1) 
                CALL GR_INTERCEPTION(prcp, pet, parameters%ci(row, col)&
&                              , states%hi(row, col), pn, ei)
              END SELECT
              en = pet - ei
              SELECT CASE  (setup%production_module) 
              CASE (0) 
!% -------------------------------- Production module case
                CALL GR_PRODUCTION(pn, en, parameters%cp(row, col), &
&                            parameters%beta(row, col), states%hp(row, &
&                            col), pr, perc)
              END SELECT
!% -------------------------------- Exchange module case
              SELECT CASE  (setup%exchange_module) 
              CASE (0) 
                l = 0._sp
              CASE (1) 
                CALL GR_EXCHANGE(parameters%exc(row, col), states%hft(&
&                          row, col), l)
              END SELECT
            END IF
!% ---------------------------- Transfer module case
            SELECT CASE  (setup%transfer_module) 
            CASE (0) 
              prr = parameters%alpha(row, col)*(pr+perc) + l
              prd = pr + perc - prr
              CALL GR_TRANSFERN(5._sp, prcp, prr, parameters%cft(row, &
&                         col), states%hft(row, col), qr)
              IF (0._sp .LT. prd + l) THEN
                qd = prd + l
              ELSE
                qd = 0._sp
              END IF
            END SELECT
            qt = qd + qr + ql
!% ------------------------ Routing module case
            SELECT CASE  (setup%routing_module) 
            CASE (0) 
              IF (setup%sparse_storage) THEN
                CALL SPARSE_UPSTREAM_DISCHARGE(setup%dt, setup%dx, setup&
&                                        %ntime_step, mesh%nrow, mesh%&
&                                        ncol, mesh%nac, mesh%flow, mesh&
&                                        %drained_area, mesh%&
&                                        rowcol_to_ind_sparse, row, col&
&                                        , t, sparse_q, qup)
                sparse_q(k, t) = (qt+qup*REAL(mesh%drained_area(row, col&
&                 )-1))*setup%dx*setup%dx*0.001_sp/setup%dt
              ELSE
                CALL UPSTREAM_DISCHARGE(setup%dt, setup%dx, setup%&
&                                 ntime_step, mesh%nrow, mesh%ncol, mesh&
&                                 %flow, mesh%drained_area, row, col, t&
&                                 , q, qup)
                q(row, col, t) = (qt+qup*REAL(mesh%drained_area(row, col&
&                 )-1))*setup%dx*setup%dx*0.001_sp/setup%dt
              END IF
            END SELECT
          END IF
        END IF
      END DO
    END DO
!% {end do: space}
!% {end do: time}
    DO g=1,mesh%ng
      row_g = mesh%gauge_pos(1, g)
      col_g = mesh%gauge_pos(2, g)
      IF (setup%sparse_storage) THEN
        k_g = mesh%rowcol_to_ind_sparse(row_g, col_g)
        output%qsim(g, :) = sparse_q(k_g, :)
      ELSE
        output%qsim(g, :) = q(row_g, col_g, :)
      END IF
    END DO
    CALL COMPUTE_JOBS(setup, mesh, input_data, output, cost)
  END SUBROUTINE DIRECT_MODEL

END MODULE MW_RUN_DIFF

