!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!%    This module `m_setup` encapsulates all SMASH setup
MODULE M_SETUP_DIFF
  USE M_COMMON, ONLY : sp, dp, lchar, np, ns
  IMPLICIT NONE
  PUBLIC :: setupdt
!%      SetupDT type:
!%
!%      ====================    ==========================================================
!%      `args`                  Description
!%      ====================    ==========================================================
!%      ``start_time``          Start time of simulation in %Y%m%d%H%M format
!%      ``end_time``            End time of simulation in %Y%m%d%H%M format
!%      ``optim_start_time``    Start time of optimization in %Y%m%d%H%M format
!%      ``dt``                  Time step in [s]
!%      ``dx``                  Spatial step in [m] (square cell)
!%      ``nb_time_step``        Number of time step
!%      ``optim_start_step``    Optimization start step
!%      ====================    ==========================================================
  TYPE SETUPDT
      REAL(sp) :: dt=3600._sp
      REAL(sp) :: dx=1000._sp
      CHARACTER(len=lchar) :: start_time='...'
      CHARACTER(len=lchar) :: end_time='...'
      CHARACTER(len=lchar) :: optim_start_time='...'
      INTEGER :: ntime_step=0
      INTEGER :: optim_start_step=1
      LOGICAL :: active_cell_only=.true.
      LOGICAL :: simulation_only=.false.
      LOGICAL :: sparse_storage=.false.
      LOGICAL :: read_qobs=.true.
      CHARACTER(len=lchar) :: qobs_directory='...'
      LOGICAL :: read_prcp=.true.
      CHARACTER(len=lchar) :: prcp_format='tiff'
      REAL(sp) :: prcp_conversion_factor=1._sp
      CHARACTER(len=lchar) :: prcp_directory='...'
      LOGICAL :: read_pet=.true.
      CHARACTER(len=lchar) :: pet_format='tiff'
      REAL(sp) :: pet_conversion_factor=1._sp
      CHARACTER(len=lchar) :: pet_directory='...'
      LOGICAL :: daily_interannual_pet=.false.
      LOGICAL :: mean_forcing=.false.
      REAL(sp), DIMENSION(np) :: default_parameters=(/200._sp, 500._sp, &
&       5._sp/)
      REAL(sp), DIMENSION(ns) :: default_states=(/0.5_sp, 0.01_sp, &
&       0.01_sp/)
  END TYPE SETUPDT
  TYPE SETUPDT_DIFF
      REAL(sp) :: dt=3600._sp
      REAL(sp) :: dx=1000._sp
      REAL(sp) :: prcp_conversion_factor=1._sp
      REAL(sp) :: pet_conversion_factor=1._sp
      REAL(sp), DIMENSION(np) :: default_parameters=(/200._sp, 500._sp, &
&       5._sp/)
      REAL(sp), DIMENSION(ns) :: default_states=(/0.5_sp, 0.01_sp, &
&       0.01_sp/)
  END TYPE SETUPDT_DIFF
END MODULE M_SETUP_DIFF

!%    This module `m_mesh` encapsulates all SMASH mesh
MODULE M_MESH_DIFF
  USE M_COMMON, ONLY : sp, dp, lchar
  USE M_SETUP_DIFF, ONLY : setupdt, setupdt_diff
  IMPLICIT NONE
  PUBLIC :: meshdt
!%      MeshDT type:
!%
!%      ====================    ==========================================================
!%      `args`                  Description
!%      ====================    ==========================================================
!%      ====================    ==========================================================
  TYPE MESHDT
      INTEGER :: nrow
      INTEGER :: ncol
      INTEGER :: ng
      INTEGER :: nac
      INTEGER :: xmin
      INTEGER :: ymax
      INTEGER, DIMENSION(:, :), ALLOCATABLE :: flow
      INTEGER, DIMENSION(:, :), ALLOCATABLE :: drained_area
      INTEGER, DIMENSION(:, :), ALLOCATABLE :: path
      INTEGER, DIMENSION(:, :), ALLOCATABLE :: gauge_pos
      INTEGER, DIMENSION(:), ALLOCATABLE :: gauge_optim
      CHARACTER(len=20), DIMENSION(:), ALLOCATABLE :: code
      REAL(sp), DIMENSION(:), ALLOCATABLE :: area
      INTEGER, DIMENSION(:, :), ALLOCATABLE :: global_active_cell
      INTEGER, DIMENSION(:, :), ALLOCATABLE :: local_active_cell
  END TYPE MESHDT
  TYPE MESHDT_DIFF
      REAL(sp), DIMENSION(:), ALLOCATABLE :: area
  END TYPE MESHDT_DIFF

CONTAINS
  SUBROUTINE MESHDT_INITIALISE(mesh, setup, nrow, ncol, ng)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(INOUT) :: mesh
    INTEGER, INTENT(IN) :: nrow, ncol, ng
    mesh%nrow = nrow
    mesh%ncol = ncol
    mesh%ng = ng
    ALLOCATE(mesh%flow(mesh%nrow, mesh%ncol))
    mesh%flow = -99
    ALLOCATE(mesh%drained_area(mesh%nrow, mesh%ncol))
    mesh%drained_area = -99
    ALLOCATE(mesh%path(2, mesh%nrow*mesh%ncol))
    mesh%path = -99
    ALLOCATE(mesh%gauge_pos(2, mesh%ng))
    ALLOCATE(mesh%gauge_optim(mesh%ng))
    mesh%gauge_optim = 1
    ALLOCATE(mesh%code(mesh%ng))
    ALLOCATE(mesh%area(mesh%ng))
    ALLOCATE(mesh%global_active_cell(mesh%nrow, mesh%ncol))
    mesh%global_active_cell = 0
    ALLOCATE(mesh%local_active_cell(mesh%nrow, mesh%ncol))
    mesh%local_active_cell = 0
  END SUBROUTINE MESHDT_INITIALISE

END MODULE M_MESH_DIFF

!%    This module `m_output` encapsulates all SMASH output
MODULE M_OUTPUT_DIFF
  USE M_COMMON, ONLY : sp, dp, lchar, np, ns
  USE M_SETUP_DIFF, ONLY : setupdt, setupdt_diff
  USE M_MESH_DIFF, ONLY : meshdt, meshdt_diff
  IMPLICIT NONE
  PUBLIC :: outputdt
!%      OutputDT type:
!%
!%      ====================    ==========================================================
!%      `args`                  Description
!%      ====================    ==========================================================
!%      ====================    ==========================================================
  TYPE OUTPUTDT
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: qsim
      REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: qsim_grid
      REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: gradient_parameters
      REAL(sp) :: cost
  END TYPE OUTPUTDT

CONTAINS
  SUBROUTINE OUTPUTDT_INITIALISE(output, setup, mesh)
    IMPLICIT NONE
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(SETUPDT), INTENT(INOUT) :: setup
    TYPE(MESHDT), INTENT(INOUT) :: mesh
    ALLOCATE(output%qsim(mesh%ng, setup%ntime_step))
    output%qsim = -99._sp
    IF (.NOT.setup%active_cell_only) THEN
      ALLOCATE(output%qsim_grid(mesh%nrow, mesh%ncol, setup%ntime_step))
      output%qsim_grid = -99._sp
    END IF
    IF (.NOT.setup%simulation_only) THEN
      ALLOCATE(output%gradient_parameters(mesh%nrow, mesh%ncol, np))
      output%gradient_parameters = 0._sp
    END IF
    output%cost = -99._sp
  END SUBROUTINE OUTPUTDT_INITIALISE

END MODULE M_OUTPUT_DIFF

!%    This module `m_states` encapsulates all SMASH states
MODULE M_STATES_DIFF
  USE M_COMMON, ONLY : sp, dp, lchar, np, ns
  USE M_SETUP_DIFF, ONLY : setupdt, setupdt_diff
  USE M_MESH_DIFF, ONLY : meshdt, meshdt_diff
  IMPLICIT NONE
  PUBLIC :: statesdt, states_derived_type_to_matrix, &
& matrix_to_states_derived_type, vector_to_states_derived_type
  TYPE STATESDT
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hp
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hft
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hr
  END TYPE STATESDT

CONTAINS
  SUBROUTINE STATESDT_INITIALISE(states, setup, mesh)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(STATESDT), INTENT(INOUT) :: states
    INTEGER :: nrow, ncol
    nrow = mesh%nrow
    ncol = mesh%ncol
    ALLOCATE(states%hp(nrow, ncol))
    ALLOCATE(states%hft(nrow, ncol))
    ALLOCATE(states%hr(nrow, ncol))
    CALL VECTOR_TO_STATES_DERIVED_TYPE(setup%default_states, states)
  END SUBROUTINE STATESDT_INITIALISE

  SUBROUTINE STATES_DERIVED_TYPE_TO_MATRIX(states, matrix)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(IN) :: states
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(states%hp, 1), SIZE(states%hp, 2), ns), &
&   INTENT(INOUT) :: matrix
    matrix(:, :, 1) = states%hp(:, :)
    matrix(:, :, 2) = states%hft(:, :)
    matrix(:, :, 3) = states%hr(:, :)
  END SUBROUTINE STATES_DERIVED_TYPE_TO_MATRIX

  SUBROUTINE MATRIX_TO_STATES_DERIVED_TYPE(matrix, states)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(INOUT) :: states
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(states%hp, 1), SIZE(states%hp, 2), ns), &
&   INTENT(IN) :: matrix
    states%hp(:, :) = matrix(:, :, 1)
    states%hft(:, :) = matrix(:, :, 2)
    states%hr(:, :) = matrix(:, :, 3)
  END SUBROUTINE MATRIX_TO_STATES_DERIVED_TYPE

  SUBROUTINE VECTOR_TO_STATES_DERIVED_TYPE(vector, states)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(INOUT) :: states
    REAL(sp), DIMENSION(np), INTENT(IN) :: vector
    states%hp = vector(1)
    states%hft = vector(2)
    states%hr = vector(3)
  END SUBROUTINE VECTOR_TO_STATES_DERIVED_TYPE

END MODULE M_STATES_DIFF

!%    This module `m_parameters` encapsulates all SMASH parameters
MODULE M_PARAMETERS_DIFF
  USE M_COMMON, ONLY : sp, dp, lchar, np, ns
  USE M_SETUP_DIFF, ONLY : setupdt, setupdt_diff
  USE M_MESH_DIFF, ONLY : meshdt, meshdt_diff
  IMPLICIT NONE
  PUBLIC :: parametersdt, parameters_derived_type_to_matrix, &
& matrix_to_parameters_derived_type, vector_to_parameters_derived_type
  TYPE PARAMETERSDT
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cp
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cft
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: lr
  END TYPE PARAMETERSDT

CONTAINS
  SUBROUTINE PARAMETERSDT_INITIALISE(parameters, setup, mesh)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    INTEGER :: nrow, ncol
    nrow = mesh%nrow
    ncol = mesh%ncol
    ALLOCATE(parameters%cp(nrow, ncol))
    ALLOCATE(parameters%cft(nrow, ncol))
    ALLOCATE(parameters%lr(nrow, ncol))
    CALL VECTOR_TO_PARAMETERS_DERIVED_TYPE(setup%default_parameters, &
&                                    parameters)
  END SUBROUTINE PARAMETERSDT_INITIALISE

  SUBROUTINE PARAMETERS_DERIVED_TYPE_TO_MATRIX(parameters, matrix)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(parameters%cp, 1), SIZE(parameters%cp, 2), &
&   np), INTENT(INOUT) :: matrix
    matrix(:, :, 1) = parameters%cp(:, :)
    matrix(:, :, 2) = parameters%cft(:, :)
    matrix(:, :, 3) = parameters%lr(:, :)
  END SUBROUTINE PARAMETERS_DERIVED_TYPE_TO_MATRIX

  SUBROUTINE MATRIX_TO_PARAMETERS_DERIVED_TYPE(matrix, parameters)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(parameters%cp, 1), SIZE(parameters%cp, 2), &
&   np), INTENT(IN) :: matrix
    parameters%cp(:, :) = matrix(:, :, 1)
    parameters%cft(:, :) = matrix(:, :, 2)
    parameters%lr(:, :) = matrix(:, :, 3)
  END SUBROUTINE MATRIX_TO_PARAMETERS_DERIVED_TYPE

  SUBROUTINE VECTOR_TO_PARAMETERS_DERIVED_TYPE(vector, parameters)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    REAL(sp), DIMENSION(np), INTENT(IN) :: vector
    parameters%cp = vector(1)
    parameters%cft = vector(2)
    parameters%lr = vector(3)
  END SUBROUTINE VECTOR_TO_PARAMETERS_DERIVED_TYPE

END MODULE M_PARAMETERS_DIFF

!%    This module `m_data` encapsulates all SMASH data
MODULE M_INPUT_DATA_DIFF
  USE M_COMMON, ONLY : sp, dp, lchar
  USE M_SETUP_DIFF, ONLY : setupdt, setupdt_diff
  USE M_MESH_DIFF, ONLY : meshdt, meshdt_diff
  IMPLICIT NONE
!%      Input_DataDT type:
!%
!%      ====================    ==========================================================
!%      `args`                  Description
!%      ====================    ==========================================================
!%      ====================    ==========================================================
  TYPE INPUT_DATADT
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: qobs
      REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: prcp
      REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: pet
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: sparse_prcp
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: sparse_pet
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: mean_prcp
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: mean_pet
  END TYPE INPUT_DATADT

CONTAINS
  SUBROUTINE INPUT_DATADT_INITIALISE(input_data, setup, mesh)
    IMPLICIT NONE
    TYPE(INPUT_DATADT), INTENT(INOUT) :: input_data
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    IF (.NOT.setup%simulation_only) THEN
      ALLOCATE(input_data%qobs(mesh%ng, setup%ntime_step))
      input_data%qobs = -99._sp
    END IF
    IF (setup%sparse_storage) THEN
      ALLOCATE(input_data%sparse_prcp(mesh%nac, setup%ntime_step))
      input_data%sparse_prcp = -99._sp
      ALLOCATE(input_data%sparse_pet(mesh%nac, setup%ntime_step))
      input_data%sparse_pet = -99._sp
    ELSE
      ALLOCATE(input_data%prcp(mesh%nrow, mesh%ncol, setup%ntime_step))
      input_data%prcp = -99._sp
      ALLOCATE(input_data%pet(mesh%nrow, mesh%ncol, setup%ntime_step))
      input_data%pet = -99._sp
    END IF
    IF (setup%mean_forcing) THEN
      ALLOCATE(input_data%mean_prcp(mesh%ng, setup%ntime_step))
      input_data%mean_prcp = -99._sp
      ALLOCATE(input_data%mean_pet(mesh%ng, setup%ntime_step))
      input_data%mean_pet = -99._sp
    END IF
  END SUBROUTINE INPUT_DATADT_INITIALISE

END MODULE M_INPUT_DATA_DIFF

MODULE M_RUN_DIFF
  USE M_COMMON, ONLY : sp, dp, lchar, np, ns
  USE M_SETUP_DIFF, ONLY : setupdt, setupdt_diff
  USE M_MESH_DIFF, ONLY : meshdt, meshdt_diff
  USE M_INPUT_DATA_DIFF, ONLY : input_datadt, input_datadt_diff
  USE M_PARAMETERS_DIFF, ONLY : parametersdt, parametersdt_diff
  USE M_STATES_DIFF, ONLY : statesdt, statesdt_diff
  USE M_OUTPUT_DIFF, ONLY : outputdt, outputdt_diff
  IMPLICIT NONE
!~     subroutine run_ADJ()
!~     end subroutine run_ADJ
!~     subroutine run_TLM()
!~     end subroutine run_TLM

CONTAINS
!  Differentiation of run_direct in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: *(parameters.cp) cost
!   with respect to varying inputs: *(parameters.cp) cost
!   RW status of diff variables: parameters.cp:(loc) *(parameters.cp):incr
!                parameters.cft:(loc) *(parameters.cft):(loc) parameters.lr:(loc)
!                *(parameters.lr):(loc) setup.dt:(loc) setup.dx:(loc)
!                setup.start_time:(loc) setup.end_time:(loc) setup.optim_start_time:(loc)
!                setup.ntime_step:(loc) setup.optim_start_step:(loc)
!                setup.active_cell_only:(loc) setup.simulation_only:(loc)
!                setup.sparse_storage:(loc) setup.read_qobs:(loc)
!                setup.qobs_directory:(loc) setup.read_prcp:(loc)
!                setup.prcp_format:(loc) setup.prcp_conversion_factor:(loc)
!                setup.prcp_directory:(loc) setup.read_pet:(loc)
!                setup.pet_format:(loc) setup.pet_conversion_factor:(loc)
!                setup.pet_directory:(loc) setup.daily_interannual_pet:(loc)
!                setup.mean_forcing:(loc) setup.default_parameters:(loc)
!                setup.default_states:(loc) input_data.qobs:(loc)
!                *(input_data.qobs):(loc) input_data.prcp:(loc)
!                *(input_data.prcp):(loc) input_data.pet:(loc)
!                *(input_data.pet):(loc) input_data.sparse_prcp:(loc)
!                *(input_data.sparse_prcp):(loc) input_data.sparse_pet:(loc)
!                *(input_data.sparse_pet):(loc) input_data.mean_prcp:(loc)
!                *(input_data.mean_prcp):(loc) input_data.mean_pet:(loc)
!                *(input_data.mean_pet):(loc) mesh.nrow:(loc) mesh.ncol:(loc)
!                mesh.ng:(loc) mesh.nac:(loc) mesh.xmin:(loc) mesh.ymax:(loc)
!                mesh.flow:(loc) mesh.drained_area:(loc) mesh.path:(loc)
!                mesh.gauge_pos:(loc) mesh.gauge_optim:(loc) mesh.code:(loc)
!                mesh.area:(loc) *(mesh.area):(loc) mesh.global_active_cell:(loc)
!                mesh.local_active_cell:(loc) output.qsim:(loc)
!                *(output.qsim):(loc) output.qsim_grid:(loc) *(output.qsim_grid):(loc)
!                output.gradient_parameters:(loc) *(output.gradient_parameters):(loc)
!                output.cost:(loc) states.hp:(loc) *(states.hp):(loc)
!                states.hft:(loc) *(states.hft):(loc) states.hr:(loc)
!                *(states.hr):(loc) cost:in-zero
!   Plus diff mem management of: parameters.cp:in
  SUBROUTINE RUN_DIRECT_B(setup, setupb, mesh, meshb, input_data, &
&   input_datab, parameters, parametersb, states, statesb, output, &
&   outputb, cost, costb)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(SETUPDT_DIFF) :: setupb
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(MESHDT_DIFF) :: meshb
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(INPUT_DATADT) :: input_datab
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(PARAMETERSDT) :: parametersb
    TYPE(STATESDT), INTENT(IN) :: states
    TYPE(STATESDT) :: statesb
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT), INTENT(INOUT) :: outputb
    REAL(sp), INTENT(INOUT) :: cost
    REAL(sp), INTENT(INOUT) :: costb
    INTRINSIC SUM
    parametersb%cp = parametersb%cp + costb
    costb = 0.0_4
  END SUBROUTINE RUN_DIRECT_B

  SUBROUTINE RUN_DIRECT(setup, mesh, input_data, parameters, states, &
&   output, cost)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(STATESDT), INTENT(IN) :: states
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    REAL(sp), INTENT(INOUT) :: cost
    INTRINSIC SUM
    cost = SUM(parameters%cp)
  END SUBROUTINE RUN_DIRECT

END MODULE M_RUN_DIFF

